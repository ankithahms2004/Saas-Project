import {
  require_escape_string_regexp
} from "./chunk-M5EKOYPZ.js";
import {
  require_pluralize
} from "./chunk-O6QFUROF.js";
import {
  require_cloneDeep
} from "./chunk-DXHAEGQH.js";
import {
  create6 as create,
  require_set,
  require_snakeCase
} from "./chunk-BRGDJEWV.js";
import {
  R,
  fn,
  immer_esm_default,
  require_get
} from "./chunk-OV6QPJDJ.js";
import {
  ForwardRef$2r
} from "./chunk-DICHSZ7M.js";
import {
  __commonJS,
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/lodash.deburr/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.deburr/index.js"(exports2, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    var deburredLetters = {
      // Latin-1 Supplement block.
      "Ã€": "A",
      "Ã": "A",
      "Ã‚": "A",
      "Ãƒ": "A",
      "Ã„": "A",
      "Ã…": "A",
      "Ã ": "a",
      "Ã¡": "a",
      "Ã¢": "a",
      "Ã£": "a",
      "Ã¤": "a",
      "Ã¥": "a",
      "Ã‡": "C",
      "Ã§": "c",
      "Ã": "D",
      "Ã°": "d",
      "Ãˆ": "E",
      "Ã‰": "E",
      "ÃŠ": "E",
      "Ã‹": "E",
      "Ã¨": "e",
      "Ã©": "e",
      "Ãª": "e",
      "Ã«": "e",
      "ÃŒ": "I",
      "Ã": "I",
      "ÃŽ": "I",
      "Ã": "I",
      "Ã¬": "i",
      "Ã­": "i",
      "Ã®": "i",
      "Ã¯": "i",
      "Ã‘": "N",
      "Ã±": "n",
      "Ã’": "O",
      "Ã“": "O",
      "Ã”": "O",
      "Ã•": "O",
      "Ã–": "O",
      "Ã˜": "O",
      "Ã²": "o",
      "Ã³": "o",
      "Ã´": "o",
      "Ãµ": "o",
      "Ã¶": "o",
      "Ã¸": "o",
      "Ã™": "U",
      "Ãš": "U",
      "Ã›": "U",
      "Ãœ": "U",
      "Ã¹": "u",
      "Ãº": "u",
      "Ã»": "u",
      "Ã¼": "u",
      "Ã": "Y",
      "Ã½": "y",
      "Ã¿": "y",
      "Ã†": "Ae",
      "Ã¦": "ae",
      "Ãž": "Th",
      "Ã¾": "th",
      "ÃŸ": "ss",
      // Latin Extended-A block.
      "Ä€": "A",
      "Ä‚": "A",
      "Ä„": "A",
      "Ä": "a",
      "Äƒ": "a",
      "Ä…": "a",
      "Ä†": "C",
      "Äˆ": "C",
      "ÄŠ": "C",
      "ÄŒ": "C",
      "Ä‡": "c",
      "Ä‰": "c",
      "Ä‹": "c",
      "Ä": "c",
      "ÄŽ": "D",
      "Ä": "D",
      "Ä": "d",
      "Ä‘": "d",
      "Ä’": "E",
      "Ä”": "E",
      "Ä–": "E",
      "Ä˜": "E",
      "Äš": "E",
      "Ä“": "e",
      "Ä•": "e",
      "Ä—": "e",
      "Ä™": "e",
      "Ä›": "e",
      "Äœ": "G",
      "Äž": "G",
      "Ä ": "G",
      "Ä¢": "G",
      "Ä": "g",
      "ÄŸ": "g",
      "Ä¡": "g",
      "Ä£": "g",
      "Ä¤": "H",
      "Ä¦": "H",
      "Ä¥": "h",
      "Ä§": "h",
      "Ä¨": "I",
      "Äª": "I",
      "Ä¬": "I",
      "Ä®": "I",
      "Ä°": "I",
      "Ä©": "i",
      "Ä«": "i",
      "Ä­": "i",
      "Ä¯": "i",
      "Ä±": "i",
      "Ä´": "J",
      "Äµ": "j",
      "Ä¶": "K",
      "Ä·": "k",
      "Ä¸": "k",
      "Ä¹": "L",
      "Ä»": "L",
      "Ä½": "L",
      "Ä¿": "L",
      "Å": "L",
      "Äº": "l",
      "Ä¼": "l",
      "Ä¾": "l",
      "Å€": "l",
      "Å‚": "l",
      "Åƒ": "N",
      "Å…": "N",
      "Å‡": "N",
      "ÅŠ": "N",
      "Å„": "n",
      "Å†": "n",
      "Åˆ": "n",
      "Å‹": "n",
      "ÅŒ": "O",
      "ÅŽ": "O",
      "Å": "O",
      "Å": "o",
      "Å": "o",
      "Å‘": "o",
      "Å”": "R",
      "Å–": "R",
      "Å˜": "R",
      "Å•": "r",
      "Å—": "r",
      "Å™": "r",
      "Åš": "S",
      "Åœ": "S",
      "Åž": "S",
      "Å ": "S",
      "Å›": "s",
      "Å": "s",
      "ÅŸ": "s",
      "Å¡": "s",
      "Å¢": "T",
      "Å¤": "T",
      "Å¦": "T",
      "Å£": "t",
      "Å¥": "t",
      "Å§": "t",
      "Å¨": "U",
      "Åª": "U",
      "Å¬": "U",
      "Å®": "U",
      "Å°": "U",
      "Å²": "U",
      "Å©": "u",
      "Å«": "u",
      "Å­": "u",
      "Å¯": "u",
      "Å±": "u",
      "Å³": "u",
      "Å´": "W",
      "Åµ": "w",
      "Å¶": "Y",
      "Å·": "y",
      "Å¸": "Y",
      "Å¹": "Z",
      "Å»": "Z",
      "Å½": "Z",
      "Åº": "z",
      "Å¼": "z",
      "Å¾": "z",
      "Ä²": "IJ",
      "Ä³": "ij",
      "Å’": "Oe",
      "Å“": "oe",
      "Å‰": "'n",
      "Å¿": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol = root.Symbol;
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js"(exports2, module) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/@sindresorhus/transliterate/replacements.js
var require_replacements = __commonJS({
  "node_modules/@sindresorhus/transliterate/replacements.js"(exports2, module) {
    "use strict";
    module.exports = [
      // German umlauts
      ["ÃŸ", "ss"],
      ["Ã¤", "ae"],
      ["Ã„", "Ae"],
      ["Ã¶", "oe"],
      ["Ã–", "Oe"],
      ["Ã¼", "ue"],
      ["Ãœ", "Ue"],
      // Latin
      ["Ã€", "A"],
      ["Ã", "A"],
      ["Ã‚", "A"],
      ["Ãƒ", "A"],
      ["Ã„", "Ae"],
      ["Ã…", "A"],
      ["Ã†", "AE"],
      ["Ã‡", "C"],
      ["Ãˆ", "E"],
      ["Ã‰", "E"],
      ["ÃŠ", "E"],
      ["Ã‹", "E"],
      ["ÃŒ", "I"],
      ["Ã", "I"],
      ["ÃŽ", "I"],
      ["Ã", "I"],
      ["Ã", "D"],
      ["Ã‘", "N"],
      ["Ã’", "O"],
      ["Ã“", "O"],
      ["Ã”", "O"],
      ["Ã•", "O"],
      ["Ã–", "Oe"],
      ["Å", "O"],
      ["Ã˜", "O"],
      ["Ã™", "U"],
      ["Ãš", "U"],
      ["Ã›", "U"],
      ["Ãœ", "Ue"],
      ["Å°", "U"],
      ["Ã", "Y"],
      ["Ãž", "TH"],
      ["ÃŸ", "ss"],
      ["Ã ", "a"],
      ["Ã¡", "a"],
      ["Ã¢", "a"],
      ["Ã£", "a"],
      ["Ã¤", "ae"],
      ["Ã¥", "a"],
      ["Ã¦", "ae"],
      ["Ã§", "c"],
      ["Ã¨", "e"],
      ["Ã©", "e"],
      ["Ãª", "e"],
      ["Ã«", "e"],
      ["Ã¬", "i"],
      ["Ã­", "i"],
      ["Ã®", "i"],
      ["Ã¯", "i"],
      ["Ã°", "d"],
      ["Ã±", "n"],
      ["Ã²", "o"],
      ["Ã³", "o"],
      ["Ã´", "o"],
      ["Ãµ", "o"],
      ["Ã¶", "oe"],
      ["Å‘", "o"],
      ["Ã¸", "o"],
      ["Ã¹", "u"],
      ["Ãº", "u"],
      ["Ã»", "u"],
      ["Ã¼", "ue"],
      ["Å±", "u"],
      ["Ã½", "y"],
      ["Ã¾", "th"],
      ["Ã¿", "y"],
      ["áºž", "SS"],
      // Vietnamese
      ["Ã ", "a"],
      ["Ã€", "A"],
      ["Ã¡", "a"],
      ["Ã", "A"],
      ["Ã¢", "a"],
      ["Ã‚", "A"],
      ["Ã£", "a"],
      ["Ãƒ", "A"],
      ["Ã¨", "e"],
      ["Ãˆ", "E"],
      ["Ã©", "e"],
      ["Ã‰", "E"],
      ["Ãª", "e"],
      ["ÃŠ", "E"],
      ["Ã¬", "i"],
      ["ÃŒ", "I"],
      ["Ã­", "i"],
      ["Ã", "I"],
      ["Ã²", "o"],
      ["Ã’", "O"],
      ["Ã³", "o"],
      ["Ã“", "O"],
      ["Ã´", "o"],
      ["Ã”", "O"],
      ["Ãµ", "o"],
      ["Ã•", "O"],
      ["Ã¹", "u"],
      ["Ã™", "U"],
      ["Ãº", "u"],
      ["Ãš", "U"],
      ["Ã½", "y"],
      ["Ã", "Y"],
      ["Äƒ", "a"],
      ["Ä‚", "A"],
      ["Ä", "D"],
      ["Ä‘", "d"],
      ["Ä©", "i"],
      ["Ä¨", "I"],
      ["Å©", "u"],
      ["Å¨", "U"],
      ["Æ¡", "o"],
      ["Æ ", "O"],
      ["Æ°", "u"],
      ["Æ¯", "U"],
      ["áº¡", "a"],
      ["áº ", "A"],
      ["áº£", "a"],
      ["áº¢", "A"],
      ["áº¥", "a"],
      ["áº¤", "A"],
      ["áº§", "a"],
      ["áº¦", "A"],
      ["áº©", "a"],
      ["áº¨", "A"],
      ["áº«", "a"],
      ["áºª", "A"],
      ["áº­", "a"],
      ["áº¬", "A"],
      ["áº¯", "a"],
      ["áº®", "A"],
      ["áº±", "a"],
      ["áº°", "A"],
      ["áº³", "a"],
      ["áº²", "A"],
      ["áºµ", "a"],
      ["áº´", "A"],
      ["áº·", "a"],
      ["áº¶", "A"],
      ["áº¹", "e"],
      ["áº¸", "E"],
      ["áº»", "e"],
      ["áºº", "E"],
      ["áº½", "e"],
      ["áº¼", "E"],
      ["áº¿", "e"],
      ["áº¾", "E"],
      ["á»", "e"],
      ["á»€", "E"],
      ["á»ƒ", "e"],
      ["á»‚", "E"],
      ["á»…", "e"],
      ["á»„", "E"],
      ["á»‡", "e"],
      ["á»†", "E"],
      ["á»‰", "i"],
      ["á»ˆ", "I"],
      ["á»‹", "i"],
      ["á»Š", "I"],
      ["á»", "o"],
      ["á»Œ", "O"],
      ["á»", "o"],
      ["á»Ž", "O"],
      ["á»‘", "o"],
      ["á»", "O"],
      ["á»“", "o"],
      ["á»’", "O"],
      ["á»•", "o"],
      ["á»”", "O"],
      ["á»—", "o"],
      ["á»–", "O"],
      ["á»™", "o"],
      ["á»˜", "O"],
      ["á»›", "o"],
      ["á»š", "O"],
      ["á»", "o"],
      ["á»œ", "O"],
      ["á»Ÿ", "o"],
      ["á»ž", "O"],
      ["á»¡", "o"],
      ["á» ", "O"],
      ["á»£", "o"],
      ["á»¢", "O"],
      ["á»¥", "u"],
      ["á»¤", "U"],
      ["á»§", "u"],
      ["á»¦", "U"],
      ["á»©", "u"],
      ["á»¨", "U"],
      ["á»«", "u"],
      ["á»ª", "U"],
      ["á»­", "u"],
      ["á»¬", "U"],
      ["á»¯", "u"],
      ["á»®", "U"],
      ["á»±", "u"],
      ["á»°", "U"],
      ["á»³", "y"],
      ["á»²", "Y"],
      ["á»µ", "y"],
      ["á»´", "Y"],
      ["á»·", "y"],
      ["á»¶", "Y"],
      ["á»¹", "y"],
      ["á»¸", "Y"],
      // Arabic
      ["Ø¡", "e"],
      ["Ø¢", "a"],
      ["Ø£", "a"],
      ["Ø¤", "w"],
      ["Ø¥", "i"],
      ["Ø¦", "y"],
      ["Ø§", "a"],
      ["Ø¨", "b"],
      ["Ø©", "t"],
      ["Øª", "t"],
      ["Ø«", "th"],
      ["Ø¬", "j"],
      ["Ø­", "h"],
      ["Ø®", "kh"],
      ["Ø¯", "d"],
      ["Ø°", "dh"],
      ["Ø±", "r"],
      ["Ø²", "z"],
      ["Ø³", "s"],
      ["Ø´", "sh"],
      ["Øµ", "s"],
      ["Ø¶", "d"],
      ["Ø·", "t"],
      ["Ø¸", "z"],
      ["Ø¹", "e"],
      ["Øº", "gh"],
      ["Ù€", "_"],
      ["Ù", "f"],
      ["Ù‚", "q"],
      ["Ùƒ", "k"],
      ["Ù„", "l"],
      ["Ù…", "m"],
      ["Ù†", "n"],
      ["Ù‡", "h"],
      ["Ùˆ", "w"],
      ["Ù‰", "a"],
      ["ÙŠ", "y"],
      ["ÙŽâ€Ž", "a"],
      ["Ù", "u"],
      ["Ùâ€Ž", "i"],
      ["Ù ", "0"],
      ["Ù¡", "1"],
      ["Ù¢", "2"],
      ["Ù£", "3"],
      ["Ù¤", "4"],
      ["Ù¥", "5"],
      ["Ù¦", "6"],
      ["Ù§", "7"],
      ["Ù¨", "8"],
      ["Ù©", "9"],
      // Persian / Farsi
      ["Ú†", "ch"],
      ["Ú©", "k"],
      ["Ú¯", "g"],
      ["Ù¾", "p"],
      ["Ú˜", "zh"],
      ["ÛŒ", "y"],
      ["Û°", "0"],
      ["Û±", "1"],
      ["Û²", "2"],
      ["Û³", "3"],
      ["Û´", "4"],
      ["Ûµ", "5"],
      ["Û¶", "6"],
      ["Û·", "7"],
      ["Û¸", "8"],
      ["Û¹", "9"],
      // Pashto
      ["Ù¼", "p"],
      ["Ú", "z"],
      ["Ú…", "c"],
      ["Ú‰", "d"],
      ["ïº«", "d"],
      ["ïº­", "r"],
      ["Ú“", "r"],
      ["ïº¯", "z"],
      ["Ú–", "g"],
      ["Úš", "x"],
      ["Ú«", "g"],
      ["Ú¼", "n"],
      ["Û€", "e"],
      ["Û", "e"],
      ["Û", "ai"],
      // Urdu
      ["Ù¹", "t"],
      ["Úˆ", "d"],
      ["Ú‘", "r"],
      ["Úº", "n"],
      ["Û", "h"],
      ["Ú¾", "h"],
      ["Û’", "e"],
      // Russian
      ["Ð", "A"],
      ["Ð°", "a"],
      ["Ð‘", "B"],
      ["Ð±", "b"],
      ["Ð’", "V"],
      ["Ð²", "v"],
      ["Ð“", "G"],
      ["Ð³", "g"],
      ["Ð”", "D"],
      ["Ð´", "d"],
      ["Ð•", "E"],
      ["Ðµ", "e"],
      ["Ð–", "Zh"],
      ["Ð¶", "zh"],
      ["Ð—", "Z"],
      ["Ð·", "z"],
      ["Ð˜", "I"],
      ["Ð¸", "i"],
      ["Ð™", "J"],
      ["Ð¹", "j"],
      ["Ðš", "K"],
      ["Ðº", "k"],
      ["Ð›", "L"],
      ["Ð»", "l"],
      ["Ðœ", "M"],
      ["Ð¼", "m"],
      ["Ð", "N"],
      ["Ð½", "n"],
      ["Ðž", "O"],
      ["Ð¾", "o"],
      ["ÐŸ", "P"],
      ["Ð¿", "p"],
      ["Ð ", "R"],
      ["Ñ€", "r"],
      ["Ð¡", "S"],
      ["Ñ", "s"],
      ["Ð¢", "T"],
      ["Ñ‚", "t"],
      ["Ð£", "U"],
      ["Ñƒ", "u"],
      ["Ð¤", "F"],
      ["Ñ„", "f"],
      ["Ð¥", "H"],
      ["Ñ…", "h"],
      ["Ð¦", "Cz"],
      ["Ñ†", "cz"],
      ["Ð§", "Ch"],
      ["Ñ‡", "ch"],
      ["Ð¨", "Sh"],
      ["Ñˆ", "sh"],
      ["Ð©", "Shh"],
      ["Ñ‰", "shh"],
      ["Ðª", ""],
      ["ÑŠ", ""],
      ["Ð«", "Y"],
      ["Ñ‹", "y"],
      ["Ð¬", ""],
      ["ÑŒ", ""],
      ["Ð­", "E"],
      ["Ñ", "e"],
      ["Ð®", "Yu"],
      ["ÑŽ", "yu"],
      ["Ð¯", "Ya"],
      ["Ñ", "ya"],
      ["Ð", "Yo"],
      ["Ñ‘", "yo"],
      // Romanian
      ["Äƒ", "a"],
      ["Ä‚", "A"],
      ["È™", "s"],
      ["È˜", "S"],
      ["È›", "t"],
      ["Èš", "T"],
      ["Å£", "t"],
      ["Å¢", "T"],
      // Turkish
      ["ÅŸ", "s"],
      ["Åž", "S"],
      ["Ã§", "c"],
      ["Ã‡", "C"],
      ["ÄŸ", "g"],
      ["Äž", "G"],
      ["Ä±", "i"],
      ["Ä°", "I"],
      // Armenian
      ["Õ¡", "a"],
      ["Ô±", "A"],
      ["Õ¢", "b"],
      ["Ô²", "B"],
      ["Õ£", "g"],
      ["Ô³", "G"],
      ["Õ¤", "d"],
      ["Ô´", "D"],
      ["Õ¥", "ye"],
      ["Ôµ", "Ye"],
      ["Õ¦", "z"],
      ["Ô¶", "Z"],
      ["Õ§", "e"],
      ["Ô·", "E"],
      ["Õ¨", "y"],
      ["Ô¸", "Y"],
      ["Õ©", "t"],
      ["Ô¹", "T"],
      ["Õª", "zh"],
      ["Ôº", "Zh"],
      ["Õ«", "i"],
      ["Ô»", "I"],
      ["Õ¬", "l"],
      ["Ô¼", "L"],
      ["Õ­", "kh"],
      ["Ô½", "Kh"],
      ["Õ®", "ts"],
      ["Ô¾", "Ts"],
      ["Õ¯", "k"],
      ["Ô¿", "K"],
      ["Õ°", "h"],
      ["Õ€", "H"],
      ["Õ±", "dz"],
      ["Õ", "Dz"],
      ["Õ²", "gh"],
      ["Õ‚", "Gh"],
      ["Õ³", "tch"],
      ["Õƒ", "Tch"],
      ["Õ´", "m"],
      ["Õ„", "M"],
      ["Õµ", "y"],
      ["Õ…", "Y"],
      ["Õ¶", "n"],
      ["Õ†", "N"],
      ["Õ·", "sh"],
      ["Õ‡", "Sh"],
      ["Õ¸", "vo"],
      ["Õˆ", "Vo"],
      ["Õ¹", "ch"],
      ["Õ‰", "Ch"],
      ["Õº", "p"],
      ["ÕŠ", "P"],
      ["Õ»", "j"],
      ["Õ‹", "J"],
      ["Õ¼", "r"],
      ["ÕŒ", "R"],
      ["Õ½", "s"],
      ["Õ", "S"],
      ["Õ¾", "v"],
      ["ÕŽ", "V"],
      ["Õ¿", "t"],
      ["Õ", "T"],
      ["Ö€", "r"],
      ["Õ", "R"],
      ["Ö", "c"],
      ["Õ‘", "C"],
      ["Õ¸Ö‚", "u"],
      ["ÕˆÕ’", "U"],
      ["ÕˆÖ‚", "U"],
      ["Öƒ", "p"],
      ["Õ“", "P"],
      ["Ö„", "q"],
      ["Õ”", "Q"],
      ["Ö…", "o"],
      ["Õ•", "O"],
      ["Ö†", "f"],
      ["Õ–", "F"],
      ["Ö‡", "yev"],
      // Georgian
      ["áƒ", "a"],
      ["áƒ‘", "b"],
      ["áƒ’", "g"],
      ["áƒ“", "d"],
      ["áƒ”", "e"],
      ["áƒ•", "v"],
      ["áƒ–", "z"],
      ["áƒ—", "t"],
      ["áƒ˜", "i"],
      ["áƒ™", "k"],
      ["áƒš", "l"],
      ["áƒ›", "m"],
      ["áƒœ", "n"],
      ["áƒ", "o"],
      ["áƒž", "p"],
      ["áƒŸ", "zh"],
      ["áƒ ", "r"],
      ["áƒ¡", "s"],
      ["áƒ¢", "t"],
      ["áƒ£", "u"],
      ["áƒ¤", "ph"],
      ["áƒ¥", "q"],
      ["áƒ¦", "gh"],
      ["áƒ§", "k"],
      ["áƒ¨", "sh"],
      ["áƒ©", "ch"],
      ["áƒª", "ts"],
      ["áƒ«", "dz"],
      ["áƒ¬", "ts"],
      ["áƒ­", "tch"],
      ["áƒ®", "kh"],
      ["áƒ¯", "j"],
      ["áƒ°", "h"],
      // Czech
      ["Ä", "c"],
      ["Ä", "d"],
      ["Ä›", "e"],
      ["Åˆ", "n"],
      ["Å™", "r"],
      ["Å¡", "s"],
      ["Å¥", "t"],
      ["Å¯", "u"],
      ["Å¾", "z"],
      ["ÄŒ", "C"],
      ["ÄŽ", "D"],
      ["Äš", "E"],
      ["Å‡", "N"],
      ["Å˜", "R"],
      ["Å ", "S"],
      ["Å¤", "T"],
      ["Å®", "U"],
      ["Å½", "Z"],
      // Dhivehi
      ["Þ€", "h"],
      ["Þ", "sh"],
      ["Þ‚", "n"],
      ["Þƒ", "r"],
      ["Þ„", "b"],
      ["Þ…", "lh"],
      ["Þ†", "k"],
      ["Þ‡", "a"],
      ["Þˆ", "v"],
      ["Þ‰", "m"],
      ["ÞŠ", "f"],
      ["Þ‹", "dh"],
      ["ÞŒ", "th"],
      ["Þ", "l"],
      ["ÞŽ", "g"],
      ["Þ", "gn"],
      ["Þ", "s"],
      ["Þ‘", "d"],
      ["Þ’", "z"],
      ["Þ“", "t"],
      ["Þ”", "y"],
      ["Þ•", "p"],
      ["Þ–", "j"],
      ["Þ—", "ch"],
      ["Þ˜", "tt"],
      ["Þ™", "hh"],
      ["Þš", "kh"],
      ["Þ›", "th"],
      ["Þœ", "z"],
      ["Þ", "sh"],
      ["Þž", "s"],
      ["ÞŸ", "d"],
      ["Þ ", "t"],
      ["Þ¡", "z"],
      ["Þ¢", "a"],
      ["Þ£", "gh"],
      ["Þ¤", "q"],
      ["Þ¥", "w"],
      ["Þ¦", "a"],
      ["Þ§", "aa"],
      ["Þ¨", "i"],
      ["Þ©", "ee"],
      ["Þª", "u"],
      ["Þ«", "oo"],
      ["Þ¬", "e"],
      ["Þ­", "ey"],
      ["Þ®", "o"],
      ["Þ¯", "oa"],
      ["Þ°", ""],
      // Greek
      ["Î±", "a"],
      ["Î²", "v"],
      ["Î³", "g"],
      ["Î´", "d"],
      ["Îµ", "e"],
      ["Î¶", "z"],
      ["Î·", "i"],
      ["Î¸", "th"],
      ["Î¹", "i"],
      ["Îº", "k"],
      ["Î»", "l"],
      ["Î¼", "m"],
      ["Î½", "n"],
      ["Î¾", "ks"],
      ["Î¿", "o"],
      ["Ï€", "p"],
      ["Ï", "r"],
      ["Ïƒ", "s"],
      ["Ï„", "t"],
      ["Ï…", "y"],
      ["Ï†", "f"],
      ["Ï‡", "x"],
      ["Ïˆ", "ps"],
      ["Ï‰", "o"],
      ["Î¬", "a"],
      ["Î­", "e"],
      ["Î¯", "i"],
      ["ÏŒ", "o"],
      ["Ï", "y"],
      ["Î®", "i"],
      ["ÏŽ", "o"],
      ["Ï‚", "s"],
      ["ÏŠ", "i"],
      ["Î°", "y"],
      ["Ï‹", "y"],
      ["Î", "i"],
      ["Î‘", "A"],
      ["Î’", "B"],
      ["Î“", "G"],
      ["Î”", "D"],
      ["Î•", "E"],
      ["Î–", "Z"],
      ["Î—", "I"],
      ["Î˜", "TH"],
      ["Î™", "I"],
      ["Îš", "K"],
      ["Î›", "L"],
      ["Îœ", "M"],
      ["Î", "N"],
      ["Îž", "KS"],
      ["ÎŸ", "O"],
      ["Î ", "P"],
      ["Î¡", "R"],
      ["Î£", "S"],
      ["Î¤", "T"],
      ["Î¥", "Y"],
      ["Î¦", "F"],
      ["Î§", "X"],
      ["Î¨", "PS"],
      ["Î©", "O"],
      ["Î†", "A"],
      ["Îˆ", "E"],
      ["ÎŠ", "I"],
      ["ÎŒ", "O"],
      ["ÎŽ", "Y"],
      ["Î‰", "I"],
      ["Î", "O"],
      ["Îª", "I"],
      ["Î«", "Y"],
      // Disabled as it conflicts with German and Latin.
      // Hungarian
      // ['Ã¤', 'a'],
      // ['Ã„', 'A'],
      // ['Ã¶', 'o'],
      // ['Ã–', 'O'],
      // ['Ã¼', 'u'],
      // ['Ãœ', 'U'],
      // ['Å±', 'u'],
      // ['Å°', 'U'],
      // Latvian
      ["Ä", "a"],
      ["Ä“", "e"],
      ["Ä£", "g"],
      ["Ä«", "i"],
      ["Ä·", "k"],
      ["Ä¼", "l"],
      ["Å†", "n"],
      ["Å«", "u"],
      ["Ä€", "A"],
      ["Ä’", "E"],
      ["Ä¢", "G"],
      ["Äª", "I"],
      ["Ä¶", "K"],
      ["Ä»", "L"],
      ["Å…", "N"],
      ["Åª", "U"],
      ["Ä", "c"],
      ["Å¡", "s"],
      ["Å¾", "z"],
      ["ÄŒ", "C"],
      ["Å ", "S"],
      ["Å½", "Z"],
      // Lithuanian
      ["Ä…", "a"],
      ["Ä", "c"],
      ["Ä™", "e"],
      ["Ä—", "e"],
      ["Ä¯", "i"],
      ["Å¡", "s"],
      ["Å³", "u"],
      ["Å«", "u"],
      ["Å¾", "z"],
      ["Ä„", "A"],
      ["ÄŒ", "C"],
      ["Ä˜", "E"],
      ["Ä–", "E"],
      ["Ä®", "I"],
      ["Å ", "S"],
      ["Å²", "U"],
      ["Åª", "U"],
      // Macedonian
      ["ÐŒ", "Kj"],
      ["Ñœ", "kj"],
      ["Ð‰", "Lj"],
      ["Ñ™", "lj"],
      ["ÐŠ", "Nj"],
      ["Ñš", "nj"],
      ["Ð¢Ñ", "Ts"],
      ["Ñ‚Ñ", "ts"],
      // Polish
      ["Ä…", "a"],
      ["Ä‡", "c"],
      ["Ä™", "e"],
      ["Å‚", "l"],
      ["Å„", "n"],
      ["Å›", "s"],
      ["Åº", "z"],
      ["Å¼", "z"],
      ["Ä„", "A"],
      ["Ä†", "C"],
      ["Ä˜", "E"],
      ["Å", "L"],
      ["Åƒ", "N"],
      ["Åš", "S"],
      ["Å¹", "Z"],
      ["Å»", "Z"],
      // Disabled as it conflicts with Vietnamese.
      // Serbian
      // ['Ñ™', 'lj'],
      // ['Ñš', 'nj'],
      // ['Ð‰', 'Lj'],
      // ['ÐŠ', 'Nj'],
      // ['Ä‘', 'dj'],
      // ['Ä', 'Dj'],
      // ['Ñ’', 'dj'],
      // ['Ñ˜', 'j'],
      // ['Ñ›', 'c'],
      // ['ÑŸ', 'dz'],
      // ['Ð‚', 'Dj'],
      // ['Ðˆ', 'j'],
      // ['Ð‹', 'C'],
      // ['Ð', 'Dz'],
      // Disabled as it conflicts with German and Latin.
      // Slovak
      // ['Ã¤', 'a'],
      // ['Ã„', 'A'],
      // ['Ä¾', 'l'],
      // ['Äº', 'l'],
      // ['Å•', 'r'],
      // ['Ä½', 'L'],
      // ['Ä¹', 'L'],
      // ['Å”', 'R'],
      // Disabled as it conflicts with German and Latin.
      // Swedish
      // ['Ã¥', 'o'],
      // ['Ã…', 'o'],
      // ['Ã¤', 'a'],
      // ['Ã„', 'A'],
      // ['Ã«', 'e'],
      // ['Ã‹', 'E'],
      // ['Ã¶', 'o'],
      // ['Ã–', 'O'],
      // Ukrainian
      ["Ð„", "Ye"],
      ["Ð†", "I"],
      ["Ð‡", "Yi"],
      ["Ò", "G"],
      ["Ñ”", "ye"],
      ["Ñ–", "i"],
      ["Ñ—", "yi"],
      ["Ò‘", "g"]
      // Danish
      // ['Ã†', 'Ae'],
      // ['Ã˜', 'Oe'],
      // ['Ã…', 'Aa'],
      // ['Ã¦', 'ae'],
      // ['Ã¸', 'oe'],
      // ['Ã¥', 'aa']
    ];
  }
});

// node_modules/@sindresorhus/transliterate/index.js
var require_transliterate = __commonJS({
  "node_modules/@sindresorhus/transliterate/index.js"(exports2, module) {
    "use strict";
    var deburr = require_lodash();
    var escapeStringRegexp = require_escape_string_regexp2();
    var builtinReplacements = require_replacements();
    var doCustomReplacements = (string, replacements) => {
      for (const [key, value] of replacements) {
        string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value);
      }
      return string;
    };
    module.exports = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = {
        customReplacements: [],
        ...options
      };
      const customReplacements = new Map([
        ...builtinReplacements,
        ...options.customReplacements
      ]);
      string = string.normalize();
      string = doCustomReplacements(string, customReplacements);
      string = deburr(string);
      return string;
    };
  }
});

// node_modules/@sindresorhus/slugify/overridable-replacements.js
var require_overridable_replacements = __commonJS({
  "node_modules/@sindresorhus/slugify/overridable-replacements.js"(exports2, module) {
    "use strict";
    module.exports = [
      ["&", " and "],
      ["ðŸ¦„", " unicorn "],
      ["â™¥", " love "]
    ];
  }
});

// node_modules/@sindresorhus/slugify/index.js
var require_slugify = __commonJS({
  "node_modules/@sindresorhus/slugify/index.js"(exports2, module) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var transliterate = require_transliterate();
    var builtinOverridableReplacements = require_overridable_replacements();
    var decamelize = (string) => {
      return string.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
    };
    var removeMootSeparators = (string, separator) => {
      const escapedSeparator = escapeStringRegexp(separator);
      return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
    };
    var slugify2 = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = {
        separator: "-",
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false,
        ...options
      };
      const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
      const customReplacements = new Map([
        ...builtinOverridableReplacements,
        ...options.customReplacements
      ]);
      string = transliterate(string, { customReplacements });
      if (options.decamelize) {
        string = decamelize(string);
      }
      let patternSlug = /[^a-zA-Z\d]+/g;
      if (options.lowercase) {
        string = string.toLowerCase();
        patternSlug = /[^a-z\d]+/g;
      }
      string = string.replace(patternSlug, options.separator);
      string = string.replace(/\\/g, "");
      if (options.separator) {
        string = removeMootSeparators(string, options.separator);
      }
      if (shouldPrependUnderscore) {
        string = `_${string}`;
      }
      return string;
    };
    var counter = () => {
      const occurrences = /* @__PURE__ */ new Map();
      const countable = (string, options) => {
        string = slugify2(string, options);
        if (!string) {
          return "";
        }
        const stringLower = string.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
        const counter2 = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter2 === "number" ? counter2 + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
          string = `${string}-${newCounter}`;
        }
        return string;
      };
      countable.reset = () => {
        occurrences.clear();
      };
      return countable;
    };
    module.exports = slugify2;
    module.exports.counter = counter;
  }
});

// node_modules/@strapi/content-type-builder/dist/_chunks/index-CWMd-Uk7.mjs
var import_get = __toESM(require_get(), 1);
var import_set = __toESM(require_set(), 1);
var import_snakeCase = __toESM(require_snakeCase(), 1);
var import_pluralize = __toESM(require_pluralize(), 1);
var import_slugify = __toESM(require_slugify(), 1);
var import_cloneDeep = __toESM(require_cloneDeep(), 1);
var __variableDynamicImportRuntimeHelper = (glob, path) => {
  const v = glob[path];
  if (v) {
    return typeof v === "function" ? v() : Promise.resolve(v);
  }
  return new Promise((_, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path)));
  });
};
var name$1 = "@strapi/content-type-builder";
var version = "5.0.0-rc.13";
var description = "Create and manage content types";
var repository = {
  type: "git",
  url: "git://github.com/strapi/strapi.git"
};
var license = "SEE LICENSE IN LICENSE";
var author = {
  name: "Strapi Solutions SAS",
  email: "hi@strapi.io",
  url: "https://strapi.io"
};
var maintainers = [
  {
    name: "Strapi Solutions SAS",
    email: "hi@strapi.io",
    url: "https://strapi.io"
  }
];
var exports = {
  "./strapi-admin": {
    types: "./dist/admin/src/index.d.ts",
    source: "./admin/src/index.ts",
    "import": "./dist/admin/index.mjs",
    require: "./dist/admin/index.js",
    "default": "./dist/admin/index.js"
  },
  "./strapi-server": {
    types: "./dist/server/src/index.d.ts",
    source: "./server/src/index.ts",
    "import": "./dist/server/index.mjs",
    require: "./dist/server/index.js",
    "default": "./dist/server/index.js"
  },
  "./package.json": "./package.json"
};
var types = "./dist/index.d.ts";
var files = [
  "dist/",
  "strapi-server.js"
];
var scripts = {
  build: "pack-up build",
  clean: "run -T rimraf ./dist",
  lint: "run -T eslint .",
  "test:front": "run -T cross-env IS_EE=true jest --config ./jest.config.front.js",
  "test:front:ce": "run -T cross-env IS_EE=false jest --config ./jest.config.front.js",
  "test:front:watch": "run -T cross-env IS_EE=true jest --config ./jest.config.front.js --watchAll",
  "test:front:watch:ce": "run -T cross-env IS_EE=false jest --config ./jest.config.front.js --watchAll",
  "test:ts:back": "run -T tsc -p server/tsconfig.eslint.json",
  "test:ts:front": "run -T tsc -p admin/tsconfig.json",
  "test:unit": "run -T jest",
  "test:unit:watch": "run -T jest --watch",
  watch: "pack-up watch"
};
var dependencies = {
  "@reduxjs/toolkit": "1.9.7",
  "@sindresorhus/slugify": "1.1.0",
  "@strapi/design-system": "2.0.0-rc.10",
  "@strapi/generators": "workspace:*",
  "@strapi/icons": "2.0.0-rc.10",
  "@strapi/utils": "workspace:*",
  "date-fns": "2.30.0",
  "fs-extra": "11.2.0",
  immer: "9.0.21",
  lodash: "4.17.21",
  pluralize: "8.0.0",
  qs: "6.11.1",
  "react-intl": "6.6.2",
  "react-redux": "8.1.3",
  yup: "0.32.9"
};
var devDependencies = {
  "@strapi/admin": "workspace:*",
  "@strapi/pack-up": "5.0.0",
  "@strapi/types": "workspace:*",
  "@testing-library/dom": "10.1.0",
  "@testing-library/react": "15.0.7",
  "@testing-library/user-event": "14.5.2",
  "@types/fs-extra": "11.0.4",
  "@types/pluralize": "0.0.30",
  koa: "2.15.2",
  "koa-body": "6.0.1",
  react: "18.3.1",
  "react-dom": "18.3.1",
  "react-query": "3.39.3",
  "react-router-dom": "6.22.3",
  "styled-components": "6.1.8"
};
var peerDependencies = {
  "@strapi/admin": "^5.0.0 || ^5.0.0-beta || ^5.0.0-alpha || ^5.0.0-rc",
  react: "^17.0.0 || ^18.0.0",
  "react-dom": "^17.0.0 || ^18.0.0",
  "react-router-dom": "^6.0.0",
  "styled-components": "^6.0.0"
};
var engines = {
  node: ">=18.0.0 <=20.x.x",
  npm: ">=6.0.0"
};
var strapi = {
  name: "content-type-builder",
  displayName: "Content Type Builder",
  description: "Modelize the data structure of your API. Create new fields and relations in just a minute. The files are automatically created and updated in your project.",
  kind: "plugin",
  required: true
};
var pluginPkg = {
  name: name$1,
  version,
  description,
  repository,
  license,
  author,
  maintainers,
  exports,
  types,
  files,
  scripts,
  dependencies,
  devDependencies,
  peerDependencies,
  engines,
  strapi
};
var PERMISSIONS = {
  // This permission regards the main component (App) and is used to tell
  // If the plugin link should be displayed in the menu
  // And also if the plugin is accessible. This use case is found when a user types the url of the
  // plugin directly in the browser
  main: [{ action: "plugin::content-type-builder.read", subject: null }]
};
var MAX_COMPONENT_DEPTH = 6;
var pluginId = pluginPkg.name.replace(/^@strapi\//i, "");
var getRelationType = (relation, targetAttribute) => {
  const hasNotTargetAttribute = targetAttribute === void 0 || targetAttribute === null;
  if (relation === "oneToOne" && hasNotTargetAttribute) {
    return "oneWay";
  }
  if (relation === "oneToMany" && hasNotTargetAttribute) {
    return "manyWay";
  }
  return relation;
};
var makeUnique = (array) => [...new Set(array)];
var ADD_ATTRIBUTE = "ContentTypeBuilder/DataManagerProvider/ADD_ATTRIBUTE";
var ADD_CUSTOM_FIELD_ATTRIBUTE = "ContentTypeBuilder/DataManagerProvider/ADD_CUSTOM_FIELD_ATTRIBUTE";
var ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE = "ContentTypeBuilder/DataManagerProvider/ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE";
var CHANGE_DYNAMIC_ZONE_COMPONENTS = "ContentTypeBuilder/DataManagerProvider/CHANGE_DYNAMIC_ZONE_COMPONENTS";
var CREATE_SCHEMA = "ContentTypeBuilder/DataManagerProvider/CREATE_SCHEMA";
var CREATE_COMPONENT_SCHEMA = "ContentTypeBuilder/DataManagerProvider/CREATE_COMPONENT_SCHEMA";
var DELETE_NOT_SAVED_TYPE = "ContentTypeBuilder/DataManagerProvider/DELETE_NOT_SAVED_TYPE";
var EDIT_ATTRIBUTE = "ContentTypeBuilder/DataManagerProvider/EDIT_ATTRIBUTE";
var EDIT_CUSTOM_FIELD_ATTRIBUTE = "ContentTypeBuilder/DataManagerProvider/EDIT_CUSTOM_FIELD_ATTRIBUTE";
var GET_DATA_SUCCEEDED = "ContentTypeBuilder/DataManagerProvider/GET_DATA_SUCCEEDED";
var RELOAD_PLUGIN = "ContentTypeBuilder/DataManagerProvider/RELOAD_PLUGIN";
var REMOVE_FIELD_FROM_DISPLAYED_COMPONENT = "ContentTypeBuilder/DataManagerProvider/REMOVE_FIELD_FROM_DISPLAYED_COMPONENT";
var REMOVE_COMPONENT_FROM_DYNAMIC_ZONE = "ContentTypeBuilder/DataManagerProvider/REMOVE_COMPONENT_FROM_DYNAMIC_ZONE";
var REMOVE_FIELD = "ContentTypeBuilder/DataManagerProvider/REMOVE_FIELD";
var SET_MODIFIED_DATA = "ContentTypeBuilder/DataManagerProvider/SET_MODIFIED_DATA";
var UPDATE_SCHEMA = "ContentTypeBuilder/DataManagerProvider/UPDATE_SCHEMA";
var UPDATE_INITIAL_STATE = "ContentTypeBuilder/DataManagerProvider/UPDATE_INITIAL_STATE";
var retrieveComponentsFromSchema = (attributes, allComponentsData) => {
  const allComponents = attributes.reduce((acc, current2) => {
    const type = current2.type;
    if (type === "component") {
      const currentComponentName = current2.component;
      acc.push(currentComponentName);
      const currentComponentAttributes = (0, import_get.default)(
        allComponentsData,
        [currentComponentName, "schema", "attributes"],
        []
      );
      acc.push(...retrieveComponentsFromSchema(currentComponentAttributes, allComponentsData));
    }
    if (type === "dynamiczone") {
      const dynamicZoneComponents = current2.components;
      const componentsFromDZComponents = dynamicZoneComponents.reduce((acc2, currentUid) => {
        const compoAttrs = (0, import_get.default)(allComponentsData, [currentUid, "schema", "attributes"], []);
        return [...acc2, ...retrieveComponentsFromSchema(compoAttrs, allComponentsData)];
      }, []);
      return [...acc, ...dynamicZoneComponents, ...componentsFromDZComponents];
    }
    return acc;
  }, []);
  return makeUnique(allComponents);
};
var initialState$1 = {
  components: {},
  contentTypes: {},
  initialComponents: {},
  initialContentTypes: {},
  initialData: {},
  modifiedData: {
    components: {},
    contentTypes: {}
  },
  reservedNames: {},
  isLoading: true,
  isLoadingForDataToBeSet: true
};
var ONE_SIDE_RELATIONS = ["oneWay", "manyWay"];
var getOppositeRelation = (originalRelation) => {
  if (originalRelation === "manyToOne") {
    return "oneToMany";
  }
  if (originalRelation === "oneToMany") {
    return "manyToOne";
  }
  return originalRelation;
};
var findAttributeIndex = (schema, attributeToFind) => {
  return schema.schema.attributes.findIndex(
    ({ name: name2 }) => name2 === attributeToFind
  );
};
var reducer$1 = (state = initialState$1, action) => immer_esm_default(state, (draftState) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  switch (action.type) {
    case ADD_ATTRIBUTE: {
      const {
        attributeToSet: { name: name2, ...rest },
        forTarget,
        targetUid
      } = action;
      delete rest.createComponent;
      const pathToDataToEdit = ["component", "contentType"].includes(forTarget) ? [forTarget] : [forTarget, targetUid];
      const currentAttributes = (0, import_get.default)(
        state,
        ["modifiedData", ...pathToDataToEdit, "schema", "attributes"],
        []
      ).slice();
      const updatedAttributes = [...currentAttributes, { ...rest, name: name2 }];
      (0, import_set.default)(
        draftState,
        ["modifiedData", ...pathToDataToEdit, "schema", "attributes"],
        updatedAttributes
      );
      if (action.shouldAddComponentToData) {
        const componentToAddUID = rest.component;
        const componentToAdd = state.components[componentToAddUID];
        const isTemporaryComponent = componentToAdd == null ? void 0 : componentToAdd.isTemporary;
        const hasComponentAlreadyBeenAdded = ((_a = state.modifiedData.components) == null ? void 0 : _a[componentToAddUID]) !== void 0;
        if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {
          break;
        }
        if (!draftState.modifiedData.components) {
          draftState.modifiedData.components = {};
        }
        draftState.modifiedData.components[componentToAddUID] = componentToAdd;
        const nestedComponents = retrieveComponentsFromSchema(
          componentToAdd.schema.attributes,
          state.components
        );
        const nestedComponentsToAddInModifiedData = nestedComponents.filter(
          (compoUID) => {
            return (0, import_get.default)(state, ["modifiedData", "components", compoUID]) === void 0;
          }
        );
        nestedComponentsToAddInModifiedData.forEach((compoUID) => {
          const compoSchema = (0, import_get.default)(state, ["components", compoUID], {});
          const isTemporary = compoSchema.isTemporary || false;
          if (!isTemporary) {
            if (!draftState.modifiedData.components) {
              draftState.modifiedData.components = {};
            }
            draftState.modifiedData.components[compoUID] = compoSchema;
          }
        });
        break;
      }
      const isCreatingRelationAttribute = rest.type === "relation";
      if (isCreatingRelationAttribute) {
        const target = rest.target;
        const targetAttribute = rest.targetAttribute || null;
        const relation = rest.relation;
        const relationType = getRelationType(relation, targetAttribute);
        const currentUid = (0, import_get.default)(state, ["modifiedData", ...pathToDataToEdit, "uid"]);
        if (rest.type === "relation" && relationType !== "oneWay" && relationType !== "manyWay" && target === currentUid) {
          const oppositeAttribute = {
            name: targetAttribute,
            relation: getOppositeRelation(relationType),
            target,
            targetAttribute: name2,
            type: "relation"
          };
          if (rest.private) {
            oppositeAttribute.private = rest.private;
          }
          const attributesToSet = [...updatedAttributes, oppositeAttribute];
          (0, import_set.default)(
            draftState,
            ["modifiedData", ...pathToDataToEdit, "schema", "attributes"],
            attributesToSet
          );
        }
      }
      break;
    }
    case ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE: {
      const { dynamicZoneTarget, componentsToAdd } = action;
      const dzAttributeIndex = findAttributeIndex(
        state.modifiedData.contentType,
        dynamicZoneTarget
      );
      componentsToAdd.forEach((componentUid) => {
        var _a2;
        if (!((_a2 = draftState.modifiedData.contentType) == null ? void 0 : _a2.schema.attributes[dzAttributeIndex].components)) {
          draftState.modifiedData.contentType.schema.attributes[dzAttributeIndex].components = [];
        }
        draftState.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.push(
          componentUid
        );
      });
      break;
    }
    case ADD_CUSTOM_FIELD_ATTRIBUTE: {
      const {
        attributeToSet: { name: name2, ...rest },
        forTarget,
        targetUid
      } = action;
      const pathToDataToEdit = ["component", "contentType"].includes(forTarget) ? [forTarget] : [forTarget, targetUid];
      const currentAttributes = (0, import_get.default)(
        state,
        ["modifiedData", ...pathToDataToEdit, "schema", "attributes"],
        []
      ).slice();
      const updatedAttributes = [...currentAttributes, { ...rest, name: name2 }];
      (0, import_set.default)(
        draftState,
        ["modifiedData", ...pathToDataToEdit, "schema", "attributes"],
        updatedAttributes
      );
      break;
    }
    case CHANGE_DYNAMIC_ZONE_COMPONENTS: {
      const { dynamicZoneTarget, newComponents } = action;
      const dzAttributeIndex = findAttributeIndex(
        state.modifiedData.contentType,
        dynamicZoneTarget
      );
      const currentDZComponents = ((_b = state.modifiedData.contentType) == null ? void 0 : _b.schema.attributes[dzAttributeIndex]).components;
      const updatedComponents = makeUnique([...currentDZComponents, ...newComponents]);
      ((_c = draftState.modifiedData.contentType) == null ? void 0 : _c.schema.attributes[dzAttributeIndex]).components = updatedComponents;
      const nestedComponents = retrieveComponentsFromSchema(
        R(draftState.modifiedData.contentType.schema.attributes),
        state.components
      );
      const nestedComponentsToAddInModifiedData = nestedComponents.filter((compoUID) => {
        return (0, import_get.default)(state, ["modifiedData", "components", compoUID]) === void 0;
      });
      nestedComponentsToAddInModifiedData.forEach((compoUID) => {
        const compoSchema = (0, import_get.default)(state, ["components", compoUID], {});
        const isTemporary = compoSchema.isTemporary || false;
        if (!isTemporary) {
          if (!draftState.modifiedData.components) {
            draftState.modifiedData.components = {};
          }
          draftState.modifiedData.components[compoUID] = compoSchema;
        }
      });
      break;
    }
    case CREATE_COMPONENT_SCHEMA: {
      const newSchema = {
        uid: action.uid,
        isTemporary: true,
        category: action.componentCategory,
        schema: {
          ...action.data,
          attributes: []
        }
      };
      draftState.components[action.uid] = newSchema;
      if (action.shouldAddComponentToData) {
        draftState.modifiedData.components[action.uid] = newSchema;
      }
      break;
    }
    case CREATE_SCHEMA: {
      const newSchema = {
        uid: action.uid,
        isTemporary: true,
        schema: {
          ...action.data,
          attributes: []
        }
      };
      draftState.contentTypes[action.uid] = newSchema;
      break;
    }
    case EDIT_ATTRIBUTE: {
      const {
        attributeToSet: { name: name2, ...rest },
        forTarget,
        targetUid,
        initialAttribute
      } = action;
      const initialAttributeName = initialAttribute.name;
      const pathToDataToEdit = ["component", "contentType"].includes(forTarget) ? [forTarget] : [forTarget, targetUid];
      const initialAttributeIndex = findAttributeIndex(
        (0, import_get.default)(state, ["modifiedData", ...pathToDataToEdit]),
        initialAttributeName
      );
      const isEditingRelation = rest.type === "relation";
      if (!isEditingRelation) {
        (0, import_set.default)(
          draftState,
          ["modifiedData", ...pathToDataToEdit, "schema", "attributes", initialAttributeIndex],
          action.attributeToSet
        );
        break;
      }
      const updatedAttributes = (0, import_get.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "schema",
        "attributes"
      ]).slice();
      const toSet = {
        name: name2,
        relation: rest.relation,
        target: rest.target,
        targetAttribute: rest.targetAttribute,
        type: "relation"
      };
      if (rest.private) {
        toSet.private = rest.private;
      }
      if (rest.pluginOptions) {
        toSet.pluginOptions = rest.pluginOptions;
      }
      const currentAttributeIndex = updatedAttributes.findIndex((value) => {
        return value.name !== void 0 && value.name === initialAttribute.name;
      });
      if (currentAttributeIndex !== -1) {
        updatedAttributes.splice(currentAttributeIndex, 1, toSet);
      }
      let oppositeAttributeNameToRemove = null;
      let oppositeAttributeNameToUpdate = null;
      let oppositeAttributeToCreate = null;
      let initialOppositeAttribute = null;
      const currentUid = (0, import_get.default)(state, ["modifiedData", ...pathToDataToEdit, "uid"]);
      const didChangeTargetRelation = initialAttribute.target !== rest.target;
      const didCreateInternalRelation = rest.target === currentUid;
      const relationType = getRelationType(rest.relation, rest.targetAttribute);
      const initialRelationType = getRelationType(
        initialAttribute.relation,
        initialAttribute.targetAttribute
      );
      const hadInternalRelation = initialAttribute.target === currentUid;
      const didChangeRelationType = initialRelationType !== relationType;
      const shouldRemoveOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && !didCreateInternalRelation && hadInternalRelation && isEditingRelation;
      const shouldRemoveOppositeAttributeBecauseOfRelationTypeChange = didChangeRelationType && hadInternalRelation && ["oneWay", "manyWay"].includes(relationType) && isEditingRelation;
      const shouldUpdateOppositeAttributeBecauseOfRelationTypeChange = !ONE_SIDE_RELATIONS.includes(initialRelationType) && !ONE_SIDE_RELATIONS.includes(relationType) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;
      const shouldCreateOppositeAttributeBecauseOfRelationTypeChange = ONE_SIDE_RELATIONS.includes(initialRelationType) && !ONE_SIDE_RELATIONS.includes(relationType) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;
      const shouldCreateOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && didCreateInternalRelation && !ONE_SIDE_RELATIONS.includes(relationType);
      if (shouldRemoveOppositeAttributeBecauseOfTargetChange || shouldRemoveOppositeAttributeBecauseOfRelationTypeChange) {
        oppositeAttributeNameToRemove = initialAttribute.targetAttribute;
      }
      if (oppositeAttributeNameToRemove) {
        const indexToRemove = updatedAttributes.findIndex(
          (value) => value.name === oppositeAttributeNameToRemove
        );
        updatedAttributes.splice(indexToRemove, 1);
      }
      if (!shouldRemoveOppositeAttributeBecauseOfTargetChange) {
        const initialTargetContentType = (0, import_get.default)(state, [
          "initialContentTypes",
          initialAttribute.target
        ]);
        if (initialTargetContentType) {
          const oppositeAttributeIndex = findAttributeIndex(
            initialTargetContentType,
            initialAttribute.targetAttribute
          );
          initialOppositeAttribute = (0, import_get.default)(state, [
            "initialContentTypes",
            initialAttribute.target,
            "schema",
            "attributes",
            oppositeAttributeIndex
          ]);
        }
      }
      if (shouldCreateOppositeAttributeBecauseOfRelationTypeChange || shouldCreateOppositeAttributeBecauseOfTargetChange) {
        oppositeAttributeToCreate = {
          name: rest.targetAttribute,
          relation: getOppositeRelation(relationType),
          target: rest.target,
          targetAttribute: name2,
          type: "relation"
        };
        if (rest.private) {
          oppositeAttributeToCreate.private = rest.private;
        }
        if (initialOppositeAttribute && initialOppositeAttribute.pluginOptions) {
          oppositeAttributeToCreate.pluginOptions = initialOppositeAttribute.pluginOptions;
        }
        const indexOfInitialAttribute = updatedAttributes.findIndex(
          ({ name: name22 }) => name22 === initialAttribute.name
        );
        const indexOfUpdatedAttribute = updatedAttributes.findIndex(
          ({ name: attrName }) => name2 === attrName
        );
        const indexToInsert = (indexOfInitialAttribute === -1 ? indexOfUpdatedAttribute : indexOfInitialAttribute) + 1;
        updatedAttributes.splice(indexToInsert, 0, oppositeAttributeToCreate);
      }
      if (shouldUpdateOppositeAttributeBecauseOfRelationTypeChange) {
        oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;
        oppositeAttributeToCreate = {
          name: rest.targetAttribute,
          relation: getOppositeRelation(relationType),
          target: rest.target,
          targetAttribute: name2,
          type: "relation"
        };
        if (rest.private) {
          oppositeAttributeToCreate.private = rest.private;
        }
        if (initialOppositeAttribute && initialOppositeAttribute.pluginOptions) {
          oppositeAttributeToCreate.pluginOptions = initialOppositeAttribute.pluginOptions;
        }
        if (oppositeAttributeNameToUpdate) {
          const indexToUpdate = updatedAttributes.findIndex(
            ({ name: name22 }) => name22 === oppositeAttributeNameToUpdate
          );
          updatedAttributes.splice(indexToUpdate, 1, oppositeAttributeToCreate);
        }
      }
      (0, import_set.default)(
        draftState,
        ["modifiedData", ...pathToDataToEdit, "schema", "attributes"],
        updatedAttributes
      );
      break;
    }
    case EDIT_CUSTOM_FIELD_ATTRIBUTE: {
      const { forTarget, targetUid, initialAttribute, attributeToSet } = action;
      const initialAttributeName = initialAttribute.name;
      const pathToDataToEdit = ["component", "contentType"].includes(forTarget) ? [forTarget] : [forTarget, targetUid];
      const initialAttributeIndex = findAttributeIndex(
        (0, import_get.default)(state, ["modifiedData", ...pathToDataToEdit]),
        initialAttributeName
      );
      (0, import_set.default)(
        draftState,
        ["modifiedData", ...pathToDataToEdit, "schema", "attributes", initialAttributeIndex],
        attributeToSet
      );
      break;
    }
    case GET_DATA_SUCCEEDED: {
      draftState.components = action.components;
      draftState.initialComponents = action.components;
      draftState.initialContentTypes = action.contentTypes;
      draftState.contentTypes = action.contentTypes;
      draftState.reservedNames = action.reservedNames;
      draftState.isLoading = false;
      break;
    }
    case UPDATE_INITIAL_STATE: {
      draftState.initialData = draftState.modifiedData;
      break;
    }
    case DELETE_NOT_SAVED_TYPE: {
      draftState.contentTypes = state.initialContentTypes;
      draftState.components = state.initialComponents;
      break;
    }
    case RELOAD_PLUGIN: {
      return initialState$1;
    }
    case REMOVE_COMPONENT_FROM_DYNAMIC_ZONE: {
      const dzAttributeIndex = findAttributeIndex(state.modifiedData.contentType, action.dzName);
      draftState.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.splice(
        action.componentToRemoveIndex,
        1
      );
      break;
    }
    case REMOVE_FIELD: {
      const { mainDataKey, attributeToRemoveName } = action;
      const pathToAttributes = ["modifiedData", mainDataKey, "schema", "attributes"];
      const attributeToRemoveIndex = findAttributeIndex(
        state.modifiedData[mainDataKey],
        attributeToRemoveName
      );
      const pathToAttributeToRemove = [...pathToAttributes, attributeToRemoveIndex];
      const attributeToRemoveData = (0, import_get.default)(state, pathToAttributeToRemove);
      const isRemovingRelationAttribute = attributeToRemoveData.type === "relation";
      const canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === "contentType";
      if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {
        const { target, relation, targetAttribute } = attributeToRemoveData;
        const relationType = getRelationType(relation, targetAttribute);
        const uid = (_d = state.modifiedData.contentType) == null ? void 0 : _d.uid;
        const shouldRemoveOppositeAttribute = target === uid && !ONE_SIDE_RELATIONS.includes(relationType);
        if (shouldRemoveOppositeAttribute) {
          const attributes = (_e = state.modifiedData[mainDataKey]) == null ? void 0 : _e.schema.attributes.slice();
          const nextAttributes = attributes.filter((attribute) => {
            if (attribute.name === attributeToRemoveName) {
              return false;
            }
            if (attribute.target === uid && attribute.targetAttribute === attributeToRemoveName) {
              return false;
            }
            return true;
          });
          draftState.modifiedData[mainDataKey].schema.attributes = nextAttributes;
          break;
        }
      }
      const uidFieldsToUpdate = state.modifiedData[mainDataKey].schema.attributes.slice().reduce((acc, current2) => {
        if (current2.type !== "uid") {
          return acc;
        }
        if (current2.targetField !== attributeToRemoveName) {
          return acc;
        }
        acc.push(current2.name);
        return acc;
      }, []);
      uidFieldsToUpdate.forEach((fieldName) => {
        var _a2;
        const fieldIndex = findAttributeIndex(state.modifiedData[mainDataKey], fieldName);
        (_a2 = draftState.modifiedData[mainDataKey]) == null ? true : delete _a2.schema.attributes[fieldIndex].targetField;
      });
      (_f = draftState.modifiedData[mainDataKey]) == null ? void 0 : _f.schema.attributes.splice(attributeToRemoveIndex, 1);
      break;
    }
    case REMOVE_FIELD_FROM_DISPLAYED_COMPONENT: {
      const { attributeToRemoveName, componentUid } = action;
      const attributeToRemoveIndex = findAttributeIndex(
        (_g = state.modifiedData.components) == null ? void 0 : _g[componentUid],
        attributeToRemoveName
      );
      (_k = (_j = (_i = (_h = draftState.modifiedData.components) == null ? void 0 : _h[componentUid]) == null ? void 0 : _i.schema) == null ? void 0 : _j.attributes) == null ? void 0 : _k.splice(
        attributeToRemoveIndex,
        1
      );
      break;
    }
    case SET_MODIFIED_DATA: {
      draftState.isLoadingForDataToBeSet = false;
      draftState.initialData = action.schemaToSet;
      draftState.modifiedData = action.schemaToSet;
      if (!action.hasJustCreatedSchema) {
        draftState.components = state.initialComponents;
        draftState.contentTypes = state.initialContentTypes;
      }
      break;
    }
    case UPDATE_SCHEMA: {
      const {
        data: { displayName, category, icon, kind },
        schemaType,
        uid
      } = action;
      draftState.modifiedData[schemaType].schema.displayName = displayName;
      if (action.schemaType === "component") {
        draftState.modifiedData.component.category = category;
        draftState.modifiedData.component.schema.icon = icon;
        const addedComponent = R(draftState.modifiedData.component);
        draftState.components[uid] = addedComponent;
        break;
      }
      draftState.modifiedData.contentType.schema.kind = kind;
      break;
    }
    default:
      return draftState;
  }
});
var nameToSlug = (name2) => (0, import_slugify.default)(name2, { separator: "-" });
var ON_CHANGE = "ContentTypeBuilder/FormModal/ON_CHANGE";
var ON_CHANGE_RELATION_TARGET = "ContentTypeBuilder/FormModal/ON_CHANGE_RELATION_TARGET";
var ON_CHANGE_RELATION_TYPE = "ContentTypeBuilder/FormModal/ON_CHANGE_RELATION_TYPE";
var RESET_PROPS = "ContentTypeBuilder/FormModal/RESET_PROPS";
var RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO = "ContentTypeBuilder/FormModal/RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO";
var RESET_PROPS_AND_SAVE_CURRENT_DATA = "ContentTypeBuilder/FormModal/RESET_PROPS_AND_SAVE_CURRENT_DATA";
var RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ = "ContentTypeBuilder/FormModal/RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ";
var SET_DATA_TO_EDIT = "ContentTypeBuilder/FormModal/SET_DATA_TO_EDIT";
var SET_ATTRIBUTE_DATA_SCHEMA = "ContentTypeBuilder/FormModal/SET_ATTRIBUTE_DATA_SCHEMA";
var SET_CUSTOM_FIELD_DATA_SCHEMA = "ContentTypeBuilder/FormModal/SET_CUSTOM_FIELD_DATA_SCHEMA";
var SET_DYNAMIC_ZONE_DATA_SCHEMA = "ContentTypeBuilder/FormModal/SET_DYNAMIC_ZONE_DATA_SCHEMA";
var SET_ERRORS = "ContentTypeBuilder/FormModal/SET_ERRORS";
var createUid = (name2) => {
  const modelName = nameToSlug(name2);
  return `api::${modelName}.${modelName}`;
};
var createComponentUid = (name2, category) => {
  return `${nameToSlug(category)}.${nameToSlug(name2)}`;
};
var customFieldDefaultOptionsReducer = (acc, option) => {
  if (option.items) {
    return option.items.reduce(customFieldDefaultOptionsReducer, acc);
  }
  if ("defaultValue" in option) {
    const { name: name2, defaultValue } = option;
    acc.push({ name: name2, defaultValue });
  }
  return acc;
};
var shouldPluralizeName = (nature) => ["manyToMany", "oneToMany", "manyWay"].includes(nature) ? 2 : 1;
var shouldPluralizeTargetAttribute = (nature) => ["manyToMany", "manyToOne"].includes(nature) ? 2 : 1;
var initialState = {
  formErrors: {},
  modifiedData: {},
  initialData: {},
  componentToCreate: {},
  isCreatingComponentWhileAddingAField: false
};
var reducer = (state = initialState, action) => (
  // eslint-disable-next-line consistent-return
  fn(state, (draftState) => {
    var _a, _b;
    switch (action.type) {
      case ON_CHANGE: {
        const { keys, value } = action;
        const obj = state.modifiedData;
        const hasDefaultValue = Boolean(obj.default);
        if (hasDefaultValue && keys.length === 1 && keys.includes("type")) {
          const previousType = obj.type;
          if (previousType && ["date", "datetime", "time"].includes(previousType)) {
            delete draftState.modifiedData.default;
          }
        }
        (0, import_set.default)(draftState, ["modifiedData", ...keys], value);
        break;
      }
      case ON_CHANGE_RELATION_TARGET: {
        const {
          target: {
            oneThatIsCreatingARelationWithAnother,
            selectedContentTypeFriendlyName,
            targetContentTypeAllowedRelations,
            value
          }
        } = action;
        let didChangeRelationTypeBecauseOfRestrictedRelation = false;
        let changedRelationType = null;
        (0, import_set.default)(draftState, ["modifiedData", "target"], value);
        const modifiedData = state.modifiedData;
        if (Array.isArray(targetContentTypeAllowedRelations)) {
          const currentRelationType = getRelationType(
            modifiedData.relation,
            modifiedData.targetAttribute
          );
          if (!targetContentTypeAllowedRelations.includes(currentRelationType)) {
            const relationToSet = targetContentTypeAllowedRelations[0];
            didChangeRelationTypeBecauseOfRestrictedRelation = true;
            changedRelationType = relationToSet;
            if (relationToSet === "oneWay") {
              (0, import_set.default)(draftState, ["modifiedData", "relation"], "oneToOne");
            } else if (relationToSet === "manyWay") {
              (0, import_set.default)(draftState, ["modifiedData", "relation"], "oneToMany");
            } else {
              (0, import_set.default)(draftState, ["modifiedData", "relation"], relationToSet);
            }
          }
        }
        let nameToSet;
        if (didChangeRelationTypeBecauseOfRestrictedRelation) {
          nameToSet = (0, import_pluralize.default)(
            (0, import_snakeCase.default)(nameToSlug(selectedContentTypeFriendlyName)),
            shouldPluralizeName(changedRelationType)
          );
        } else {
          nameToSet = (0, import_pluralize.default)(
            (0, import_snakeCase.default)(nameToSlug(selectedContentTypeFriendlyName)),
            shouldPluralizeName(modifiedData.relation)
          );
        }
        (0, import_set.default)(draftState, ["modifiedData", "name"], nameToSet);
        const currentTargetAttribute = state.modifiedData.targetAttribute;
        if (currentTargetAttribute === null) {
          break;
        }
        if (didChangeRelationTypeBecauseOfRestrictedRelation && ["oneWay", "manyWay"].includes(changedRelationType)) {
          (0, import_set.default)(draftState, ["modifiedData", "targetAttribute"], null);
          break;
        }
        const targetAttributeToSet = (0, import_pluralize.default)(
          (0, import_snakeCase.default)(nameToSlug(oneThatIsCreatingARelationWithAnother)),
          shouldPluralizeTargetAttribute(modifiedData.relation)
        );
        (0, import_set.default)(draftState, ["modifiedData", "targetAttribute"], targetAttributeToSet);
        break;
      }
      case ON_CHANGE_RELATION_TYPE: {
        const {
          target: { oneThatIsCreatingARelationWithAnother, value }
        } = action;
        const currentName = state.modifiedData.name;
        if (!["oneWay", "manyWay"].includes(value)) {
          (0, import_set.default)(draftState, ["modifiedData", "relation"], value);
          const currentTargetAttribute = state.modifiedData.targetAttribute;
          (0, import_set.default)(
            draftState,
            ["modifiedData", "name"],
            (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(currentName)), shouldPluralizeName(value))
          );
          (0, import_set.default)(
            draftState,
            ["modifiedData", "targetAttribute"],
            (0, import_pluralize.default)(
              currentTargetAttribute || (0, import_snakeCase.default)(nameToSlug(oneThatIsCreatingARelationWithAnother)),
              shouldPluralizeTargetAttribute(value)
            )
          );
          break;
        }
        if (value === "oneWay") {
          (0, import_set.default)(draftState, ["modifiedData", "relation"], "oneToOne");
          (0, import_set.default)(draftState, ["modifiedData", "targetAttribute"], null);
          (0, import_set.default)(draftState, ["modifiedData", "name"], (0, import_pluralize.default)((0, import_snakeCase.default)(currentName), 1));
          break;
        }
        (0, import_set.default)(draftState, ["modifiedData", "relation"], "oneToMany");
        (0, import_set.default)(draftState, ["modifiedData", "targetAttribute"], null);
        (0, import_set.default)(draftState, ["modifiedData", "name"], (0, import_pluralize.default)((0, import_snakeCase.default)(currentName), 2));
        break;
      }
      case RESET_PROPS:
        return initialState;
      case RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO: {
        const nextState = {
          ...initialState,
          modifiedData: {
            type: "component",
            repeatable: true,
            ...action.options
          }
        };
        return nextState;
      }
      case RESET_PROPS_AND_SAVE_CURRENT_DATA: {
        const componentToCreate = state.modifiedData.componentToCreate;
        const modifiedData = {
          displayName: componentToCreate.displayName,
          type: "component",
          repeatable: false,
          ...action.options,
          component: createComponentUid(componentToCreate.displayName, componentToCreate.category)
        };
        const nextState = {
          ...initialState,
          componentToCreate,
          modifiedData,
          isCreatingComponentWhileAddingAField: state.modifiedData.createComponent
        };
        return nextState;
      }
      case RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ: {
        const createdDZ = state.modifiedData;
        const dataToSet = {
          ...createdDZ,
          createComponent: true,
          componentToCreate: { type: "component" }
        };
        return { ...initialState, modifiedData: dataToSet };
      }
      case SET_DATA_TO_EDIT: {
        draftState.modifiedData = action.data;
        draftState.initialData = action.data;
        break;
      }
      case SET_ATTRIBUTE_DATA_SCHEMA: {
        const {
          attributeType,
          isEditing,
          modifiedDataToSetForEditing,
          nameToSetForRelation,
          targetUid,
          step,
          options = {}
        } = action;
        if (isEditing) {
          draftState.modifiedData = modifiedDataToSetForEditing;
          draftState.initialData = modifiedDataToSetForEditing;
          break;
        }
        let dataToSet;
        if (attributeType === "component") {
          if (step === "1") {
            dataToSet = {
              type: "component",
              createComponent: true,
              componentToCreate: { type: "component" }
            };
          } else {
            dataToSet = {
              ...options,
              type: "component",
              repeatable: true
            };
          }
        } else if (attributeType === "dynamiczone") {
          dataToSet = {
            ...options,
            type: "dynamiczone",
            components: []
          };
        } else if (attributeType === "text") {
          dataToSet = { ...options, type: "string" };
        } else if (attributeType === "number" || attributeType === "date") {
          dataToSet = options;
        } else if (attributeType === "media") {
          dataToSet = {
            allowedTypes: ["images", "files", "videos", "audios"],
            type: "media",
            multiple: true,
            ...options
          };
        } else if (attributeType === "enumeration") {
          dataToSet = { ...options, type: "enumeration", enum: [] };
        } else if (attributeType === "relation") {
          dataToSet = {
            name: (0, import_snakeCase.default)(nameToSetForRelation),
            relation: "oneToOne",
            targetAttribute: null,
            target: targetUid,
            type: "relation"
          };
        } else {
          dataToSet = { ...options, type: attributeType, default: null };
        }
        draftState.modifiedData = dataToSet;
        break;
      }
      case SET_CUSTOM_FIELD_DATA_SCHEMA: {
        const { customField, isEditing, modifiedDataToSetForEditing, options = {} } = action;
        if (isEditing) {
          draftState.modifiedData = modifiedDataToSetForEditing;
          draftState.initialData = modifiedDataToSetForEditing;
          break;
        }
        draftState.modifiedData = { ...options, type: customField.type };
        const allOptions = [
          ...((_a = customField == null ? void 0 : customField.options) == null ? void 0 : _a.base) || [],
          ...((_b = customField == null ? void 0 : customField.options) == null ? void 0 : _b.advanced) || []
        ];
        const optionDefaults = allOptions.reduce(customFieldDefaultOptionsReducer, []);
        if (optionDefaults.length) {
          optionDefaults.forEach(
            ({ name: name2, defaultValue }) => (0, import_set.default)(draftState.modifiedData, name2, defaultValue)
          );
        }
        break;
      }
      case SET_DYNAMIC_ZONE_DATA_SCHEMA: {
        draftState.modifiedData = action.attributeToEdit;
        draftState.initialData = action.attributeToEdit;
        break;
      }
      case SET_ERRORS: {
        draftState.formErrors = action.errors;
        break;
      }
      default:
        return draftState;
    }
  })
);
var reducers = {
  [`${pluginId}_formModal`]: reducer,
  [`${pluginId}_dataManagerProvider`]: reducer$1
};
var formsAPI = {
  components: {
    inputs: {},
    add({ id, component }) {
      if (!this.inputs[id]) {
        this.inputs[id] = component;
      }
    }
  },
  types: {
    attribute: {
      // test: {
      //   validators: [],
      //   form: {
      //     advanced: [
      //       /* cb */
      //     ],
      //     base: [
      //       /* cb */
      //     ],
      //   },
      // },
    },
    contentType: {
      validators: [],
      form: {
        advanced: [],
        base: []
      }
    },
    component: {
      validators: [],
      form: {
        advanced: [],
        base: []
      }
    }
  },
  contentTypeSchemaMutations: [],
  addContentTypeSchemaMutation(cb) {
    this.contentTypeSchemaMutations.push(cb);
  },
  extendContentType({ validator, form: { advanced, base } }) {
    const { contentType } = this.types;
    contentType.validators.push(validator);
    contentType.form.advanced.push(advanced);
    contentType.form.base.push(base);
  },
  extendFields(fields, { validator, form: { advanced, base } }) {
    const formType = this.types.attribute;
    fields.forEach((field) => {
      if (!formType[field]) {
        formType[field] = {
          validators: [],
          form: {
            advanced: [
              /* cb */
            ],
            base: [
              /* cb */
            ]
          }
        };
      }
      formType[field].validators.push(validator);
      formType[field].form.advanced.push(advanced);
      formType[field].form.base.push(base);
    });
  },
  getAdvancedForm(target, props = null) {
    const sectionsToAdd = (0, import_get.default)(this.types, [...target, "form", "advanced"], []).reduce(
      (acc, current2) => {
        const sections = current2(props);
        return [...acc, ...sections];
      },
      []
    );
    return sectionsToAdd;
  },
  makeCustomFieldValidator(attributeShape, validator, ...validatorArgs) {
    if (!validator)
      return attributeShape;
    return attributeShape.shape({ options: create().shape(validator(validatorArgs)) });
  },
  makeValidator(target, initShape, ...args) {
    const validators = (0, import_get.default)(this.types, [...target, "validators"], []);
    const pluginOptionsShape = validators.reduce((acc, current2) => {
      const pluginOptionShape = current2(args);
      return { ...acc, ...pluginOptionShape };
    }, {});
    return initShape.shape({ pluginOptions: create().shape(pluginOptionsShape) });
  },
  mutateContentTypeSchema(data, initialData) {
    let enhancedData = (0, import_cloneDeep.default)(data);
    const refData = (0, import_cloneDeep.default)(initialData);
    this.contentTypeSchemaMutations.forEach((cb) => {
      enhancedData = cb(enhancedData, refData);
    });
    return enhancedData;
  }
};
var prefixPluginTranslations = (trad, pluginId2) => {
  if (!pluginId2) {
    throw new TypeError("pluginId can't be empty");
  }
  return Object.keys(trad).reduce((acc, current2) => {
    acc[`${pluginId2}.${current2}`] = trad[current2];
    return acc;
  }, {});
};
var name = pluginPkg.strapi.name;
var index = {
  register(app) {
    app.addReducers(reducers);
    app.addMenuLink({
      to: `plugins/${pluginId}`,
      icon: ForwardRef$2r,
      intlLabel: {
        id: `${pluginId}.plugin.name`,
        defaultMessage: "Content Types Builder"
      },
      permissions: PERMISSIONS.main,
      Component: () => import("./index-KrAEvWtO-CYZG7NAN.js").then((n) => n.i),
      position: 5
    });
    app.registerPlugin({
      id: pluginId,
      name,
      // Internal APIs exposed by the CTB for the other plugins to use
      apis: {
        forms: formsAPI
      }
    });
  },
  bootstrap() {
  },
  async registerTrads({ locales }) {
    const importedTrads = await Promise.all(
      locales.map((locale) => {
        return __variableDynamicImportRuntimeHelper(Object.assign({ "./translations/ar.json": () => import("./ar-BYDB75EB-TKFQDAA7.js"), "./translations/cs.json": () => import("./cs-ChL4LaFY-T4QDBIKB.js"), "./translations/de.json": () => import("./de-DsHQNzp2-5LR6G3P5.js"), "./translations/dk.json": () => import("./dk-BC7NAQR2-TLEN35F2.js"), "./translations/en.json": () => import("./en-jBwb53yg-4FHSZLFO.js"), "./translations/es.json": () => import("./es-BE_zx2_w-M2FBXVLV.js"), "./translations/fr.json": () => import("./fr-lU_OMJma-LWYJBLJM.js"), "./translations/id.json": () => import("./id-W1sKBFEw-FOASB4RD.js"), "./translations/it.json": () => import("./it-D04lb2Wc-NGZIDUAQ.js"), "./translations/ja.json": () => import("./ja-BHLK_2_g-XAEJSF7X.js"), "./translations/ko.json": () => import("./ko-DoNsXHXA-4MQFSDF6.js"), "./translations/ms.json": () => import("./ms-BtGFDB9t-AVBVWJIO.js"), "./translations/nl.json": () => import("./nl-BaTAuelQ-M66MNQBY.js"), "./translations/pl.json": () => import("./pl-CP2Zgp01-OQPWFULV.js"), "./translations/pt-BR.json": () => import("./pt-BR-CCQGwXs0-MN6QEZVY.js"), "./translations/pt.json": () => import("./pt-DMeTMW2x-ER3FSR55.js"), "./translations/ru.json": () => import("./ru-DGSjru5m-D7HY4DPY.js"), "./translations/sk.json": () => import("./sk-DVK4HfSC-A7KQCNX4.js"), "./translations/sv.json": () => import("./sv-BGb12eW3-ZLMVEAEL.js"), "./translations/th.json": () => import("./th--u3VqsON-4QVH22AL.js"), "./translations/tr.json": () => import("./tr-DsUerr-c-J36SAWM5.js"), "./translations/uk.json": () => import("./uk-Bx5IlOKX-BMIMAQZS.js"), "./translations/zh-Hans.json": () => import("./zh-Hans-Cc0M5PXr-X3ZP3E6V.js"), "./translations/zh.json": () => import("./zh-CsUDN13W-KUIAGI27.js") }), `./translations/${locale}.json`).then(({ default: data }) => {
          return {
            data: prefixPluginTranslations(data, pluginId),
            locale
          };
        }).catch(() => {
          return {
            data: {},
            locale
          };
        });
      })
    );
    return Promise.resolve(importedTrads);
  }
};

export {
  require_slugify,
  PERMISSIONS,
  MAX_COMPONENT_DEPTH,
  pluginId,
  getRelationType,
  makeUnique,
  ADD_ATTRIBUTE,
  ADD_CUSTOM_FIELD_ATTRIBUTE,
  ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE,
  CHANGE_DYNAMIC_ZONE_COMPONENTS,
  CREATE_SCHEMA,
  CREATE_COMPONENT_SCHEMA,
  DELETE_NOT_SAVED_TYPE,
  EDIT_ATTRIBUTE,
  EDIT_CUSTOM_FIELD_ATTRIBUTE,
  GET_DATA_SUCCEEDED,
  RELOAD_PLUGIN,
  REMOVE_FIELD_FROM_DISPLAYED_COMPONENT,
  REMOVE_COMPONENT_FROM_DYNAMIC_ZONE,
  REMOVE_FIELD,
  SET_MODIFIED_DATA,
  UPDATE_SCHEMA,
  UPDATE_INITIAL_STATE,
  retrieveComponentsFromSchema,
  initialState$1,
  nameToSlug,
  ON_CHANGE,
  ON_CHANGE_RELATION_TARGET,
  ON_CHANGE_RELATION_TYPE,
  RESET_PROPS,
  RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO,
  RESET_PROPS_AND_SAVE_CURRENT_DATA,
  RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ,
  SET_DATA_TO_EDIT,
  SET_ATTRIBUTE_DATA_SCHEMA,
  SET_CUSTOM_FIELD_DATA_SCHEMA,
  SET_DYNAMIC_ZONE_DATA_SCHEMA,
  SET_ERRORS,
  createUid,
  createComponentUid,
  initialState,
  index
};
//# sourceMappingURL=chunk-QTP6QIR7.js.map
