{"version":3,"file":"index.mjs","sources":["../../server/src/utils/index.ts","../../server/src/history/utils.ts","../../server/src/history/controllers/validation/history-version.ts","../../server/src/history/controllers/history-version.ts","../../server/src/history/controllers/index.ts","../../server/src/history/constants.ts","../../server/src/history/services/utils.ts","../../server/src/history/services/history.ts","../../server/src/history/services/lifecycles.ts","../../server/src/history/services/index.ts","../../server/src/history/routes/history-version.ts","../../server/src/history/routes/index.ts","../../server/src/history/models/history-version.ts","../../server/src/history/index.ts","../../server/src/register.ts","../../server/src/constants/index.ts","../../server/src/bootstrap.ts","../../server/src/destroy.ts","../../server/src/middlewares/routing.ts","../../server/src/routes/admin.ts","../../server/src/routes/index.ts","../../server/src/validation/policies/hasPermissions.ts","../../server/src/policies/hasPermissions.ts","../../server/src/policies/index.ts","../../server/src/services/utils/configuration/attributes.ts","../../server/src/services/utils/configuration/settings.ts","../../server/src/controllers/validation/model-configuration.ts","../../server/src/controllers/validation/index.ts","../../server/src/controllers/utils/clone.ts","../../server/src/controllers/validation/dimensions.ts","../../server/src/controllers/utils/metadata.ts","../../server/src/controllers/collection-types.ts","../../server/src/controllers/components.ts","../../server/src/controllers/content-types.ts","../../server/src/controllers/init.ts","../../server/src/controllers/validation/relations.ts","../../server/src/controllers/relations.ts","../../server/src/controllers/single-types.ts","../../server/src/controllers/uid.ts","../../server/src/controllers/index.ts","../../server/src/services/utils/store.ts","../../server/src/services/utils/configuration/metadatas.ts","../../server/src/services/utils/configuration/layouts.ts","../../server/src/services/utils/configuration/index.ts","../../server/src/services/configuration.ts","../../server/src/services/components.ts","../../server/src/services/content-types.ts","../../server/src/services/data-mapper.ts","../../server/src/services/field-sizes.ts","../../server/src/services/metrics.ts","../../server/src/services/permission-checker.ts","../../server/src/services/permission.ts","../../server/src/services/utils/populate.ts","../../server/src/services/populate-builder.ts","../../server/src/services/uid.ts","../../server/src/services/document-metadata.ts","../../server/src/services/utils/draft.ts","../../server/src/services/document-manager.ts","../../server/src/services/index.ts","../../server/src/index.ts"],"sourcesContent":["import '@strapi/types';\nimport { DocumentManagerService } from 'src/services/document-manager';\n\ntype Services = {\n  'document-manager': DocumentManagerService;\n  [key: string]: any;\n};\n\nconst getService = <TName extends keyof Services>(name: TName): ReturnType<Services[TName]> => {\n  return strapi.plugin('content-manager').service(name as string);\n};\n\nexport { getService };\n","import type { Core } from '@strapi/types';\n\ntype HistoryServices = typeof import('./services').services;\n\nfunction getService<T extends keyof HistoryServices>(strapi: Core.Strapi, name: T) {\n  // Cast is needed because the return type of strapi.service is too vague\n  return strapi.service(`plugin::content-manager.${name}`) as ReturnType<HistoryServices[T]>;\n}\n\nexport { getService };\n","import * as yup from 'yup';\nimport { validateYupSchema } from '@strapi/utils';\n\nconst historyRestoreVersionSchema = yup\n  .object()\n  .shape({\n    contentType: yup.string().trim().required(),\n  })\n  .required();\n\nexport const validateRestoreVersion = validateYupSchema(historyRestoreVersionSchema);\n","import { async, errors } from '@strapi/utils';\nimport type { Core, UID } from '@strapi/types';\nimport { pick } from 'lodash/fp';\nimport { getService as getContentManagerService } from '../../utils';\nimport { getService } from '../utils';\nimport { HistoryVersions } from '../../../../shared/contracts';\nimport { RestoreHistoryVersion } from '../../../../shared/contracts/history-versions';\nimport { validateRestoreVersion } from './validation/history-version';\n\n/**\n * Parses pagination params and makes sure they're within valid ranges\n */\nconst getValidPagination = ({ page, pageSize }: { page: any; pageSize: any }) => {\n  let pageNumber = 1;\n  let pageSizeNumber = 20;\n\n  if (page) {\n    const parsedPage = parseInt(page, 10);\n    pageNumber = parseInt(page, 10);\n\n    if (!Number.isNaN(parsedPage) && parsedPage >= 1) {\n      pageNumber = parsedPage;\n    }\n  }\n\n  if (pageSize) {\n    const parsedPageSize = parseInt(pageSize, 10);\n\n    if (!Number.isNaN(parsedPageSize) && parsedPageSize >= 1 && parsedPageSize <= 100) {\n      pageSizeNumber = parsedPageSize;\n    }\n  }\n\n  return { page: pageNumber, pageSize: pageSizeNumber };\n};\n\nconst createHistoryVersionController = ({ strapi }: { strapi: Core.Strapi }) => {\n  return {\n    async findMany(ctx) {\n      const contentTypeUid = ctx.query.contentType as UID.ContentType;\n      const isSingleType = strapi.getModel(contentTypeUid)?.kind === 'singleType';\n\n      if (isSingleType && !contentTypeUid) {\n        throw new errors.ForbiddenError('contentType is required');\n      }\n\n      if (!isSingleType && (!contentTypeUid || !ctx.query.documentId)) {\n        throw new errors.ForbiddenError('contentType and documentId are required');\n      }\n\n      /**\n       * There are no permissions specifically for history versions,\n       * but we need to check that the user can read the content type\n       */\n      const permissionChecker = getContentManagerService('permission-checker').create({\n        userAbility: ctx.state.userAbility,\n        model: ctx.query.contentType,\n      });\n\n      if (permissionChecker.cannot.read()) {\n        return ctx.forbidden();\n      }\n\n      const query: HistoryVersions.GetHistoryVersions.Request['query'] =\n        await permissionChecker.sanitizeQuery(ctx.query);\n\n      const { results, pagination } = await getService(strapi, 'history').findVersionsPage({\n        query: {\n          ...query,\n          ...getValidPagination({ page: query.page, pageSize: query.pageSize }),\n        },\n        state: { userAbility: ctx.state.userAbility },\n      });\n\n      const sanitizedResults = await async.map(\n        results,\n        async (version: HistoryVersions.HistoryVersionDataResponse & { locale: string }) => {\n          return {\n            ...version,\n            data: await permissionChecker.sanitizeOutput(version.data),\n            createdBy: version.createdBy\n              ? pick(['id', 'firstname', 'lastname', 'username', 'email'], version.createdBy)\n              : undefined,\n          };\n        }\n      );\n\n      return {\n        data: sanitizedResults,\n        meta: { pagination },\n      };\n    },\n\n    async restoreVersion(ctx) {\n      const request = ctx.request as unknown as RestoreHistoryVersion.Request;\n\n      await validateRestoreVersion(request.body, 'contentType is required');\n\n      const permissionChecker = getContentManagerService('permission-checker').create({\n        userAbility: ctx.state.userAbility,\n        model: request.body.contentType,\n      });\n\n      if (permissionChecker.cannot.update()) {\n        throw new errors.ForbiddenError();\n      }\n\n      const restoredDocument = await getService(strapi, 'history').restoreVersion(\n        request.params.versionId\n      );\n\n      return {\n        data: { documentId: restoredDocument.documentId },\n      } satisfies RestoreHistoryVersion.Response;\n    },\n  } satisfies Core.Controller;\n};\n\nexport { createHistoryVersionController };\n","import type { Plugin } from '@strapi/types';\nimport { createHistoryVersionController } from './history-version';\n\nexport const controllers = {\n  'history-version': createHistoryVersionController,\n  /**\n   * Casting is needed because the types aren't aware that Strapi supports\n   * passing a controller factory as the value, instead of a controller object directly\n   */\n} as unknown as Plugin.LoadedPlugin['controllers'];\n","export const HISTORY_VERSION_UID = 'plugin::content-manager.history-version';\nexport const FIELDS_TO_IGNORE = [\n  'createdAt',\n  'updatedAt',\n  'publishedAt',\n  'createdBy',\n  'updatedBy',\n  'strapi_stage',\n  'strapi_assignee',\n];\n","import { difference, omit } from 'lodash/fp';\nimport type { Struct, UID } from '@strapi/types';\nimport { Core, Data, Modules, Schema } from '@strapi/types';\nimport { contentTypes } from '@strapi/utils';\nimport { CreateHistoryVersion } from '../../../../shared/contracts/history-versions';\nimport { FIELDS_TO_IGNORE } from '../constants';\nimport { HistoryVersions } from '../../../../shared/contracts';\nimport { RelationResult } from '../../../../shared/contracts/relations';\n\nconst DEFAULT_RETENTION_DAYS = 90;\n\ntype RelationResponse = {\n  results: RelationResult[];\n  meta: { missingCount: number };\n};\n\nexport const createServiceUtils = ({ strapi }: { strapi: Core.Strapi }) => {\n  /**\n   * @description\n   * Get the difference between the version schema and the content type schema\n   */\n  const getSchemaAttributesDiff = (\n    versionSchemaAttributes: CreateHistoryVersion['schema'],\n    contentTypeSchemaAttributes: Struct.SchemaAttributes\n  ) => {\n    // Omit the same fields that were omitted when creating a history version\n    const sanitizedContentTypeSchemaAttributes = omit(\n      FIELDS_TO_IGNORE,\n      contentTypeSchemaAttributes\n    );\n\n    const reduceDifferenceToAttributesObject = (\n      diffKeys: string[],\n      source: CreateHistoryVersion['schema']\n    ) => {\n      return diffKeys.reduce<CreateHistoryVersion['schema']>(\n        (previousAttributesObject, diffKey) => {\n          previousAttributesObject[diffKey] = source[diffKey];\n\n          return previousAttributesObject;\n        },\n        {}\n      );\n    };\n\n    const versionSchemaKeys = Object.keys(versionSchemaAttributes);\n    const contentTypeSchemaAttributesKeys = Object.keys(sanitizedContentTypeSchemaAttributes);\n    // The attribute is new if it's on the content type schema but not on the version schema\n    const uniqueToContentType = difference(contentTypeSchemaAttributesKeys, versionSchemaKeys);\n    const added = reduceDifferenceToAttributesObject(\n      uniqueToContentType,\n      sanitizedContentTypeSchemaAttributes\n    );\n    // The attribute was removed or renamed if it's on the version schema but not on the content type schema\n    const uniqueToVersion = difference(versionSchemaKeys, contentTypeSchemaAttributesKeys);\n    const removed = reduceDifferenceToAttributesObject(uniqueToVersion, versionSchemaAttributes);\n\n    return { added, removed };\n  };\n\n  /**\n   * @description\n   * Gets the value to set for a relation when restoring a document\n   * @returns\n   * The relation if it exists or null\n   */\n  const getRelationRestoreValue = async (\n    versionRelationData: Data.Entity,\n    attribute: Schema.Attribute.RelationWithTarget\n  ) => {\n    if (Array.isArray(versionRelationData)) {\n      if (versionRelationData.length === 0) return versionRelationData;\n\n      const existingAndMissingRelations = await Promise.all(\n        versionRelationData.map((relation) => {\n          return strapi.documents(attribute.target).findOne({\n            documentId: relation.documentId,\n            locale: relation.locale || undefined,\n          });\n        })\n      );\n\n      return existingAndMissingRelations.filter(\n        (relation) => relation !== null\n      ) as Modules.Documents.AnyDocument[];\n    }\n\n    return strapi.documents(attribute.target).findOne({\n      documentId: versionRelationData.documentId,\n      locale: versionRelationData.locale || undefined,\n    });\n  };\n\n  /**\n   * @description\n   * Gets the value to set for a media asset when restoring a document\n   * @returns\n   * The media asset if it exists or null\n   */\n  const getMediaRestoreValue = async (\n    versionRelationData: Data.Entity,\n    attribute: Schema.Attribute.Media<any, boolean>\n  ) => {\n    if (attribute.multiple) {\n      const existingAndMissingMedias = await Promise.all(\n        // @ts-expect-error Fix the type definitions so this isn't any\n        versionRelationData.map((media) => {\n          return strapi.db.query('plugin::upload.file').findOne({ where: { id: media.id } });\n        })\n      );\n\n      return existingAndMissingMedias.filter((media) => media != null);\n    }\n\n    return strapi.db\n      .query('plugin::upload.file')\n      .findOne({ where: { id: versionRelationData.id } });\n  };\n\n  const localesService = strapi.plugin('i18n')?.service('locales');\n  const i18nContentTypeService = strapi.plugin('i18n')?.service('content-types');\n\n  const getDefaultLocale = async () => (localesService ? localesService.getDefaultLocale() : null);\n\n  const isLocalizedContentType = (model: Schema.ContentType) =>\n    i18nContentTypeService ? i18nContentTypeService.isLocalizedContentType(model) : false;\n\n  /**\n   *\n   * @description\n   * Creates a dictionary of all locales available\n   */\n  const getLocaleDictionary = async (): Promise<{\n    [key: string]: { name: string; code: string };\n  }> => {\n    if (!localesService) return {};\n\n    const locales = (await localesService.find()) || [];\n    return locales.reduce(\n      (\n        acc: Record<string, NonNullable<HistoryVersions.HistoryVersionDataResponse['locale']>>,\n        locale: NonNullable<HistoryVersions.HistoryVersionDataResponse['locale']>\n      ) => {\n        acc[locale.code] = { name: locale.name, code: locale.code };\n\n        return acc;\n      },\n      {}\n    );\n  };\n\n  /**\n   *\n   * @description\n   * Gets the number of retention days defined on the license or configured by the user\n   */\n  const getRetentionDays = () => {\n    const featureConfig = strapi.ee.features.get('cms-content-history');\n    const licenseRetentionDays =\n      typeof featureConfig === 'object' && featureConfig?.options.retentionDays;\n    const userRetentionDays: number = strapi.config.get('admin.history.retentionDays');\n\n    // Allow users to override the license retention days, but not to increase it\n    if (userRetentionDays && userRetentionDays < licenseRetentionDays) {\n      return userRetentionDays;\n    }\n\n    // User didn't provide retention days value, use the license or fallback to default\n    return Math.min(licenseRetentionDays, DEFAULT_RETENTION_DAYS);\n  };\n\n  const getVersionStatus = async (\n    contentTypeUid: HistoryVersions.CreateHistoryVersion['contentType'],\n    document: Modules.Documents.AnyDocument | null\n  ) => {\n    const documentMetadataService = strapi.plugin('content-manager').service('document-metadata');\n    const meta = await documentMetadataService.getMetadata(contentTypeUid, document);\n\n    return documentMetadataService.getStatus(document, meta.availableStatus);\n  };\n\n  /**\n   * @description\n   * Creates a populate object that looks for all the relations that need\n   * to be saved in history, and populates only the fields needed to later retrieve the content.\n   *\n   * @param uid - The content type UID\n   * @param useDatabaseSyntax - Whether to use the database syntax for populate, defaults to false\n   */\n  const getDeepPopulate = (uid: UID.Schema, useDatabaseSyntax = false) => {\n    const model = strapi.getModel(uid);\n    const attributes = Object.entries(model.attributes);\n    const fieldSelector = useDatabaseSyntax ? 'select' : 'fields';\n\n    return attributes.reduce((acc: any, [attributeName, attribute]) => {\n      switch (attribute.type) {\n        case 'relation': {\n          // TODO: Support polymorphic relations\n          const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n          if (isMorphRelation) {\n            break;\n          }\n\n          const isVisible = contentTypes.isVisibleAttribute(model, attributeName);\n          if (isVisible) {\n            acc[attributeName] = { [fieldSelector]: ['documentId', 'locale', 'publishedAt'] };\n          }\n          break;\n        }\n\n        case 'media': {\n          acc[attributeName] = { [fieldSelector]: ['id'] };\n          break;\n        }\n\n        case 'component': {\n          const populate = getDeepPopulate(attribute.component);\n          acc[attributeName] = { populate };\n          break;\n        }\n\n        case 'dynamiczone': {\n          // Use fragments to populate the dynamic zone components\n          const populatedComponents = (attribute.components || []).reduce(\n            (acc: any, componentUID: UID.Component) => {\n              acc[componentUID] = { populate: getDeepPopulate(componentUID) };\n              return acc;\n            },\n            {}\n          );\n\n          acc[attributeName] = { on: populatedComponents };\n          break;\n        }\n        default:\n          break;\n      }\n\n      return acc;\n    }, {});\n  };\n\n  /**\n   * @description\n   * Builds a response object for relations containing the related data and a count of missing relations\n   */\n  const buildMediaResponse = async (values: { id: Data.ID }[]): Promise<RelationResponse> => {\n    return (\n      values\n        // Until we implement proper pagination, limit relations to an arbitrary amount\n        .slice(0, 25)\n        .reduce(\n          async (currentRelationDataPromise, entry) => {\n            const currentRelationData = await currentRelationDataPromise;\n\n            // Entry can be null if it's a toOne relation\n            if (!entry) {\n              return currentRelationData;\n            }\n\n            const relatedEntry = await strapi.db\n              .query('plugin::upload.file')\n              .findOne({ where: { id: entry.id } });\n\n            if (relatedEntry) {\n              currentRelationData.results.push(relatedEntry);\n            } else {\n              // The related content has been deleted\n              currentRelationData.meta.missingCount += 1;\n            }\n\n            return currentRelationData;\n          },\n          Promise.resolve<RelationResponse>({\n            results: [],\n            meta: { missingCount: 0 },\n          })\n        )\n    );\n  };\n\n  /**\n   * @description\n   * Builds a response object for media containing the media assets data and a count of missing media assets\n   */\n  const buildRelationReponse = async (\n    values: {\n      documentId: string;\n      locale: string | null;\n    }[],\n    attributeSchema: Schema.Attribute.RelationWithTarget\n  ): Promise<RelationResponse> => {\n    return (\n      values\n        // Until we implement proper pagination, limit relations to an arbitrary amount\n        .slice(0, 25)\n        .reduce(\n          async (currentRelationDataPromise, entry) => {\n            const currentRelationData = await currentRelationDataPromise;\n\n            // Entry can be null if it's a toOne relation\n            if (!entry) {\n              return currentRelationData;\n            }\n\n            const relatedEntry = await strapi\n              .documents(attributeSchema.target)\n              .findOne({ documentId: entry.documentId, locale: entry.locale || undefined });\n\n            if (relatedEntry) {\n              currentRelationData.results.push({\n                ...relatedEntry,\n                status: await getVersionStatus(attributeSchema.target, relatedEntry),\n              });\n            } else {\n              // The related content has been deleted\n              currentRelationData.meta.missingCount += 1;\n            }\n\n            return currentRelationData;\n          },\n          Promise.resolve<RelationResponse>({\n            results: [],\n            meta: { missingCount: 0 },\n          })\n        )\n    );\n  };\n\n  return {\n    getSchemaAttributesDiff,\n    getRelationRestoreValue,\n    getMediaRestoreValue,\n    getDefaultLocale,\n    isLocalizedContentType,\n    getLocaleDictionary,\n    getRetentionDays,\n    getVersionStatus,\n    getDeepPopulate,\n    buildMediaResponse,\n    buildRelationReponse,\n  };\n};\n","import type { Core, Data, Schema, Struct } from '@strapi/types';\nimport { async, errors } from '@strapi/utils';\nimport { omit } from 'lodash/fp';\n\nimport { FIELDS_TO_IGNORE, HISTORY_VERSION_UID } from '../constants';\nimport type { HistoryVersions } from '../../../../shared/contracts';\nimport {\n  CreateHistoryVersion,\n  HistoryVersionDataResponse,\n} from '../../../../shared/contracts/history-versions';\nimport { createServiceUtils } from './utils';\nimport { getService as getContentManagerService } from '../../utils';\n\n// Needed because the query engine doesn't return any types yet\ntype HistoryVersionQueryResult = Omit<HistoryVersionDataResponse, 'locale'> &\n  Pick<CreateHistoryVersion, 'locale'>;\n\nconst createHistoryService = ({ strapi }: { strapi: Core.Strapi }) => {\n  const query = strapi.db.query(HISTORY_VERSION_UID);\n  const serviceUtils = createServiceUtils({ strapi });\n\n  return {\n    async createVersion(historyVersionData: HistoryVersions.CreateHistoryVersion) {\n      await query.create({\n        data: {\n          ...historyVersionData,\n          createdAt: new Date(),\n          createdBy: strapi.requestContext.get()?.state?.user.id,\n        },\n      });\n    },\n\n    async findVersionsPage(params: HistoryVersions.GetHistoryVersions.Request): Promise<{\n      results: HistoryVersions.HistoryVersionDataResponse[];\n      pagination: HistoryVersions.Pagination;\n    }> {\n      const model = strapi.getModel(params.query.contentType);\n      const isLocalizedContentType = serviceUtils.isLocalizedContentType(model);\n      const defaultLocale = await serviceUtils.getDefaultLocale();\n\n      let locale = null;\n      if (isLocalizedContentType) {\n        locale = params.query.locale || defaultLocale;\n      }\n\n      const [{ results, pagination }, localeDictionary] = await Promise.all([\n        query.findPage({\n          ...params.query,\n          where: {\n            $and: [\n              { contentType: params.query.contentType },\n              ...(params.query.documentId ? [{ relatedDocumentId: params.query.documentId }] : []),\n              ...(locale ? [{ locale }] : []),\n            ],\n          },\n          populate: ['createdBy'],\n          orderBy: [{ createdAt: 'desc' }],\n        }),\n        serviceUtils.getLocaleDictionary(),\n      ]);\n      const populateEntryRelations = async (\n        entry: HistoryVersionQueryResult\n      ): Promise<CreateHistoryVersion['data']> => {\n        const entryWithRelations = await Object.entries(entry.schema).reduce(\n          async (currentDataWithRelations, [attributeKey, attributeSchema]) => {\n            const attributeValue = entry.data[attributeKey];\n            const attributeValues = Array.isArray(attributeValue)\n              ? attributeValue\n              : [attributeValue];\n\n            if (attributeSchema.type === 'media') {\n              const permissionChecker = getContentManagerService('permission-checker').create({\n                userAbility: params.state.userAbility,\n                model: 'plugin::upload.file',\n              });\n\n              const response = await serviceUtils.buildMediaResponse(attributeValues);\n              const sanitizedResults = await Promise.all(\n                response.results.map((media) => permissionChecker.sanitizeOutput(media))\n              );\n\n              return {\n                ...(await currentDataWithRelations),\n                [attributeKey]: {\n                  results: sanitizedResults,\n                  meta: response.meta,\n                },\n              };\n            }\n\n            // TODO: handle relations that are inside components\n            if (\n              attributeSchema.type === 'relation' &&\n              attributeSchema.relation !== 'morphToOne' &&\n              attributeSchema.relation !== 'morphToMany'\n            ) {\n              /**\n               * Don't build the relations response object for relations to admin users,\n               * because pickAllowedAdminUserFields will sanitize the data in the controller.\n               */\n              if (attributeSchema.target === 'admin::user') {\n                const adminUsers = await Promise.all(\n                  attributeValues.map((userToPopulate) => {\n                    if (userToPopulate == null) {\n                      return null;\n                    }\n\n                    return strapi\n                      .query('admin::user')\n                      .findOne({ where: { id: userToPopulate.id } });\n                  })\n                );\n\n                return {\n                  ...(await currentDataWithRelations),\n                  /**\n                   * Ideally we would return the same \"{results: [], meta: {}}\" shape, however,\n                   * when sanitizing the data as a whole in the controller before sending to the client,\n                   * the data for admin relation user is completely sanitized if we return an object here as opposed to an array.\n                   */\n                  [attributeKey]: adminUsers,\n                };\n              }\n\n              const permissionChecker = getContentManagerService('permission-checker').create({\n                userAbility: params.state.userAbility,\n                model: attributeSchema.target,\n              });\n\n              const response = await serviceUtils.buildRelationReponse(\n                attributeValues,\n                attributeSchema\n              );\n              const sanitizedResults = await Promise.all(\n                response.results.map((media) => permissionChecker.sanitizeOutput(media))\n              );\n\n              return {\n                ...(await currentDataWithRelations),\n                [attributeKey]: {\n                  results: sanitizedResults,\n                  meta: response.meta,\n                },\n              };\n            }\n\n            // Not a media or relation, nothing to change\n            return currentDataWithRelations;\n          },\n          Promise.resolve(entry.data)\n        );\n\n        return entryWithRelations;\n      };\n\n      const formattedResults = await Promise.all(\n        (results as HistoryVersionQueryResult[]).map(async (result) => {\n          return {\n            ...result,\n            data: await populateEntryRelations(result),\n            meta: {\n              unknownAttributes: serviceUtils.getSchemaAttributesDiff(\n                result.schema,\n                strapi.getModel(params.query.contentType).attributes\n              ),\n            },\n            locale: result.locale ? localeDictionary[result.locale] : null,\n          };\n        })\n      );\n\n      return {\n        results: formattedResults,\n        pagination,\n      };\n    },\n\n    async restoreVersion(versionId: Data.ID) {\n      const version = await query.findOne({ where: { id: versionId } });\n      const contentTypeSchemaAttributes = strapi.getModel(version.contentType).attributes;\n      const schemaDiff = serviceUtils.getSchemaAttributesDiff(\n        version.schema,\n        contentTypeSchemaAttributes\n      );\n\n      // Set all added attribute values to null\n      const dataWithoutAddedAttributes = Object.keys(schemaDiff.added).reduce(\n        (currentData, addedKey) => {\n          currentData[addedKey] = null;\n          return currentData;\n        },\n        // Clone to avoid mutating the original version data\n        structuredClone(version.data)\n      );\n      const sanitizedSchemaAttributes = omit(\n        FIELDS_TO_IGNORE,\n        contentTypeSchemaAttributes\n      ) as Struct.SchemaAttributes;\n\n      // Set all deleted relation values to null\n      const reducer = async.reduce(Object.entries(sanitizedSchemaAttributes));\n      const dataWithoutMissingRelations = await reducer(\n        async (\n          previousRelationAttributes: Record<string, unknown>,\n          [name, attribute]: [string, Schema.Attribute.AnyAttribute]\n        ) => {\n          const versionRelationData = version.data[name];\n          if (!versionRelationData) {\n            return previousRelationAttributes;\n          }\n\n          if (\n            attribute.type === 'relation' &&\n            // TODO: handle polymorphic relations\n            attribute.relation !== 'morphToOne' &&\n            attribute.relation !== 'morphToMany'\n          ) {\n            const data = await serviceUtils.getRelationRestoreValue(versionRelationData, attribute);\n            previousRelationAttributes[name] = data;\n          }\n\n          if (attribute.type === 'media') {\n            const data = await serviceUtils.getMediaRestoreValue(versionRelationData, attribute);\n            previousRelationAttributes[name] = data;\n          }\n\n          return previousRelationAttributes;\n        },\n        // Clone to avoid mutating the original version data\n        structuredClone(dataWithoutAddedAttributes)\n      );\n\n      const data = omit(['id', ...Object.keys(schemaDiff.removed)], dataWithoutMissingRelations);\n      const restoredDocument = await strapi.documents(version.contentType).update({\n        documentId: version.relatedDocumentId,\n        locale: version.locale,\n        data,\n      });\n\n      if (!restoredDocument) {\n        throw new errors.ApplicationError('Failed to restore version');\n      }\n\n      return restoredDocument;\n    },\n  };\n};\n\nexport { createHistoryService };\n","import type { Core, Modules, UID } from '@strapi/types';\nimport { contentTypes } from '@strapi/utils';\n\nimport { omit, castArray } from 'lodash/fp';\n\nimport { scheduleJob } from 'node-schedule';\n\nimport { getService } from '../utils';\nimport { FIELDS_TO_IGNORE, HISTORY_VERSION_UID } from '../constants';\n\nimport { CreateHistoryVersion } from '../../../../shared/contracts/history-versions';\nimport { createServiceUtils } from './utils';\n\n/**\n * Filters out actions that should not create a history version.\n */\nconst shouldCreateHistoryVersion = (\n  context: Modules.Documents.Middleware.Context\n): context is Modules.Documents.Middleware.Context & {\n  action: 'create' | 'update' | 'clone' | 'publish' | 'unpublish' | 'discardDraft';\n  contentType: UID.CollectionType;\n} => {\n  // Ignore requests that are not related to the content manager\n  if (!strapi.requestContext.get()?.request.url.startsWith('/content-manager')) {\n    return false;\n  }\n\n  // NOTE: cannot do type narrowing with array includes\n  if (\n    context.action !== 'create' &&\n    context.action !== 'update' &&\n    context.action !== 'clone' &&\n    context.action !== 'publish' &&\n    context.action !== 'unpublish' &&\n    context.action !== 'discardDraft'\n  ) {\n    return false;\n  }\n\n  /**\n   * When a document is published, the draft version of the document is also updated.\n   * It creates confusion for users because they see two history versions each publish action.\n   * To avoid this, we silence the update action during a publish request,\n   * so that they only see the published version of the document in the history.\n   */\n  if (\n    context.action === 'update' &&\n    strapi.requestContext.get()?.request.url.endsWith('/actions/publish')\n  ) {\n    return false;\n  }\n\n  // Ignore content types not created by the user\n  if (!context.contentType.uid.startsWith('api::')) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Returns the content type schema (and its components schemas).\n * Used to determine if changes were made in the content type builder since a history version was created.\n * And therefore which fields can be restored and which cannot.\n */\nconst getSchemas = (uid: UID.CollectionType) => {\n  const attributesSchema = strapi.getModel(uid).attributes;\n\n  // TODO: Handle nested components\n  const componentsSchemas = Object.keys(attributesSchema).reduce(\n    (currentComponentSchemas, key) => {\n      const fieldSchema = attributesSchema[key];\n\n      if (fieldSchema.type === 'component') {\n        const componentSchema = strapi.getModel(fieldSchema.component).attributes;\n        return {\n          ...currentComponentSchemas,\n          [fieldSchema.component]: componentSchema,\n        };\n      }\n\n      // Ignore anything that's not a component\n      return currentComponentSchemas;\n    },\n    {} as CreateHistoryVersion['componentsSchemas']\n  );\n\n  return {\n    schema: omit(FIELDS_TO_IGNORE, attributesSchema) as CreateHistoryVersion['schema'],\n    componentsSchemas,\n  };\n};\n\nconst createLifecyclesService = ({ strapi }: { strapi: Core.Strapi }) => {\n  const state: {\n    deleteExpiredJob: ReturnType<typeof scheduleJob> | null;\n    isInitialized: boolean;\n  } = {\n    deleteExpiredJob: null,\n    isInitialized: false,\n  };\n\n  const serviceUtils = createServiceUtils({ strapi });\n\n  return {\n    async bootstrap() {\n      // Prevent initializing the service twice\n      if (state.isInitialized) {\n        return;\n      }\n\n      strapi.documents.use(async (context, next) => {\n        const result = (await next()) as any;\n\n        if (!shouldCreateHistoryVersion(context)) {\n          return result;\n        }\n\n        // On create/clone actions, the documentId is not available before creating the action is executed\n        const documentId =\n          context.action === 'create' || context.action === 'clone'\n            ? result.documentId\n            : context.params.documentId;\n\n        // Apply default locale if not available in the request\n        const defaultLocale = await serviceUtils.getDefaultLocale();\n        const locales = castArray(context.params?.locale || defaultLocale);\n        if (!locales.length) {\n          return result;\n        }\n\n        // All schemas related to the content type\n        const uid = context.contentType.uid;\n        const schemas = getSchemas(uid);\n        const model = strapi.getModel(uid);\n\n        const isLocalizedContentType = serviceUtils.isLocalizedContentType(model);\n\n        // Find all affected entries\n        const localeEntries = await strapi.db.query(uid).findMany({\n          where: {\n            documentId,\n            ...(isLocalizedContentType ? { locale: { $in: locales } } : {}),\n            ...(contentTypes.hasDraftAndPublish(strapi.contentTypes[uid])\n              ? { publishedAt: null }\n              : {}),\n          },\n          populate: serviceUtils.getDeepPopulate(uid, true /* use database syntax */),\n        });\n\n        await strapi.db.transaction(async ({ onCommit }) => {\n          // .createVersion() is executed asynchronously,\n          // onCommit prevents creating a history version\n          // when the transaction has already been committed\n          onCommit(async () => {\n            for (const entry of localeEntries) {\n              const status = await serviceUtils.getVersionStatus(uid, entry);\n\n              await getService(strapi, 'history').createVersion({\n                contentType: uid,\n                data: omit(FIELDS_TO_IGNORE, entry) as Modules.Documents.AnyDocument,\n                relatedDocumentId: documentId,\n                locale: entry.locale,\n                status,\n                ...schemas,\n              });\n            }\n          });\n        });\n\n        return result;\n      });\n\n      // Schedule a job to delete expired history versions every day at midnight\n      state.deleteExpiredJob = scheduleJob('0 0 * * *', () => {\n        const retentionDaysInMilliseconds = serviceUtils.getRetentionDays() * 24 * 60 * 60 * 1000;\n        const expirationDate = new Date(Date.now() - retentionDaysInMilliseconds);\n\n        strapi.db.query(HISTORY_VERSION_UID).deleteMany({\n          where: {\n            created_at: {\n              $lt: expirationDate.toISOString(),\n            },\n          },\n        });\n      });\n\n      state.isInitialized = true;\n    },\n\n    async destroy() {\n      if (state.deleteExpiredJob) {\n        state.deleteExpiredJob.cancel();\n      }\n    },\n  };\n};\n\nexport { createLifecyclesService };\n","import type { Plugin } from '@strapi/types';\nimport { createHistoryService } from './history';\nimport { createLifecyclesService } from './lifecycles';\n\nexport const services = {\n  history: createHistoryService,\n  lifecycles: createLifecyclesService,\n} satisfies Plugin.LoadedPlugin['services'];\n","import type { Plugin } from '@strapi/types';\n\nconst info = { pluginName: 'content-manager', type: 'admin' };\n\nconst historyVersionRouter: Plugin.LoadedPlugin['routes'][string] = {\n  type: 'admin',\n  routes: [\n    {\n      method: 'GET',\n      info,\n      path: '/history-versions',\n      handler: 'history-version.findMany',\n      config: {\n        policies: ['admin::isAuthenticatedAdmin'],\n      },\n    },\n    {\n      method: 'PUT',\n      info,\n      path: '/history-versions/:versionId/restore',\n      handler: 'history-version.restoreVersion',\n      config: {\n        policies: ['admin::isAuthenticatedAdmin'],\n      },\n    },\n  ],\n};\n\nexport { historyVersionRouter };\n","import type { Plugin } from '@strapi/types';\nimport { historyVersionRouter } from './history-version';\n\n/**\n * The routes will me merged with the other Content Manager routers,\n * so we need to avoid conficts in the router name, and to prefix the path for each route.\n */\nexport const routes = {\n  'history-version': historyVersionRouter,\n} satisfies Plugin.LoadedPlugin['routes'];\n","import type { Model } from '@strapi/database';\nimport { HISTORY_VERSION_UID } from '../constants';\n\nconst historyVersion: Model = {\n  uid: HISTORY_VERSION_UID,\n  tableName: 'strapi_history_versions',\n  singularName: 'history-version',\n  attributes: {\n    id: {\n      type: 'increments',\n    },\n    contentType: {\n      type: 'string',\n      column: { notNullable: true },\n    },\n    relatedDocumentId: {\n      type: 'string',\n      // TODO: notNullable should be true once history can record publish actions\n      column: { notNullable: false },\n    },\n    locale: {\n      type: 'string',\n    },\n    status: {\n      type: 'enumeration',\n      enum: ['draft', 'published', 'modified'],\n    },\n    data: {\n      type: 'json',\n    },\n    schema: {\n      type: 'json',\n    },\n    createdAt: {\n      type: 'datetime',\n      default: () => new Date(),\n    },\n    // FIXME: joinTable should be optional\n    // @ts-expect-error database model is not yet updated to support useJoinTable\n    createdBy: {\n      type: 'relation',\n      relation: 'oneToOne',\n      target: 'admin::user',\n      useJoinTable: false,\n    },\n  },\n};\n\nexport { historyVersion };\n","import type { Plugin } from '@strapi/types';\nimport { controllers } from './controllers';\nimport { services } from './services';\nimport { routes } from './routes';\nimport { getService } from './utils';\nimport { historyVersion } from './models/history-version';\n\n/**\n * Check once if the feature is enabled before loading it,\n * so that we can assume it is enabled in the other files.\n */\nconst getFeature = (): Partial<Plugin.LoadedPlugin> => {\n  if (strapi.ee.features.isEnabled('cms-content-history')) {\n    return {\n      register({ strapi }) {\n        strapi.get('models').add(historyVersion);\n      },\n      bootstrap({ strapi }) {\n        // Start recording history and saving history versions\n        getService(strapi, 'lifecycles').bootstrap();\n      },\n      destroy({ strapi }) {\n        getService(strapi, 'lifecycles').destroy();\n      },\n      controllers,\n      services,\n      routes,\n    };\n  }\n\n  /**\n   * Keep registering the model to avoid losing the data if the feature is disabled,\n   * or if the license expires.\n   */\n  return {\n    register({ strapi }) {\n      strapi.get('models').add(historyVersion);\n    },\n  };\n};\n\nexport default getFeature();\n","import type { Plugin } from '@strapi/types';\nimport history from './history';\n\nconst register: Plugin.LoadedPlugin['register'] = async ({ strapi }) => {\n  await history.register?.({ strapi });\n};\n\nexport default register;\n","const ALLOWED_WEBHOOK_EVENTS = {\n  ENTRY_PUBLISH: 'entry.publish',\n  ENTRY_UNPUBLISH: 'entry.unpublish',\n};\n\nexport { ALLOWED_WEBHOOK_EVENTS };\n","import { getService } from './utils';\nimport { ALLOWED_WEBHOOK_EVENTS } from './constants';\nimport history from './history';\n\nexport default async () => {\n  Object.entries(ALLOWED_WEBHOOK_EVENTS).forEach(([key, value]) => {\n    strapi.get('webhookStore').addAllowedEvent(key, value);\n  });\n\n  getService('field-sizes').setCustomFieldInputSizes();\n  await getService('components').syncConfigurations();\n  await getService('content-types').syncConfigurations();\n  await getService('permission').registerPermissions();\n\n  await history.bootstrap?.({ strapi });\n};\n","import type { Plugin } from '@strapi/types';\nimport history from './history';\n\nconst destroy: Plugin.LoadedPlugin['destroy'] = async ({ strapi }) => {\n  await history.destroy?.({ strapi });\n};\n\nexport default destroy;\n","import type { UID, Core, Struct } from '@strapi/types';\nimport type { Context, Next } from 'koa';\nimport isNil from 'lodash/isNil';\n\ninterface ContentType extends Struct.ContentTypeSchema {\n  plugin?: string;\n}\n\nexport default async (ctx: Context, next: Next) => {\n  const { model }: { model: UID.ContentType } = ctx.params;\n\n  const ct: ContentType = strapi.contentTypes[model];\n\n  if (!ct) {\n    return ctx.send({ error: 'contentType.notFound' }, 404);\n  }\n\n  let controllers;\n  if (!ct.plugin || ct.plugin === 'admin') {\n    controllers = strapi.admin.controllers;\n  } else {\n    controllers = strapi.plugin(ct.plugin).controllers;\n  }\n\n  const { route }: { route: Core.Route } = ctx.state;\n\n  if (typeof route.handler !== 'string') {\n    return next();\n  }\n\n  const [, action] = route.handler.split('.');\n\n  let actionConfig: any;\n  if (!ct.plugin || ct.plugin === 'admin') {\n    actionConfig = strapi.config.get(`admin.layout.${ct.modelName}.actions.${action}`);\n  } else {\n    actionConfig = strapi.plugin(ct.plugin).config(`layout.${ct.modelName}.actions.${action}`);\n  }\n\n  if (!isNil(actionConfig)) {\n    const [controller, action] = actionConfig.split('.');\n\n    if (controller && action) {\n      return controllers[controller.toLowerCase()][action](ctx, next);\n    }\n  }\n\n  await next();\n};\n","import { routing } from '../middlewares';\n\nexport default {\n  type: 'admin',\n  routes: [\n    {\n      method: 'GET',\n      path: '/init',\n      handler: 'init.getInitData',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/content-types',\n      handler: 'content-types.findContentTypes',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/content-types-settings',\n      handler: 'content-types.findContentTypesSettings',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/content-types/:uid/configuration',\n      handler: 'content-types.findContentTypeConfiguration',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/content-types/:uid/configuration',\n      handler: 'content-types.updateContentTypeConfiguration',\n      config: {\n        policies: ['admin::isAuthenticatedAdmin'],\n      },\n    },\n\n    {\n      method: 'GET',\n      path: '/components',\n      handler: 'components.findComponents',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/components/:uid/configuration',\n      handler: 'components.findComponentConfiguration',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/components/:uid/configuration',\n      handler: 'components.updateComponentConfiguration',\n      config: {\n        policies: [],\n      },\n    },\n\n    {\n      method: 'POST',\n      path: '/uid/generate',\n      handler: 'uid.generateUID',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/uid/check-availability',\n      handler: 'uid.checkUIDAvailability',\n      config: {\n        policies: [],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/relations/:model/:targetField',\n      handler: 'relations.findAvailable',\n      config: {\n        policies: ['admin::isAuthenticatedAdmin'],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/relations/:model/:id/:targetField',\n      handler: 'relations.findExisting',\n      config: {\n        policies: ['admin::isAuthenticatedAdmin'],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/single-types/:model',\n      handler: 'single-types.find',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/single-types/:model',\n      handler: 'single-types.createOrUpdate',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: {\n              actions: [\n                'plugin::content-manager.explorer.create',\n                'plugin::content-manager.explorer.update',\n              ],\n              hasAtLeastOne: true,\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/single-types/:model',\n      handler: 'single-types.delete',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.delete'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/single-types/:model/actions/publish',\n      handler: 'single-types.publish',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/single-types/:model/actions/unpublish',\n      handler: 'single-types.unpublish',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/single-types/:model/actions/discard',\n      handler: 'single-types.discard',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.update'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/single-types/:model/actions/countDraftRelations',\n      handler: 'single-types.countDraftRelations',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/collection-types/:model',\n      handler: 'collection-types.find',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model',\n      handler: 'collection-types.create',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.create'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/clone/:sourceId',\n      handler: 'collection-types.clone',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.create'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/auto-clone/:sourceId',\n      handler: 'collection-types.autoClone',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.create'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/collection-types/:model/:id',\n      handler: 'collection-types.findOne',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/collection-types/:model/:id',\n      handler: 'collection-types.update',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.update'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/collection-types/:model/:id',\n      handler: 'collection-types.delete',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.delete'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/actions/publish',\n      handler: 'collection-types.publish',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/:id/actions/publish',\n      handler: 'collection-types.publish',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/:id/actions/unpublish',\n      handler: 'collection-types.unpublish',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/:id/actions/discard',\n      handler: 'collection-types.discard',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.update'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/actions/bulkDelete',\n      handler: 'collection-types.bulkDelete',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.delete'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/actions/bulkPublish',\n      handler: 'collection-types.bulkPublish',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/collection-types/:model/actions/bulkUnpublish',\n      handler: 'collection-types.bulkUnpublish',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/collection-types/:model/:id/actions/countDraftRelations',\n      handler: 'collection-types.countDraftRelations',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/collection-types/:model/actions/countManyEntriesDraftRelations',\n      handler: 'collection-types.countManyEntriesDraftRelations',\n      config: {\n        middlewares: [routing],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'plugin::content-manager.hasPermissions',\n            config: { actions: ['plugin::content-manager.explorer.read'] },\n          },\n        ],\n      },\n    },\n  ],\n};\n","import admin from './admin';\nimport history from '../history';\n\nexport default {\n  admin,\n  ...(history.routes ? history.routes : {}),\n};\n","import { yup, validateYupSchemaSync } from '@strapi/utils';\n\nconst hasPermissionsSchema = yup.object({\n  actions: yup.array().of(yup.string()),\n  hasAtLeastOne: yup.boolean(),\n});\n\nexport const validateHasPermissionsInput = validateYupSchemaSync(hasPermissionsSchema);\n","import type { Context } from 'koa';\nimport { policy } from '@strapi/utils';\nimport { validateHasPermissionsInput } from '../validation/policies/hasPermissions';\n\nconst { createPolicy } = policy;\n\nexport default createPolicy({\n  name: 'plugin::content-manager.hasPermissions',\n  validator: validateHasPermissionsInput,\n  /**\n   * NOTE: Action aliases are currently not checked at this level (policy).\n   *       This is currently the intended behavior to avoid changing the behavior of API related permissions.\n   *       If you want to add support for it, please create a dedicated RFC with a list of potential side effect this could have.\n   */\n  handler(ctx: Context, config = {}) {\n    const { actions = [], hasAtLeastOne = false }: { actions: string[]; hasAtLeastOne: boolean } =\n      config;\n\n    const { userAbility } = ctx.state;\n    const { model }: { model: string } = ctx.params;\n\n    const isAuthorized = hasAtLeastOne\n      ? actions.some((action) => userAbility.can(action, model))\n      : actions.every((action) => userAbility.can(action, model));\n\n    return isAuthorized;\n  },\n});\n","import hasPermissions from './hasPermissions';\n\nexport default {\n  hasPermissions,\n};\n","import _ from 'lodash';\nimport { intersection } from 'lodash/fp';\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\n\nconst { getNonVisibleAttributes, getWritableAttributes } = contentTypesUtils;\nconst { PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } =\n  contentTypesUtils.constants;\n\nconst NON_SORTABLES = ['component', 'json', 'media', 'richtext', 'dynamiczone', 'blocks'];\nconst SORTABLE_RELATIONS = ['oneToOne', 'manyToOne'];\n\nconst NON_LISTABLES = ['json', 'password', 'richtext', 'dynamiczone', 'blocks'];\nconst LISTABLE_RELATIONS = ['oneToOne', 'oneToMany', 'manyToOne', 'manyToMany'];\n\n// hidden fields are fields that are configured to be hidden from list, and edit views\nconst isHidden = (schema: any, name: any) => {\n  if (!_.has(schema.attributes, name)) {\n    return false;\n  }\n\n  const isHidden = _.get(schema, ['config', 'attributes', name, 'hidden'], false);\n  if (isHidden === true) {\n    return true;\n  }\n\n  return false;\n};\n\nconst isListable = (schema: any, name: any) => {\n  if (!_.has(schema.attributes, name)) {\n    return false;\n  }\n\n  if (isHidden(schema, name)) {\n    return false;\n  }\n\n  const attribute = schema.attributes[name];\n  if (NON_LISTABLES.includes(attribute.type)) {\n    return false;\n  }\n\n  if (isRelation(attribute) && !LISTABLE_RELATIONS.includes(attribute.relationType)) {\n    return false;\n  }\n\n  return true;\n};\n\nconst isSortable = (schema: any, name: any) => {\n  if (!_.has(schema.attributes, name)) {\n    return false;\n  }\n\n  if (schema.modelType === 'component' && name === 'id') return false;\n\n  const attribute = schema.attributes[name];\n  if (NON_SORTABLES.includes(attribute.type)) {\n    return false;\n  }\n\n  if (isRelation(attribute) && !SORTABLE_RELATIONS.includes(attribute.relationType)) {\n    return false;\n  }\n\n  return true;\n};\n\nconst isSearchable = (schema: any, name: any) => {\n  return isSortable(schema, name);\n};\n\nconst isVisible = (schema: any, name: any) => {\n  if (!_.has(schema.attributes, name)) {\n    return false;\n  }\n\n  if (isHidden(schema, name)) {\n    return false;\n  }\n\n  if (isTimestamp(schema, name) || name === 'id') {\n    return false;\n  }\n\n  if (isPublicationField(name)) {\n    return false;\n  }\n\n  if (isCreatorField(schema, name)) {\n    return false;\n  }\n\n  return true;\n};\n\nconst isPublicationField = (name: any) => PUBLISHED_AT_ATTRIBUTE === name;\n\nconst isTimestamp = (schema: any, name: any) => {\n  if (!_.has(schema.attributes, name)) {\n    return false;\n  }\n\n  const timestamps = contentTypesUtils.getTimestamps(schema);\n  if (!timestamps || !Array.isArray(timestamps)) {\n    return false;\n  }\n\n  if (timestamps.includes(name)) {\n    return true;\n  }\n};\n\nconst isCreatorField = (schema: any, name: any) => {\n  if (!_.has(schema.attributes, name)) {\n    return false;\n  }\n\n  const creatorFields = contentTypesUtils.getCreatorFields(schema);\n  if (!creatorFields || !Array.isArray(creatorFields)) {\n    return false;\n  }\n\n  if (creatorFields.includes(name)) {\n    return true;\n  }\n};\n\nconst isRelation = (attribute: any) => attribute.type === 'relation';\n\nconst hasRelationAttribute = (schema: any, name: any) => {\n  if (!_.has(schema.attributes, name)) {\n    return false;\n  }\n\n  if (isHidden(schema, name)) {\n    return false;\n  }\n\n  if (!isVisible(schema, name)) {\n    return false;\n  }\n\n  return isRelation(schema.attributes[name]);\n};\n\nconst hasEditableAttribute = (schema: any, name: any) => {\n  if (!_.has(schema.attributes, name)) {\n    return false;\n  }\n\n  if (isHidden(schema, name)) {\n    return false;\n  }\n\n  if (!isVisible(schema, name)) {\n    return false;\n  }\n\n  return true;\n};\n\nconst findFirstStringAttribute = (schema: any) => {\n  return Object.keys(schema.attributes || {}).find((key) => {\n    const { type } = schema.attributes[key];\n    return type === 'string' && key !== 'id';\n  });\n};\n\nconst getDefaultMainField = (schema: any) => findFirstStringAttribute(schema) || 'id';\n\n/**\n * Returns list of all sortable attributes for a given content type schema\n * TODO V5: Refactor non visible fields to be a part of content-manager schema so we can use isSortable instead\n * @param {*} schema\n * @returns\n */\nconst getSortableAttributes = (schema: any) => {\n  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));\n\n  const model = strapi.getModel(schema.uid);\n  const nonVisibleWritableAttributes = intersection(\n    getNonVisibleAttributes(model),\n    getWritableAttributes(model)\n  );\n\n  return [\n    'id',\n    ...validAttributes,\n    ...nonVisibleWritableAttributes,\n    CREATED_BY_ATTRIBUTE,\n    UPDATED_BY_ATTRIBUTE,\n  ];\n};\n\nexport {\n  isSortable,\n  isVisible,\n  isSearchable,\n  isRelation,\n  isListable,\n  hasEditableAttribute,\n  hasRelationAttribute,\n  getDefaultMainField,\n  getSortableAttributes,\n};\n","import { isEmpty, pick, pipe, propOr, isEqual } from 'lodash/fp';\nimport { traverse } from '@strapi/utils';\nimport qs from 'qs';\nimport { isSortable, getDefaultMainField, getSortableAttributes } from './attributes';\n\n/** General settings */\nconst DEFAULT_SETTINGS = {\n  bulkable: true,\n  filterable: true,\n  searchable: true,\n  pageSize: 10,\n};\n\nconst settingsFields = [\n  'searchable',\n  'filterable',\n  'bulkable',\n  'pageSize',\n  'mainField',\n  'defaultSortBy',\n  'defaultSortOrder',\n];\n\nconst getModelSettings = pipe([propOr({}, 'config.settings'), pick(settingsFields)]);\n\nasync function isValidDefaultSort(schema: any, value: any) {\n  const parsedValue = qs.parse(value);\n\n  const omitNonSortableAttributes = ({ schema, key }: any, { remove }: any) => {\n    const sortableAttributes = getSortableAttributes(schema);\n    if (!sortableAttributes.includes(key)) {\n      remove(key);\n    }\n  };\n\n  const sanitizedValue = await traverse.traverseQuerySort(\n    omitNonSortableAttributes,\n    { schema, getModel: strapi.getModel.bind(strapi) },\n    parsedValue\n  );\n\n  // If any of the keys has been removed, the sort attribute is not valid\n  return isEqual(parsedValue, sanitizedValue);\n}\n\nconst createDefaultSettings = async (schema: any) => {\n  const defaultField = getDefaultMainField(schema);\n\n  return {\n    ...DEFAULT_SETTINGS,\n    mainField: defaultField,\n    defaultSortBy: defaultField,\n    defaultSortOrder: 'ASC',\n    ...getModelSettings(schema),\n  };\n};\n\nconst syncSettings = async (configuration: any, schema: any) => {\n  if (isEmpty(configuration.settings)) return createDefaultSettings(schema);\n\n  const defaultField = getDefaultMainField(schema);\n\n  const { mainField = defaultField, defaultSortBy = defaultField } = configuration.settings || {};\n\n  return {\n    ...configuration.settings,\n    mainField: isSortable(schema, mainField) ? mainField : defaultField,\n    defaultSortBy: (await isValidDefaultSort(schema, defaultSortBy)) ? defaultSortBy : defaultField,\n  };\n};\n\nexport { isValidDefaultSort, createDefaultSettings, syncSettings };\n","import { yup } from '@strapi/utils';\nimport { getService } from '../../utils';\nimport { isListable, hasEditableAttribute } from '../../services/utils/configuration/attributes';\nimport { isValidDefaultSort } from '../../services/utils/configuration/settings';\n\n/**\n * Creates the validation schema for content-type configurations\n */\nexport default (schema: any, opts = {}) =>\n  yup\n    .object()\n    .shape({\n      settings: createSettingsSchema(schema).default(null).nullable(),\n      metadatas: createMetadasSchema(schema).default(null).nullable(),\n      layouts: createLayoutsSchema(schema, opts).default(null).nullable(),\n      options: yup.object().optional(),\n    })\n    .noUnknown();\n\nconst createSettingsSchema = (schema: any) => {\n  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));\n\n  return yup\n    .object()\n    .shape({\n      bulkable: yup.boolean().required(),\n      filterable: yup.boolean().required(),\n      pageSize: yup.number().integer().min(10).max(100).required(),\n      searchable: yup.boolean().required(),\n      // should be reset when the type changes\n      mainField: yup.string().oneOf(validAttributes.concat('id')).default('id'),\n      // should be reset when the type changes\n      defaultSortBy: yup\n        .string()\n        .test('is-valid-sort-attribute', '${path} is not a valid sort attribute', async (value) =>\n          isValidDefaultSort(schema, value)\n        )\n        .default('id'),\n      defaultSortOrder: yup.string().oneOf(['ASC', 'DESC']).default('ASC'),\n    })\n    .noUnknown();\n};\n\nconst createMetadasSchema = (schema: any) => {\n  return yup.object().shape(\n    Object.keys(schema.attributes).reduce((acc: any, key) => {\n      acc[key] = yup\n        .object()\n        .shape({\n          edit: yup\n            .object()\n            .shape({\n              label: yup.string(),\n              description: yup.string(),\n              placeholder: yup.string(),\n              editable: yup.boolean(),\n              visible: yup.boolean(),\n              mainField: yup.lazy((value) => {\n                if (!value) {\n                  return yup.string();\n                }\n\n                const targetSchema = getService('content-types').findContentType(\n                  schema.attributes[key].targetModel\n                );\n\n                if (!targetSchema) {\n                  return yup.string();\n                }\n\n                const validAttributes = Object.keys(targetSchema.attributes).filter((key) =>\n                  isListable(targetSchema, key)\n                );\n\n                return yup.string().oneOf(validAttributes.concat('id')).default('id');\n              }),\n            })\n            .noUnknown()\n            .required(),\n          list: yup\n            .object()\n            .shape({\n              label: yup.string(),\n              searchable: yup.boolean(),\n              sortable: yup.boolean(),\n            })\n            .noUnknown()\n            .required(),\n        })\n        .noUnknown();\n\n      return acc;\n    }, {})\n  );\n};\n\nconst createArrayTest = ({ allowUndefined = false } = {}) => ({\n  name: 'isArray',\n  message: '${path} is required and must be an array',\n  test: (val: any) => (allowUndefined === true && val === undefined ? true : Array.isArray(val)),\n});\n\nconst createLayoutsSchema = (schema: any, opts = {}) => {\n  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));\n\n  const editAttributes = Object.keys(schema.attributes).filter((key) =>\n    hasEditableAttribute(schema, key)\n  );\n\n  return yup.object().shape({\n    edit: yup\n      .array()\n      .of(\n        yup.array().of(\n          yup\n            .object()\n            .shape({\n              name: yup.string().oneOf(editAttributes).required(),\n              size: yup.number().integer().positive().required(),\n            })\n            .noUnknown()\n        )\n      )\n      .test(createArrayTest(opts)),\n    list: yup.array().of(yup.string().oneOf(validAttributes)).test(createArrayTest(opts)),\n  });\n};\n","import _ from 'lodash';\nimport { yup, validateYupSchema, errors } from '@strapi/utils';\nimport createModelConfigurationSchema from './model-configuration';\n\nconst { PaginationError, ValidationError } = errors;\nconst TYPES = ['singleType', 'collectionType'];\n\n/**\n * Validates type kind\n */\nconst kindSchema = yup.string().oneOf(TYPES).nullable();\n\nconst bulkActionInputSchema = yup\n  .object({\n    documentIds: yup.array().of(yup.strapiID()).min(1).required(),\n  })\n  .required();\n\nconst generateUIDInputSchema = yup.object({\n  contentTypeUID: yup.string().required(),\n  field: yup.string().required(),\n  data: yup.object().required(),\n});\n\nconst checkUIDAvailabilityInputSchema = yup.object({\n  contentTypeUID: yup.string().required(),\n  field: yup.string().required(),\n  value: yup\n    .string()\n    .matches(/^[A-Za-z0-9-_.~]*$/)\n    .required(),\n});\n\nconst validateUIDField = (contentTypeUID: any, field: any) => {\n  const model = strapi.contentTypes[contentTypeUID];\n\n  if (!model) {\n    throw new ValidationError('ContentType not found');\n  }\n\n  if (\n    !_.has(model, ['attributes', field]) ||\n    _.get(model, ['attributes', field, 'type']) !== 'uid'\n  ) {\n    throw new ValidationError(`${field} must be a valid \\`uid\\` attribute`);\n  }\n};\n\nconst validatePagination = ({ page, pageSize }: any) => {\n  const pageNumber = parseInt(page, 10);\n  const pageSizeNumber = parseInt(pageSize, 10);\n\n  if (Number.isNaN(pageNumber) || pageNumber < 1) {\n    throw new PaginationError('invalid pageNumber param');\n  }\n  if (Number.isNaN(pageSizeNumber) || pageSizeNumber < 1) {\n    throw new PaginationError('invalid pageSize param');\n  }\n};\n\nconst validateKind = validateYupSchema(kindSchema);\nconst validateBulkActionInput = validateYupSchema(bulkActionInputSchema);\nconst validateGenerateUIDInput = validateYupSchema(generateUIDInputSchema);\nconst validateCheckUIDAvailabilityInput = validateYupSchema(checkUIDAvailabilityInputSchema);\n\nexport {\n  createModelConfigurationSchema,\n  validateUIDField,\n  validatePagination,\n  validateKind,\n  validateBulkActionInput,\n  validateGenerateUIDInput,\n  validateCheckUIDAvailabilityInput,\n};\n","import { set } from 'lodash/fp';\nimport strapiUtils from '@strapi/utils';\nimport { ProhibitedCloningField } from '../../../../shared/contracts/collection-types';\n\nconst { isVisibleAttribute } = strapiUtils.contentTypes;\n\n/**\n * Use an array of strings to represent the path to a field, so we can show breadcrumbs in the admin\n * We can't use special characters as delimiters, because the path includes display names\n * for dynamic zone components, which can contain any character.\n */\n\nfunction checkRelation(model: any, attributeName: any, path: string[]): ProhibitedCloningField[] {\n  // we don't care about createdBy, updatedBy, localizations etc.\n  if (!isVisibleAttribute(model, attributeName)) {\n    // Return empty array and not null so we can always spread the result\n    return [];\n  }\n\n  /**\n   * Only one-to-many and one-to-one (when they're reversed, not one-way) are dangerous,\n   * because the other relations don't \"steal\" the relation from the entry we're cloning\n   */\n  const { relation, inversedBy, mappedBy } = model.attributes[attributeName];\n\n  if (\n    ['oneToOne', 'oneToMany'].includes(relation) &&\n    [mappedBy, inversedBy].some((key) => key != null)\n  ) {\n    return [[[...path, attributeName], 'relation']];\n  }\n\n  return [];\n}\n\nconst getProhibitedCloningFields = (\n  uid: any,\n  pathPrefix: string[] = []\n): ProhibitedCloningField[] => {\n  const model = strapi.getModel(uid);\n\n  const prohibitedFields = Object.keys(model.attributes).reduce<ProhibitedCloningField[]>(\n    (acc, attributeName) => {\n      const attribute: any = model.attributes[attributeName];\n      const attributePath = [...pathPrefix, attributeName];\n\n      switch (attribute.type) {\n        case 'relation':\n          return [...acc, ...checkRelation(model, attributeName, pathPrefix)];\n        case 'component':\n          return [...acc, ...getProhibitedCloningFields(attribute.component, attributePath)];\n        case 'dynamiczone':\n          return [\n            ...acc,\n            ...(attribute.components || []).flatMap((componentUID: any) =>\n              getProhibitedCloningFields(componentUID, [\n                ...attributePath,\n                strapi.getModel(componentUID).info.displayName,\n              ])\n            ),\n          ];\n        case 'uid':\n          return [...acc, [attributePath, 'unique']];\n        default:\n          if (attribute?.unique) {\n            return [...acc, [attributePath, 'unique']];\n          }\n          return acc;\n      }\n    },\n    []\n  );\n\n  return prohibitedFields;\n};\n\n/**\n * Iterates all attributes of the content type, and removes the ones that are not creatable.\n *   - If it's a relation, it sets the value to [] or null.\n *   - If it's a regular attribute, it sets the value to null.\n * When cloning, if you don't set a field it will be copied from the original entry. So we need to\n * remove the fields that the user can't create.\n */\nconst excludeNotCreatableFields =\n  (uid: any, permissionChecker: any) =>\n  (body: any, path = []): any => {\n    const model = strapi.getModel(uid);\n    const canCreate = (path: any) => permissionChecker.can.create(null, path);\n\n    return Object.keys(model.attributes).reduce((body, attributeName) => {\n      const attribute = model.attributes[attributeName];\n      const attributePath = [...path, attributeName].join('.');\n\n      // Ignore the attribute if it's not visible\n      if (!isVisibleAttribute(model, attributeName)) {\n        return body;\n      }\n\n      switch (attribute.type) {\n        // Relation should be empty if the user can't create it\n        case 'relation': {\n          if (canCreate(attributePath)) return body;\n          return set(attributePath, { set: [] }, body);\n        }\n        // Go deeper into the component\n        case 'component': {\n          return excludeNotCreatableFields(attribute.component, permissionChecker)(body, [\n            ...path,\n            attributeName,\n          ] as any);\n        }\n        // Attribute should be null if the user can't create it\n        default: {\n          if (canCreate(attributePath)) return body;\n          return set(attributePath, null, body);\n        }\n      }\n    }, body);\n  };\n\nexport { getProhibitedCloningFields, excludeNotCreatableFields };\n","import { errors, yup, validateYupSchema, contentTypes } from '@strapi/utils';\nimport type { UID } from '@strapi/types';\n\ninterface Options {\n  allowMultipleLocales?: boolean;\n}\n\nconst singleLocaleSchema = yup.string().nullable();\n\nconst multipleLocaleSchema = yup.lazy((value) =>\n  Array.isArray(value) ? yup.array().of(singleLocaleSchema.required()) : singleLocaleSchema\n);\n\nconst statusSchema = yup.mixed().oneOf(['draft', 'published'], 'Invalid status');\n\n/**\n * From a request or query object, validates and returns the locale and status of the document.\n * If the status is not provided and Draft & Publish is disabled, it defaults to 'published'.\n */\nexport const getDocumentLocaleAndStatus = async (\n  request: any,\n  model: UID.Schema,\n  opts: Options = { allowMultipleLocales: false }\n) => {\n  const { allowMultipleLocales } = opts;\n  const { locale, status: providedStatus, ...rest } = request || {};\n\n  const defaultStatus = contentTypes.hasDraftAndPublish(strapi.getModel(model))\n    ? undefined\n    : 'published';\n  const status = providedStatus !== undefined ? providedStatus : defaultStatus;\n\n  const schema = yup.object().shape({\n    locale: allowMultipleLocales ? multipleLocaleSchema : singleLocaleSchema,\n    status: statusSchema,\n  });\n\n  try {\n    await validateYupSchema(schema, { strict: true, abortEarly: false })(request);\n\n    return { locale, status, ...rest };\n  } catch (error: any) {\n    throw new errors.ValidationError(`Validation error: ${error.message}`);\n  }\n};\n","import { UID } from '@strapi/types';\nimport { async } from '@strapi/utils';\n\nimport { getService } from '../../utils';\n\nimport { DocumentVersion, GetMetadataOptions } from '../../services/document-metadata';\n\nimport type {\n  AvailableLocaleDocument,\n  AvailableStatusDocument,\n} from '../../../../shared/contracts/collection-types';\n\n/**\n * Format a document with metadata. Making sure the metadata response is\n * correctly sanitized for the current user\n */\nexport const formatDocumentWithMetadata = async (\n  permissionChecker: any,\n  uid: UID.ContentType,\n  document: DocumentVersion,\n  opts: GetMetadataOptions = {}\n) => {\n  const documentMetadata = getService('document-metadata');\n\n  const serviceOutput = await documentMetadata.formatDocumentWithMetadata(uid, document, opts);\n\n  let {\n    meta: { availableLocales, availableStatus },\n  } = serviceOutput;\n\n  const metadataSanitizer = permissionChecker.sanitizeOutput;\n\n  availableLocales = await async.map(\n    availableLocales,\n    async (localeDocument: AvailableLocaleDocument) => metadataSanitizer(localeDocument)\n  );\n\n  availableStatus = await async.map(\n    availableStatus,\n    async (statusDocument: AvailableStatusDocument) => metadataSanitizer(statusDocument)\n  );\n\n  return {\n    ...serviceOutput,\n    meta: {\n      availableLocales,\n      availableStatus,\n    },\n  };\n};\n","import { isNil } from 'lodash/fp';\n\nimport { setCreatorFields, async, errors } from '@strapi/utils';\nimport type { Modules, UID } from '@strapi/types';\n\nimport { getService } from '../utils';\nimport { validateBulkActionInput } from './validation';\nimport { getProhibitedCloningFields, excludeNotCreatableFields } from './utils/clone';\nimport { getDocumentLocaleAndStatus } from './validation/dimensions';\nimport { formatDocumentWithMetadata } from './utils/metadata';\n\ntype Options = Modules.Documents.Params.Pick<UID.ContentType, 'populate:object'>;\n\n/**\n * Create a new document.\n *\n * @param ctx - Koa context\n * @param opts - Options\n * @param opts.populate - Populate options of the returned document.\n *                        By default documentManager will populate all relations.\n */\nconst createDocument = async (ctx: any, opts?: Options) => {\n  const { userAbility, user } = ctx.state;\n  const { model } = ctx.params;\n  const { body } = ctx.request;\n\n  const documentManager = getService('document-manager');\n  const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n  if (permissionChecker.cannot.create()) {\n    throw new errors.ForbiddenError();\n  }\n\n  const pickPermittedFields = permissionChecker.sanitizeCreateInput;\n  const setCreator = setCreatorFields({ user });\n  const sanitizeFn = async.pipe(pickPermittedFields, setCreator as any);\n  const sanitizedBody = await sanitizeFn(body);\n\n  const { locale, status } = await getDocumentLocaleAndStatus(body, model);\n\n  return documentManager.create(model, {\n    data: sanitizedBody as any,\n    locale,\n    status,\n    populate: opts?.populate,\n  });\n\n  // TODO: Revert the creation if create permission conditions are not met\n  // if (permissionChecker.cannot.create(document)) {\n  //   throw new errors.ForbiddenError();\n  // }\n};\n\n/**\n * Update a document version.\n * - If the document version exists, it will be updated.\n * - If the document version does not exist, a new document locale will be created.\n *   By default documentManager will populate all relations.\n *\n * @param ctx - Koa context\n * @param opts - Options\n * @param opts.populate - Populate options of the returned document\n */\nconst updateDocument = async (ctx: any, opts?: Options) => {\n  const { userAbility, user } = ctx.state;\n  const { id, model } = ctx.params;\n  const { body } = ctx.request;\n\n  const documentManager = getService('document-manager');\n  const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n  if (permissionChecker.cannot.update()) {\n    throw new errors.ForbiddenError();\n  }\n\n  // Populate necessary fields to check permissions\n  const permissionQuery = await permissionChecker.sanitizedQuery.update(ctx.query);\n  const populate = await getService('populate-builder')(model)\n    .populateFromQuery(permissionQuery)\n    .build();\n\n  const { locale } = await getDocumentLocaleAndStatus(body, model);\n\n  // Load document version to update\n  const [documentVersion, documentExists] = await Promise.all([\n    documentManager.findOne(id, model, { populate, locale, status: 'draft' }),\n    documentManager.exists(model, id),\n  ]);\n\n  if (!documentExists) {\n    throw new errors.NotFoundError();\n  }\n\n  // If version is not found, but document exists,\n  // the intent is to create a new document locale\n  if (documentVersion) {\n    if (permissionChecker.cannot.update(documentVersion)) {\n      throw new errors.ForbiddenError();\n    }\n  } else if (permissionChecker.cannot.create()) {\n    throw new errors.ForbiddenError();\n  }\n\n  const pickPermittedFields = documentVersion\n    ? permissionChecker.sanitizeUpdateInput(documentVersion)\n    : permissionChecker.sanitizeCreateInput;\n  const setCreator = setCreatorFields({ user, isEdition: true });\n  const sanitizeFn = async.pipe(pickPermittedFields, setCreator as any);\n  const sanitizedBody = await sanitizeFn(body);\n\n  return documentManager.update(documentVersion?.documentId || id, model, {\n    data: sanitizedBody as any,\n    populate: opts?.populate,\n    locale,\n  });\n};\n\nexport default {\n  async find(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query } = ctx.request;\n\n    const documentMetadata = getService('document-metadata');\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(query);\n\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .populateDeep(1)\n      .countRelations({ toOne: false, toMany: true })\n      .build();\n\n    const { locale, status } = await getDocumentLocaleAndStatus(query, model);\n\n    const { results: documents, pagination } = await documentManager.findPage(\n      { ...permissionQuery, populate, locale, status },\n      model\n    );\n\n    // TODO: Skip this part if not necessary (if D&P disabled or columns not displayed in the view)\n    const documentsAvailableStatus = await documentMetadata.getManyAvailableStatus(\n      model,\n      documents\n    );\n\n    const setStatus = (document: any) => {\n      // Available status of document\n      const availableStatuses = documentsAvailableStatus.filter(\n        (d: any) => d.documentId === document.documentId\n      );\n      // Compute document version status\n      document.status = documentMetadata.getStatus(document, availableStatuses);\n      return document;\n    };\n\n    const results = await async.map(\n      documents,\n      async.pipe(permissionChecker.sanitizeOutput, setStatus)\n    );\n\n    ctx.body = {\n      results,\n      pagination,\n    };\n  },\n\n  async findOne(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model, id } = ctx.params;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .populateDeep(Infinity)\n      .countRelations()\n      .build();\n\n    const { locale, status } = await getDocumentLocaleAndStatus(ctx.query, model);\n\n    const version = await documentManager.findOne(id, model, {\n      populate,\n      locale,\n      status,\n    });\n\n    if (!version) {\n      // Check if document exists\n      const exists = await documentManager.exists(model, id);\n      if (!exists) {\n        return ctx.notFound();\n      }\n\n      // If the requested locale doesn't exist, return an empty response\n      const { meta } = await formatDocumentWithMetadata(\n        permissionChecker,\n        model,\n        // @ts-expect-error TODO: fix\n        { documentId: id, locale, publishedAt: null },\n        { availableLocales: true, availableStatus: false }\n      );\n\n      ctx.body = { data: {}, meta };\n\n      return;\n    }\n\n    // if the user has condition that needs populated content, it's not applied because entity don't have relations populated\n    if (permissionChecker.cannot.read(version)) {\n      return ctx.forbidden();\n    }\n\n    // TODO: Count populated relations by permissions\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(version);\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\n  },\n\n  async create(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    const [totalEntries, document] = await Promise.all([\n      strapi.db.query(model).count(),\n      createDocument(ctx),\n    ]);\n\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(document);\n    ctx.status = 201;\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument, {\n      // Empty metadata as it's not relevant for a new document\n      availableLocales: false,\n      availableStatus: false,\n    });\n\n    if (totalEntries === 0) {\n      strapi.telemetry.send('didCreateFirstContentTypeEntry', {\n        eventProperties: { model },\n      });\n    }\n  },\n\n  async update(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    const updatedVersion = await updateDocument(ctx);\n\n    const sanitizedVersion = await permissionChecker.sanitizeOutput(updatedVersion);\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedVersion);\n  },\n\n  async clone(ctx: any) {\n    const { userAbility, user } = ctx.state;\n    const { model, sourceId: id } = ctx.params;\n    const { body } = ctx.request;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.create()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.create(ctx.query);\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .build();\n\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\n    const document = await documentManager.findOne(id, model, {\n      populate,\n      locale,\n      status: 'draft',\n    });\n\n    if (!document) {\n      return ctx.notFound();\n    }\n\n    const pickPermittedFields = permissionChecker.sanitizeCreateInput;\n    const setCreator = setCreatorFields({ user });\n    const excludeNotCreatable = excludeNotCreatableFields(model, permissionChecker);\n    const sanitizeFn = async.pipe(pickPermittedFields, setCreator as any, excludeNotCreatable);\n    const sanitizedBody = await sanitizeFn(body);\n\n    const clonedDocument = await documentManager.clone(document.documentId, sanitizedBody, model);\n\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(clonedDocument);\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument, {\n      // Empty metadata as it's not relevant for a new document\n      availableLocales: false,\n      availableStatus: false,\n    });\n  },\n\n  async autoClone(ctx: any) {\n    const { model } = ctx.params;\n\n    // Check if the model has fields that prevent auto cloning\n    const prohibitedFields = getProhibitedCloningFields(model);\n\n    if (prohibitedFields.length > 0) {\n      return ctx.badRequest(\n        'Entity could not be cloned as it has unique and/or relational fields. ' +\n          'Please edit those fields manually and save to complete the cloning.',\n        {\n          prohibitedFields,\n        }\n      );\n    }\n\n    await this.clone(ctx);\n  },\n\n  async delete(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.delete(ctx.query);\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .build();\n\n    const { locale } = await getDocumentLocaleAndStatus(ctx.query, model);\n\n    // Find locales to delete\n    const documentLocales = await documentManager.findLocales(id, model, { populate, locale });\n\n    if (documentLocales.length === 0) {\n      return ctx.notFound();\n    }\n\n    for (const document of documentLocales) {\n      if (permissionChecker.cannot.delete(document)) {\n        return ctx.forbidden();\n      }\n    }\n\n    const result = await documentManager.delete(id, model, { locale });\n\n    ctx.body = await permissionChecker.sanitizeOutput(result);\n  },\n\n  /**\n   * Publish a document version.\n   * Supports creating/saving a document and publishing it in one request.\n   */\n  async publish(ctx: any) {\n    const { userAbility } = ctx.state;\n    // If id does not exist, the document has to be created\n    const { id, model } = ctx.params;\n    const { body } = ctx.request;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.publish()) {\n      return ctx.forbidden();\n    }\n\n    const publishedDocument = await strapi.db.transaction(async () => {\n      // Create or update document\n      const permissionQuery = await permissionChecker.sanitizedQuery.publish(ctx.query);\n      const populate = await getService('populate-builder')(model)\n        .populateFromQuery(permissionQuery)\n        .populateDeep(Infinity)\n        .countRelations()\n        .build();\n\n      let document: any;\n\n      const { locale } = await getDocumentLocaleAndStatus(body, model);\n\n      /**\n       * Publish can be called on two scenarios:\n       * 1. Create a new document and publish it in one request\n       * 2. Update an existing document and publish it in one request\n       *\n       * Based on user permissions:\n       * 1. User cannot create a document, but can publish\n       *    Action will be forbidden as user cannot create a document\n       * 2. User can update and publish a document\n       *    Action will be allowed, but document will not be updated, only published with the latest draft\n       */\n      const isCreate = isNil(id);\n      if (isCreate) {\n        if (permissionChecker.cannot.create()) {\n          throw new errors.ForbiddenError();\n        }\n\n        document = await createDocument(ctx, { populate });\n      }\n\n      const isUpdate = !isCreate;\n      if (isUpdate) {\n        document = await documentManager.findOne(id!, model, { populate, locale });\n\n        if (!document) {\n          throw new errors.NotFoundError('Document not found');\n        }\n\n        // Only Update if user has update permissions\n        if (permissionChecker.can.update(document)) {\n          await updateDocument(ctx);\n        }\n      }\n\n      if (permissionChecker.cannot.publish(document)) {\n        throw new errors.ForbiddenError();\n      }\n\n      const publishResult = await documentManager.publish(document.documentId, model, {\n        locale,\n        // TODO: Allow setting creator fields on publish\n        // data: setCreatorFields({ user, isEdition: true })({}),\n      });\n\n      if (!publishResult || publishResult.length === 0) {\n        throw new errors.NotFoundError('Document not found or already published.');\n      }\n\n      return publishResult[0];\n    });\n\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(publishedDocument);\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\n  },\n\n  async bulkPublish(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { body } = ctx.request;\n    const { documentIds } = body;\n\n    await validateBulkActionInput(body);\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.publish()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.publish(ctx.query);\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .populateDeep(Infinity)\n      .countRelations()\n      .build();\n\n    const { locale } = await getDocumentLocaleAndStatus(body, model, {\n      allowMultipleLocales: true,\n    });\n\n    const entityPromises = documentIds.map((documentId: any) =>\n      documentManager.findLocales(documentId, model, { populate, locale, isPublished: false })\n    );\n    const entities = (await Promise.all(entityPromises)).flat();\n\n    for (const entity of entities) {\n      if (!entity) {\n        return ctx.notFound();\n      }\n\n      if (permissionChecker.cannot.publish(entity)) {\n        return ctx.forbidden();\n      }\n    }\n\n    const count = await documentManager.publishMany(model, documentIds, locale);\n    ctx.body = { count };\n  },\n\n  async bulkUnpublish(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { body } = ctx.request;\n    const { documentIds } = body;\n\n    await validateBulkActionInput(body);\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.unpublish()) {\n      return ctx.forbidden();\n    }\n\n    const { locale } = await getDocumentLocaleAndStatus(body, model, {\n      allowMultipleLocales: true,\n    });\n\n    const entityPromises = documentIds.map((documentId: any) =>\n      documentManager.findLocales(documentId, model, { locale, isPublished: true })\n    );\n    const entities = (await Promise.all(entityPromises)).flat();\n\n    for (const entity of entities) {\n      if (!entity) {\n        return ctx.notFound();\n      }\n\n      if (permissionChecker.cannot.publish(entity)) {\n        return ctx.forbidden();\n      }\n    }\n\n    const entitiesIds = entities.map((document) => document.documentId);\n\n    const { count } = await documentManager.unpublishMany(entitiesIds, model, { locale });\n\n    ctx.body = { count };\n  },\n\n  async unpublish(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n    const {\n      body: { discardDraft, ...body },\n    } = ctx.request;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.unpublish()) {\n      return ctx.forbidden();\n    }\n\n    if (discardDraft && permissionChecker.cannot.discard()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.unpublish(ctx.query);\n\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .build();\n\n    // TODO allow multiple locales for bulk locale unpublish\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\n    const document = await documentManager.findOne(id, model, {\n      populate,\n      locale,\n      status: 'published',\n    });\n\n    if (!document) {\n      throw new errors.NotFoundError();\n    }\n\n    if (permissionChecker.cannot.unpublish(document)) {\n      throw new errors.ForbiddenError();\n    }\n\n    if (discardDraft && permissionChecker.cannot.discard(document)) {\n      throw new errors.ForbiddenError();\n    }\n\n    await strapi.db.transaction(async () => {\n      if (discardDraft) {\n        await documentManager.discardDraft(document.documentId, model, { locale });\n      }\n\n      ctx.body = await async.pipe(\n        (document) => documentManager.unpublish(document.documentId, model, { locale }),\n        permissionChecker.sanitizeOutput,\n        (document) => formatDocumentWithMetadata(permissionChecker, model, document)\n      )(document);\n    });\n  },\n\n  async discard(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n    const { body } = ctx.request;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.discard()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.discard(ctx.query);\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .build();\n\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\n    const document = await documentManager.findOne(id, model, {\n      populate,\n      locale,\n      status: 'published',\n    });\n\n    // Can not discard a document that is not published\n    if (!document) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.discard(document)) {\n      return ctx.forbidden();\n    }\n\n    ctx.body = await async.pipe(\n      (document) => documentManager.discardDraft(document.documentId, model, { locale }),\n      permissionChecker.sanitizeOutput,\n      (document) => formatDocumentWithMetadata(permissionChecker, model, document)\n    )(document);\n  },\n\n  async bulkDelete(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query, body } = ctx.request;\n    const { documentIds } = body;\n\n    await validateBulkActionInput(body);\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.delete(query);\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .build();\n\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\n\n    const documentLocales = await documentManager.findLocales(documentIds, model, {\n      populate,\n      locale,\n    });\n\n    if (documentLocales.length === 0) {\n      return ctx.notFound();\n    }\n\n    for (const document of documentLocales) {\n      if (permissionChecker.cannot.delete(document)) {\n        return ctx.forbidden();\n      }\n    }\n\n    // We filter out documentsIds that maybe doesn't exist in a specific locale\n    const localeDocumentsIds = documentLocales.map((document) => document.documentId);\n\n    const { count } = await documentManager.deleteMany(localeDocumentsIds, model, { locale });\n\n    ctx.body = { count };\n  },\n\n  async countDraftRelations(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model, id } = ctx.params;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);\n    const populate = await getService('populate-builder')(model)\n      .populateFromQuery(permissionQuery)\n      .build();\n\n    const { locale, status } = await getDocumentLocaleAndStatus(ctx.query, model);\n    const entity = await documentManager.findOne(id, model, { populate, locale, status });\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.read(entity)) {\n      return ctx.forbidden();\n    }\n\n    const number = await documentManager.countDraftRelations(id, model, locale);\n\n    return {\n      data: number,\n    };\n  },\n\n  async countManyEntriesDraftRelations(ctx: any) {\n    const { userAbility } = ctx.state;\n    const ids = ctx.request.query.documentIds as string[];\n    const locale = ctx.request.query.locale as string[];\n    const { model } = ctx.params;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const documents = await documentManager.findMany(\n      {\n        filters: {\n          documentId: ids,\n        },\n        locale,\n      },\n      model\n    );\n\n    if (!documents) {\n      return ctx.notFound();\n    }\n\n    const number = await documentManager.countManyEntriesDraftRelations(ids, model, locale);\n\n    return {\n      data: number,\n    };\n  },\n};\n","import { getService } from '../utils';\nimport { createModelConfigurationSchema } from './validation';\n\nexport default {\n  findComponents(ctx: any) {\n    const components = getService('components').findAllComponents();\n    const { toDto } = getService('data-mapper');\n\n    ctx.body = { data: components.map(toDto) };\n  },\n\n  async findComponentConfiguration(ctx: any) {\n    const { uid } = ctx.params;\n\n    const componentService = getService('components');\n\n    const component = componentService.findComponent(uid);\n\n    if (!component) {\n      return ctx.notFound('component.notFound');\n    }\n\n    const configuration = await componentService.findConfiguration(component);\n    const componentsConfigurations = await componentService.findComponentsConfigurations(component);\n\n    ctx.body = {\n      data: {\n        component: configuration,\n        components: componentsConfigurations,\n      },\n    };\n  },\n\n  async updateComponentConfiguration(ctx: any) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    const componentService = getService('components');\n\n    const component = componentService.findComponent(uid);\n\n    if (!component) {\n      return ctx.notFound('component.notFound');\n    }\n\n    let input;\n    try {\n      input = await createModelConfigurationSchema(component).validate(body, {\n        abortEarly: false,\n        stripUnknown: true,\n        strict: true,\n      });\n    } catch (error: any) {\n      return ctx.badRequest(null, {\n        name: 'validationError',\n        errors: error.errors,\n      });\n    }\n\n    const newConfiguration = await componentService.updateConfiguration(component, input);\n\n    ctx.body = { data: newConfiguration };\n  },\n};\n","import { has, assoc, mapValues, prop } from 'lodash/fp';\nimport { getService } from '../utils';\nimport { createModelConfigurationSchema, validateKind } from './validation';\n\nconst hasEditMainField = has('edit.mainField');\nconst getEditMainField = prop('edit.mainField');\nconst assocListMainField = assoc('list.mainField');\n\nconst assocMainField = (metadata: any) =>\n  hasEditMainField(metadata) ? assocListMainField(getEditMainField(metadata), metadata) : metadata;\n\nexport default {\n  async findContentTypes(ctx: any) {\n    const { kind } = ctx.query;\n\n    try {\n      await validateKind(kind);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const contentTypes = getService('content-types').findContentTypesByKind(kind);\n    const { toDto } = getService('data-mapper');\n\n    ctx.body = { data: contentTypes.map(toDto) };\n  },\n\n  async findContentTypesSettings(ctx: any) {\n    const { findAllContentTypes, findConfiguration } = getService('content-types');\n\n    const contentTypes = await findAllContentTypes();\n    const configurations = await Promise.all(\n      contentTypes.map(async (contentType: any) => {\n        const { uid, settings } = await findConfiguration(contentType);\n        return { uid, settings };\n      })\n    );\n\n    ctx.body = {\n      data: configurations,\n    };\n  },\n\n  async findContentTypeConfiguration(ctx: any) {\n    const { uid } = ctx.params;\n\n    const contentTypeService = getService('content-types');\n\n    const contentType = await contentTypeService.findContentType(uid);\n\n    if (!contentType) {\n      return ctx.notFound('contentType.notFound');\n    }\n\n    const configuration = await contentTypeService.findConfiguration(contentType);\n\n    const confWithUpdatedMetadata = {\n      ...configuration,\n      metadatas: mapValues(assocMainField, configuration.metadatas),\n    };\n\n    const components = await contentTypeService.findComponentsConfigurations(contentType);\n\n    ctx.body = {\n      data: {\n        contentType: confWithUpdatedMetadata,\n        components,\n      },\n    };\n  },\n\n  async updateContentTypeConfiguration(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    const contentTypeService = getService('content-types');\n    const metricsService = getService('metrics');\n\n    const contentType = await contentTypeService.findContentType(uid);\n\n    if (!contentType) {\n      return ctx.notFound('contentType.notFound');\n    }\n\n    if (!getService('permission').canConfigureContentType({ userAbility, contentType })) {\n      return ctx.forbidden();\n    }\n\n    let input;\n    try {\n      input = await createModelConfigurationSchema(contentType).validate(body, {\n        abortEarly: false,\n        stripUnknown: true,\n        strict: true,\n      });\n    } catch (error: any) {\n      return ctx.badRequest(null, {\n        name: 'validationError',\n        errors: error.errors,\n      });\n    }\n\n    const newConfiguration = await contentTypeService.updateConfiguration(contentType, input);\n\n    await metricsService.sendDidConfigureListView(contentType, newConfiguration);\n\n    const confWithUpdatedMetadata = {\n      ...newConfiguration,\n      metadatas: mapValues(assocMainField, newConfiguration.metadatas),\n    };\n\n    const components = await contentTypeService.findComponentsConfigurations(contentType);\n\n    ctx.body = {\n      data: {\n        contentType: confWithUpdatedMetadata,\n        components,\n      },\n    };\n  },\n};\n","import { getService } from '../utils';\n\nexport default {\n  getInitData(ctx: any) {\n    const { toDto } = getService('data-mapper');\n    const { findAllComponents } = getService('components');\n    const { getAllFieldSizes } = getService('field-sizes');\n    const { findAllContentTypes } = getService('content-types');\n\n    ctx.body = {\n      data: {\n        fieldSizes: getAllFieldSizes(),\n        components: findAllComponents().map(toDto),\n        contentTypes: findAllContentTypes().map(toDto),\n      },\n    };\n  },\n};\n","import { yup, validateYupSchema } from '@strapi/utils';\n\nconst validateFindAvailableSchema = yup\n  .object()\n  .shape({\n    component: yup.string(),\n    id: yup.strapiID(),\n    _q: yup.string(),\n    idsToOmit: yup.array().of(yup.strapiID()),\n    idsToInclude: yup.array().of(yup.strapiID()),\n    page: yup.number().integer().min(1),\n    pageSize: yup.number().integer().min(1).max(100),\n    locale: yup.string().nullable(),\n    status: yup.string().oneOf(['published', 'draft']).nullable(),\n  })\n  .required();\n\nconst validateFindExistingSchema = yup\n  .object()\n  .shape({\n    page: yup.number().integer().min(1),\n    pageSize: yup.number().integer().min(1).max(100),\n    locale: yup.string().nullable(),\n    status: yup.string().oneOf(['published', 'draft']).nullable(),\n  })\n  .required();\n\nconst validateFindAvailable = validateYupSchema(validateFindAvailableSchema, { strict: false });\nconst validateFindExisting = validateYupSchema(validateFindExistingSchema, { strict: false });\n\nexport { validateFindAvailable, validateFindExisting };\n","import { prop, uniq, uniqBy, concat, flow } from 'lodash/fp';\n\nimport { isOperatorOfType, contentTypes, relations, errors } from '@strapi/utils';\nimport type { Data, Modules, UID } from '@strapi/types';\n\nimport { getService } from '../utils';\nimport { validateFindAvailable, validateFindExisting } from './validation/relations';\nimport { isListable } from '../services/utils/configuration/attributes';\n\nconst { PUBLISHED_AT_ATTRIBUTE, UPDATED_AT_ATTRIBUTE } = contentTypes.constants;\n\ninterface RelationEntity {\n  id: Data.ID;\n  documentId: Modules.Documents.ID;\n  updatedAt: string | Date;\n  publishedAt?: string | Date;\n  [key: string]: unknown;\n}\n\nconst addFiltersClause = (params: any, filtersClause: any) => {\n  params.filters = params.filters || {};\n  params.filters.$and = params.filters.$and || [];\n  params.filters.$and.push(filtersClause);\n};\n\nconst sanitizeMainField = (model: any, mainField: any, userAbility: any) => {\n  const permissionChecker = getService('permission-checker').create({\n    userAbility,\n    model: model.uid,\n  });\n\n  // Whether the main field can be displayed or not, regardless of permissions.\n  const isMainFieldListable = isListable(model, mainField);\n  // Whether the user has the permission to access the model's main field (using RBAC abilities)\n  const canReadMainField = permissionChecker.can.read(null, mainField);\n\n  if (!isMainFieldListable || !canReadMainField) {\n    // Default to 'id' if the actual main field shouldn't be displayed\n    return 'id';\n  }\n\n  // Edge cases\n\n  // 1. Enforce 'name' as the main field for users and permissions' roles\n  if (model.uid === 'plugin::users-permissions.role') {\n    return 'name';\n  }\n\n  return mainField;\n};\n\nconst addStatusToRelations = async (uid: UID.ContentType, relations: RelationEntity[]) => {\n  if (!contentTypes.hasDraftAndPublish(strapi.contentTypes[uid])) {\n    return relations;\n  }\n\n  const documentMetadata = getService('document-metadata');\n  const documentsAvailableStatus = await documentMetadata.getManyAvailableStatus(uid, relations);\n\n  return relations.map((relation: RelationEntity) => {\n    const availableStatuses = documentsAvailableStatus.filter(\n      (availableDocument: RelationEntity) => availableDocument.documentId === relation.documentId\n    );\n\n    return {\n      ...relation,\n      status: documentMetadata.getStatus(relation, availableStatuses),\n    };\n  });\n};\n\nconst getPublishedAtClause = (status: string, uid: UID.Schema) => {\n  const model = strapi.getModel(uid);\n\n  /**\n   * If dp is disabled, ignore the filter\n   */\n  if (!model || !contentTypes.hasDraftAndPublish(model)) {\n    return {};\n  }\n\n  // Prioritize the draft status in case it's not provided\n  return status === 'published' ? { $notNull: true } : { $null: true };\n};\n\nconst validateLocale = (sourceUid: UID.Schema, targetUid: UID.ContentType, locale?: string) => {\n  const sourceModel = strapi.getModel(sourceUid);\n  const targetModel = strapi.getModel(targetUid);\n\n  const isLocalized = strapi.plugin('i18n').service('content-types').isLocalizedContentType;\n  const isSourceLocalized = isLocalized(sourceModel);\n  const isTargetLocalized = isLocalized(targetModel);\n\n  let validatedLocale = locale;\n\n  if (!targetModel || !isTargetLocalized) validatedLocale = undefined;\n\n  return {\n    locale: validatedLocale,\n    isSourceLocalized,\n    isTargetLocalized,\n  };\n};\n\nconst validateStatus = (\n  sourceUid: UID.Schema,\n  status?: Modules.Documents.Params.PublicationStatus.Kind\n) => {\n  const sourceModel = strapi.getModel(sourceUid);\n\n  const isDP = contentTypes.hasDraftAndPublish;\n  const isSourceDP = isDP(sourceModel);\n\n  // Default to draft if not set\n  if (!isSourceDP) return { status: undefined };\n\n  switch (status) {\n    case 'published':\n      return { status: 'published' };\n    default:\n      // Assign to draft if the status is not valid\n      return { status: 'draft' };\n  }\n};\n\nexport default {\n  async extractAndValidateRequestInfo(ctx: any, id?: Data.ID) {\n    const { userAbility } = ctx.state;\n    const { model, targetField } = ctx.params;\n\n    const sourceSchema = strapi.getModel(model);\n    if (!sourceSchema) {\n      throw new errors.ValidationError(`The model ${model} doesn't exist`);\n    }\n\n    const attribute: any = sourceSchema.attributes[targetField];\n    if (!attribute || attribute.type !== 'relation') {\n      throw new errors.ValidationError(\n        `The relational field ${targetField} doesn't exist on ${model}`\n      );\n    }\n\n    const sourceUid = model;\n    const targetUid = attribute.target;\n\n    const { locale, isSourceLocalized, isTargetLocalized } = validateLocale(\n      sourceUid,\n      targetUid,\n      ctx.request?.query?.locale\n    );\n    const { status } = validateStatus(sourceUid, ctx.request?.query?.status);\n\n    const permissionChecker = getService('permission-checker').create({\n      userAbility,\n      model,\n    });\n\n    const isComponent = sourceSchema.modelType === 'component';\n    if (!isComponent) {\n      if (permissionChecker.cannot.read(null, targetField)) {\n        return ctx.forbidden();\n      }\n    }\n\n    let entryId: string | number | null = null;\n\n    if (id) {\n      const where: Record<string, any> = {};\n\n      if (!isComponent) {\n        where.documentId = id;\n\n        if (status) {\n          where.publishedAt = getPublishedAtClause(status, sourceUid);\n        }\n\n        if (locale && isSourceLocalized) {\n          where.locale = locale;\n        }\n      } else {\n        // If the source is a component, we only need to filter by the\n        // component's entity id\n        where.id = id;\n      }\n\n      const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);\n      const populate = await getService('populate-builder')(model)\n        .populateFromQuery(permissionQuery)\n        .build();\n\n      const currentEntity = await strapi.db.query(model).findOne({\n        where,\n        populate,\n      });\n\n      // We need to check if the entity exists\n      // and if the user has the permission to read it in this way\n      // There may be multiple entities (publication states) under this\n      // documentId + locale. We only need to check if one exists\n      if (!currentEntity) {\n        throw new errors.NotFoundError();\n      }\n\n      if (!isComponent) {\n        if (permissionChecker.cannot.read(currentEntity, targetField)) {\n          throw new errors.ForbiddenError();\n        }\n      }\n\n      entryId = currentEntity.id;\n    }\n\n    const modelConfig = isComponent\n      ? await getService('components').findConfiguration(sourceSchema)\n      : await getService('content-types').findConfiguration(sourceSchema);\n\n    const targetSchema = strapi.getModel(targetUid);\n\n    const mainField = flow(\n      prop(`metadatas.${targetField}.edit.mainField`),\n      (mainField) => mainField || 'id',\n      (mainField) => sanitizeMainField(targetSchema, mainField, userAbility)\n    )(modelConfig);\n\n    const fieldsToSelect = uniq([\n      mainField,\n      PUBLISHED_AT_ATTRIBUTE,\n      UPDATED_AT_ATTRIBUTE,\n      'documentId',\n    ]);\n\n    if (isTargetLocalized) {\n      fieldsToSelect.push('locale');\n    }\n\n    return {\n      entryId,\n      locale,\n      status,\n      attribute,\n      fieldsToSelect,\n      mainField,\n      source: { schema: sourceSchema },\n      target: { schema: targetSchema, isLocalized: isTargetLocalized },\n      sourceSchema,\n      targetSchema,\n      targetField,\n    };\n  },\n\n  /**\n   * Used to find new relations to add in a relational field.\n   *\n   * Component and document relations are dealt a bit differently (they don't have a document_id).\n   */\n  async findAvailable(ctx: any) {\n    const { id } = ctx.request.query;\n\n    await validateFindAvailable(ctx.request.query);\n\n    const {\n      locale,\n      status,\n      targetField,\n      fieldsToSelect,\n      mainField,\n      source: {\n        schema: { uid: sourceUid, modelType: sourceModelType },\n      },\n      target: {\n        schema: { uid: targetUid },\n        isLocalized: isTargetLocalized,\n      },\n    } = await this.extractAndValidateRequestInfo(ctx, id);\n\n    const { idsToOmit, idsToInclude, _q, ...query } = ctx.request.query;\n\n    const permissionChecker = getService('permission-checker').create({\n      userAbility: ctx.state.userAbility,\n      model: targetUid,\n    });\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(query);\n\n    const queryParams = {\n      sort: mainField,\n      // cannot select other fields as the user may not have the permissions\n      fields: fieldsToSelect,\n      ...permissionQuery,\n    };\n\n    // If no status is requested, we find all the draft relations and later update them\n    // with the latest available status\n    addFiltersClause(queryParams, {\n      publishedAt: getPublishedAtClause(status, targetUid),\n    });\n\n    // We will only filter by locale if the target content type is localized\n    const filterByLocale = isTargetLocalized && locale;\n    if (filterByLocale) {\n      addFiltersClause(queryParams, { locale });\n    }\n\n    if (id) {\n      /**\n       * Exclude the relations that are already related to the source\n       *\n       * We also optionally filter the target relations by the requested\n       * status and locale if provided.\n       */\n      const subQuery = strapi.db.queryBuilder(sourceUid);\n\n      // The alias refers to the DB table of the target content type model\n      const alias = subQuery.getAlias();\n\n      const where: Record<string, any> = {\n        [`${alias}.id`]: { $notNull: true },\n        [`${alias}.document_id`]: { $notNull: true },\n      };\n\n      /**\n       * Content Types -> Specify document id\n       * Components    -> Specify entity id (they don't have a document id)\n       */\n      if (sourceModelType === 'contentType') {\n        where.document_id = id;\n      } else {\n        where.id = id;\n      }\n\n      // Add the status and locale filters if they are provided\n      if (status) {\n        where[`${alias}.published_at`] = getPublishedAtClause(status, targetUid);\n      }\n      if (filterByLocale) {\n        where[`${alias}.locale`] = locale;\n      }\n\n      /**\n       * UI can provide a list of ids to omit,\n       * those are the relations user set in the UI but has not persisted.\n       * We don't want to include them in the available relations.\n       */\n      if ((idsToInclude?.length ?? 0) !== 0) {\n        where[`${alias}.id`].$notIn = idsToInclude;\n      }\n\n      const knexSubQuery = subQuery\n        .where(where)\n        .join({ alias, targetField })\n        .select(`${alias}.id`)\n        .getKnexQuery();\n\n      addFiltersClause(queryParams, {\n        id: { $notIn: knexSubQuery },\n      });\n    }\n\n    /**\n     * Apply a filter to the mainField based on the search query and filter operator\n     * searching should be allowed only on mainField for permission reasons\n     */\n    if (_q) {\n      const _filter = isOperatorOfType('where', query._filter) ? query._filter : '$containsi';\n      addFiltersClause(queryParams, { [mainField]: { [_filter]: _q } });\n    }\n\n    if (idsToOmit?.length > 0) {\n      // If we have ids to omit, we should filter them out\n      addFiltersClause(queryParams, {\n        id: { $notIn: uniq(idsToOmit) },\n      });\n    }\n\n    const res = await strapi.db\n      .query(targetUid)\n      .findPage(strapi.get('query-params').transform(targetUid, queryParams));\n\n    ctx.body = {\n      ...res,\n      results: await addStatusToRelations(targetUid, res.results),\n    };\n  },\n\n  async findExisting(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { id } = ctx.params;\n\n    await validateFindExisting(ctx.request.query);\n\n    const {\n      entryId,\n      attribute,\n      targetField,\n      fieldsToSelect,\n      source: {\n        schema: { uid: sourceUid },\n      },\n      target: {\n        schema: { uid: targetUid },\n      },\n    } = await this.extractAndValidateRequestInfo(ctx, id);\n\n    const permissionQuery = await getService('permission-checker')\n      .create({ userAbility, model: targetUid })\n      .sanitizedQuery.read({ fields: fieldsToSelect });\n\n    /**\n     * loadPages can not be used for single relations,\n     * this unifies the loading regardless of it's type\n     *\n     * NOTE: Relations need to be loaded using any db.query method\n     *       to ensure the proper ordering is applied\n     */\n    const dbQuery = strapi.db.query(sourceUid);\n    const loadRelations = relations.isAnyToMany(attribute)\n      ? (...args: Parameters<typeof dbQuery.loadPages>) => dbQuery.loadPages(...args)\n      : (...args: Parameters<typeof dbQuery.load>) =>\n          dbQuery\n            .load(...args)\n            // Ensure response is an array\n            .then((res) => ({ results: res ? [res] : [] }));\n\n    /**\n     * If user does not have access to specific relations (custom conditions),\n     * only the ids of the relations are returned.\n     *\n     * - First query loads all the ids.\n     * - Second one also loads the main field, and excludes forbidden relations.\n     *\n     * The response contains the union of the two queries.\n     */\n    const res = await loadRelations({ id: entryId }, targetField, {\n      select: ['id', 'documentId', 'locale', 'publishedAt'],\n      ordering: 'desc',\n      page: ctx.request.query.page,\n      pageSize: ctx.request.query.pageSize,\n    });\n\n    /**\n     * Add all ids to load in permissionQuery\n     * If any of the relations are not accessible, the permissionQuery will exclude them\n     */\n    const loadedIds = res.results.map((item: any) => item.id);\n    addFiltersClause(permissionQuery, { id: { $in: loadedIds } });\n\n    /**\n     * Load the relations with the main field, the sanitized permission query\n     * will exclude the relations the user does not have access to.\n     *\n     * Pagination is not necessary as the permissionQuery contains the ids to load.\n     */\n    const sanitizedRes = await loadRelations({ id: entryId }, targetField, {\n      ...strapi.get('query-params').transform(targetUid, permissionQuery),\n      ordering: 'desc',\n    });\n\n    const relationsUnion = uniqBy('id', concat(sanitizedRes.results, res.results));\n\n    ctx.body = {\n      pagination: res.pagination || {\n        page: 1,\n        pageCount: 1,\n        pageSize: 10,\n        total: relationsUnion.length,\n      },\n      results: await addStatusToRelations(targetUid, relationsUnion),\n    };\n  },\n};\n","import type { UID, Modules } from '@strapi/types';\nimport { setCreatorFields, async, errors } from '@strapi/utils';\n\nimport { getDocumentLocaleAndStatus } from './validation/dimensions';\nimport { getService } from '../utils';\nimport { formatDocumentWithMetadata } from './utils/metadata';\n\ntype OptionsWithPopulate = Modules.Documents.Params.Pick<UID.ContentType, 'populate:object'>;\n\nconst buildPopulateFromQuery = async (query: any, model: any) => {\n  return getService('populate-builder')(model)\n    .populateFromQuery(query)\n    .populateDeep(Infinity)\n    .countRelations()\n    .build();\n};\n\nconst findDocument = async (query: any, uid: UID.SingleType, opts: any = {}) => {\n  const documentManager = getService('document-manager');\n  const populate = await buildPopulateFromQuery(query, uid);\n\n  return (\n    documentManager\n      .findMany({ ...opts, populate }, uid)\n      // Return the first document found\n      .then((documents: any) => documents[0])\n  );\n};\n\nconst createOrUpdateDocument = async (ctx: any, opts?: OptionsWithPopulate) => {\n  const { user, userAbility } = ctx.state;\n  const { model } = ctx.params;\n  const { body, query } = ctx.request;\n\n  const documentManager = getService('document-manager');\n  const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n  if (permissionChecker.cannot.create() && permissionChecker.cannot.update()) {\n    throw new errors.ForbiddenError();\n  }\n\n  const sanitizedQuery = await permissionChecker.sanitizedQuery.update(query);\n\n  const { locale } = await getDocumentLocaleAndStatus(body, model);\n\n  // Load document version to update\n  const [documentVersion, otherDocumentVersion] = await Promise.all([\n    findDocument(sanitizedQuery, model, { locale, status: 'draft' }),\n    // Find the first document to check if it exists\n    strapi.db.query(model).findOne({ select: ['documentId'] }),\n  ]);\n\n  const documentId = otherDocumentVersion?.documentId;\n\n  const pickPermittedFields = documentVersion\n    ? permissionChecker.sanitizeUpdateInput(documentVersion)\n    : permissionChecker.sanitizeCreateInput;\n\n  const setCreator = documentVersion\n    ? setCreatorFields({ user, isEdition: true })\n    : setCreatorFields({ user });\n\n  const sanitizeFn = async.pipe(pickPermittedFields, setCreator as any);\n\n  // If version is not found, but document exists,\n  // the intent is to create a new document locale\n  if (documentVersion) {\n    if (permissionChecker.cannot.update(documentVersion)) {\n      throw new errors.ForbiddenError();\n    }\n  } else if (permissionChecker.cannot.create()) {\n    throw new errors.ForbiddenError();\n  }\n\n  const sanitizedBody = await sanitizeFn(body);\n\n  if (!documentId) {\n    return documentManager.create(model, {\n      data: sanitizedBody,\n      ...sanitizedQuery,\n      locale,\n    });\n  }\n\n  return documentManager.update(documentId, model, {\n    data: sanitizedBody as any,\n    populate: opts?.populate,\n    locale,\n  });\n};\n\nexport default {\n  async find(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query = {} } = ctx.request;\n\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(query);\n    const { locale, status } = await getDocumentLocaleAndStatus(query, model);\n\n    const version = await findDocument(permissionQuery, model, { locale, status });\n\n    // allow user with create permission to know a single type is not created\n    if (!version) {\n      if (permissionChecker.cannot.create()) {\n        return ctx.forbidden();\n      }\n      // Check if document exists\n      const document = await strapi.db.query(model).findOne({});\n\n      if (!document) {\n        return ctx.notFound();\n      }\n\n      // If the requested locale doesn't exist, return an empty response\n      const { meta } = await formatDocumentWithMetadata(\n        permissionChecker,\n        model,\n        // @ts-expect-error - fix types\n        { id: document.documentId, locale, publishedAt: null },\n        { availableLocales: true, availableStatus: false }\n      );\n      ctx.body = { data: {}, meta };\n      return;\n    }\n\n    if (permissionChecker.cannot.read(version)) {\n      return ctx.forbidden();\n    }\n\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(version);\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\n  },\n\n  async createOrUpdate(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    const document = await createOrUpdateDocument(ctx);\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(document);\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\n  },\n\n  async delete(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query = {} } = ctx.request;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const sanitizedQuery = await permissionChecker.sanitizedQuery.delete(query);\n    const populate = await buildPopulateFromQuery(sanitizedQuery, model);\n\n    const { locale } = await getDocumentLocaleAndStatus(query, model);\n    const documentLocales = await documentManager.findLocales(undefined, model, {\n      populate,\n      locale,\n    });\n\n    if (documentLocales.length === 0) {\n      return ctx.notFound();\n    }\n\n    for (const document of documentLocales) {\n      if (permissionChecker.cannot.delete(document)) {\n        return ctx.forbidden();\n      }\n    }\n\n    const deletedEntity = await documentManager.delete(documentLocales.at(0).documentId, model, {\n      locale,\n    });\n\n    ctx.body = await permissionChecker.sanitizeOutput(deletedEntity);\n  },\n\n  async publish(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query = {} } = ctx.request;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.publish()) {\n      return ctx.forbidden();\n    }\n\n    const publishedDocument = await strapi.db.transaction(async () => {\n      const sanitizedQuery = await permissionChecker.sanitizedQuery.publish(query);\n      const populate = await buildPopulateFromQuery(sanitizedQuery, model);\n      const document = await createOrUpdateDocument(ctx, { populate });\n\n      if (!document) {\n        throw new errors.NotFoundError();\n      }\n\n      if (permissionChecker.cannot.publish(document)) {\n        throw new errors.ForbiddenError();\n      }\n\n      const { locale } = await getDocumentLocaleAndStatus(document, model);\n      const publishResult = await documentManager.publish(document.documentId, model, { locale });\n\n      return publishResult.at(0);\n    });\n\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(publishedDocument);\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\n  },\n\n  async unpublish(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const {\n      body: { discardDraft, ...body },\n      query = {},\n    } = ctx.request;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.unpublish()) {\n      return ctx.forbidden();\n    }\n\n    if (discardDraft && permissionChecker.cannot.discard()) {\n      return ctx.forbidden();\n    }\n\n    const sanitizedQuery = await permissionChecker.sanitizedQuery.unpublish(query);\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\n\n    const document = await findDocument(sanitizedQuery, model, { locale });\n\n    if (!document) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.unpublish(document)) {\n      return ctx.forbidden();\n    }\n\n    if (discardDraft && permissionChecker.cannot.discard(document)) {\n      return ctx.forbidden();\n    }\n\n    await strapi.db.transaction(async () => {\n      if (discardDraft) {\n        await documentManager.discardDraft(document.documentId, model, { locale });\n      }\n\n      ctx.body = await async.pipe(\n        (document) => documentManager.unpublish(document.documentId, model, { locale }),\n        permissionChecker.sanitizeOutput,\n        (document) => formatDocumentWithMetadata(permissionChecker, model, document)\n      )(document);\n    });\n  },\n\n  async discard(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { body, query = {} } = ctx.request;\n\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.discard()) {\n      return ctx.forbidden();\n    }\n\n    const sanitizedQuery = await permissionChecker.sanitizedQuery.discard(query);\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\n\n    const document = await findDocument(sanitizedQuery, model, { locale, status: 'published' });\n\n    // Can not discard a document that is not published\n    if (!document) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.discard(document)) {\n      return ctx.forbidden();\n    }\n\n    ctx.body = await async.pipe(\n      (document) => documentManager.discardDraft(document.documentId, model, { locale }),\n      permissionChecker.sanitizeOutput,\n      (document) => formatDocumentWithMetadata(permissionChecker, model, document)\n    )(document);\n  },\n\n  async countDraftRelations(ctx: any) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query } = ctx.request;\n    const documentManager = getService('document-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    const { locale } = await getDocumentLocaleAndStatus(query, model);\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const document = await findDocument({}, model);\n    if (!document) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.read(document)) {\n      return ctx.forbidden();\n    }\n\n    const number = await documentManager.countDraftRelations(document.documentId, model, locale);\n\n    return {\n      data: number,\n    };\n  },\n};\n","import type { UID } from '@strapi/types';\nimport { getService } from '../utils';\nimport { getDocumentLocaleAndStatus } from './validation/dimensions';\n\nimport {\n  validateGenerateUIDInput,\n  validateCheckUIDAvailabilityInput,\n  validateUIDField,\n} from './validation';\n\nexport default {\n  async generateUID(ctx: any) {\n    const { contentTypeUID, field, data } = await validateGenerateUIDInput(ctx.request.body);\n\n    const { query = {} } = ctx.request;\n    const { locale } = await getDocumentLocaleAndStatus(query, contentTypeUID as UID.Schema);\n\n    await validateUIDField(contentTypeUID, field);\n\n    const uidService = getService('uid');\n\n    ctx.body = {\n      data: await uidService.generateUIDField({ contentTypeUID, field, data, locale }),\n    };\n  },\n\n  async checkUIDAvailability(ctx: any) {\n    const { contentTypeUID, field, value } = await validateCheckUIDAvailabilityInput(\n      ctx.request.body\n    );\n\n    const { query = {} } = ctx.request;\n    const { locale } = await getDocumentLocaleAndStatus(query, contentTypeUID as UID.Schema);\n\n    await validateUIDField(contentTypeUID, field);\n\n    const uidService = getService('uid');\n\n    const isAvailable = await uidService.checkUIDAvailability({\n      contentTypeUID,\n      field,\n      value,\n      locale,\n    });\n\n    ctx.body = {\n      isAvailable,\n      suggestion: !isAvailable\n        ? await uidService.findUniqueUID({ contentTypeUID, field, value, locale })\n        : null,\n    };\n  },\n};\n","import collectionTypes from './collection-types';\nimport components from './components';\nimport contentTypes from './content-types';\nimport init from './init';\nimport relations from './relations';\nimport singleTypes from './single-types';\nimport uid from './uid';\nimport history from '../history';\n\nexport default {\n  'collection-types': collectionTypes,\n  components,\n  'content-types': contentTypes,\n  init,\n  relations,\n  'single-types': singleTypes,\n  uid,\n  ...(history.controllers ? history.controllers : {}),\n};\n","import _ from 'lodash';\n\nconst keys = {\n  CONFIGURATION: 'configuration',\n};\n\nconst getStore = () => strapi.store({ type: 'plugin', name: 'content_manager' });\n\n/** Model configuration */\nconst EMPTY_CONFIG = {\n  settings: {},\n  metadatas: {},\n  layouts: {},\n};\n\nconst configurationKey = (key: any) => `${keys.CONFIGURATION}_${key}`;\n\nconst getModelConfiguration = async (key: any) => {\n  const config = await getStore().get({ key: configurationKey(key) });\n  return _.merge({}, EMPTY_CONFIG, config);\n};\n\nconst setModelConfiguration = async (key: string, value: any) => {\n  const storedConfig = (await getStore().get({ key: configurationKey(key) })) || {};\n  const currentConfig = { ...storedConfig };\n\n  Object.keys(value).forEach((key) => {\n    if (value[key] !== null && value[key] !== undefined) {\n      _.set(currentConfig, key, value[key]);\n    }\n  });\n\n  if (!_.isEqual(currentConfig, storedConfig)) {\n    return getStore().set({\n      key: configurationKey(key),\n      value: currentConfig,\n    });\n  }\n};\n\nconst deleteKey = (key: any) => {\n  return strapi.db\n    .query('strapi::core-store')\n    .delete({ where: { key: `plugin_content_manager_configuration_${key}` } });\n};\n\nconst findByKey = async (key: any) => {\n  const results = await strapi.db.query('strapi::core-store').findMany({\n    where: {\n      key: {\n        $startsWith: key,\n      },\n    },\n  });\n\n  return results.map(({ value }) => JSON.parse(value));\n};\n\nconst getAllConfigurations = () => findByKey('plugin_content_manager_configuration');\n\nexport default {\n  getAllConfigurations,\n  findByKey,\n  getModelConfiguration,\n  setModelConfiguration,\n  deleteKey,\n  keys,\n};\n","import _ from 'lodash';\nimport { getService } from '../../../utils';\nimport {\n  isSortable,\n  isSearchable,\n  isVisible,\n  isListable,\n  isRelation,\n  getDefaultMainField,\n} from './attributes';\n\nfunction createDefaultMetadatas(schema: any) {\n  return {\n    ...Object.keys(schema.attributes).reduce((acc: any, name) => {\n      acc[name] = createDefaultMetadata(schema, name);\n      return acc;\n    }, {}),\n    id: {\n      edit: {},\n      list: {\n        label: 'id',\n        searchable: true,\n        sortable: true,\n      },\n    },\n  };\n}\n\nfunction createDefaultMetadata(schema: any, name: any) {\n  const edit = {\n    label: name,\n    description: '',\n    placeholder: '',\n    visible: isVisible(schema, name),\n    editable: true,\n  } as any;\n\n  const fieldAttributes = schema.attributes[name];\n  if (isRelation(fieldAttributes)) {\n    const { targetModel } = fieldAttributes;\n\n    const targetSchema = getTargetSchema(targetModel);\n\n    if (targetSchema) {\n      edit.mainField = getDefaultMainField(targetSchema);\n    }\n  }\n\n  _.assign(\n    edit,\n    _.pick(_.get(schema, ['config', 'metadatas', name, 'edit'], {}), [\n      'label',\n      'description',\n      'placeholder',\n      'visible',\n      'editable',\n      'mainField',\n    ])\n  );\n\n  const list = {\n    // @ts-expect-error we need to specify these properties\n    label: name,\n    // @ts-expect-error we need to specify these properties\n    searchable: isSearchable(schema, name),\n    // @ts-expect-error we need to specify these properties\n    sortable: isSortable(schema, name),\n    ..._.pick(_.get(schema, ['config', 'metadatas', name, 'list'], {}), [\n      'label',\n      'searchable',\n      'sortable',\n    ]),\n  };\n\n  return { edit, list };\n}\n\n/** Synchronisation functions */\n\nasync function syncMetadatas(configuration: any, schema: any) {\n  // clear all keys that do not exist anymore\n  if (_.isEmpty(configuration.metadatas)) {\n    return createDefaultMetadatas(schema);\n  }\n\n  // remove old keys\n  const metasWithValidKeys = _.pick(configuration.metadatas, Object.keys(schema.attributes));\n\n  // add new keys and missing fields\n  const metasWithDefaults = _.merge({}, createDefaultMetadatas(schema), metasWithValidKeys);\n\n  // clear the invalid mainFields\n  const updatedMetas = Object.keys(metasWithDefaults).reduce((acc, key) => {\n    const { edit, list } = metasWithDefaults[key];\n    const attr = schema.attributes[key];\n\n    const updatedMeta = { edit, list };\n    // update sortable attr\n    if (list.sortable && !isSortable(schema, key)) {\n      _.set(updatedMeta, ['list', 'sortable'], false);\n      _.set(acc, [key], updatedMeta);\n    }\n\n    if (list.searchable && !isSearchable(schema, key)) {\n      _.set(updatedMeta, ['list', 'searchable'], false);\n      _.set(acc, [key], updatedMeta);\n    }\n\n    if (!_.has(edit, 'mainField')) return acc;\n\n    // remove mainField if the attribute is not a relation anymore\n    if (!isRelation(attr)) {\n      _.set(updatedMeta, 'edit', _.omit(edit, ['mainField']));\n      _.set(acc, [key], updatedMeta);\n      return acc;\n    }\n\n    // if the mainField is id you can keep it\n    if (edit.mainField === 'id') return acc;\n\n    // check the mainField in the targetModel\n    const targetSchema = getTargetSchema(attr.targetModel);\n\n    if (!targetSchema) return acc;\n\n    if (!isSortable(targetSchema, edit.mainField) && !isListable(targetSchema, edit.mainField)) {\n      _.set(updatedMeta, ['edit', 'mainField'], getDefaultMainField(targetSchema));\n      _.set(acc, [key], updatedMeta);\n      return acc;\n    }\n\n    return acc;\n  }, {});\n\n  return _.assign(metasWithDefaults, updatedMetas);\n}\n\nconst getTargetSchema = (targetModel: any) => {\n  return getService('content-types').findContentType(targetModel);\n};\n\nexport { createDefaultMetadatas, syncMetadatas };\n","import _ from 'lodash';\nimport { getService } from '../../../utils';\nimport { isListable, hasEditableAttribute, hasRelationAttribute } from './attributes';\n\nconst DEFAULT_LIST_LENGTH = 4;\nconst MAX_ROW_SIZE = 12;\n\nconst isAllowedFieldSize = (type: any, size: any) => {\n  const { getFieldSize } = getService('field-sizes');\n  const fieldSize = getFieldSize(type);\n\n  // Check if field was locked to another size\n  if (!fieldSize.isResizable && size !== fieldSize.default) {\n    return false;\n  }\n\n  // Otherwise allow unless it's bigger than a row\n  return size <= MAX_ROW_SIZE;\n};\n\nconst getDefaultFieldSize = (attribute: any) => {\n  const { hasFieldSize, getFieldSize } = getService('field-sizes');\n\n  // Check if it's a custom field with a custom size and get the default size for the field type\n  return getFieldSize(hasFieldSize(attribute.customField) ? attribute.customField : attribute.type)\n    .default;\n};\n\nasync function createDefaultLayouts(schema: any) {\n  return {\n    // @ts-expect-error necessary to provide this default layout\n    list: createDefaultListLayout(schema),\n    // @ts-expect-error necessary to provide this default layout\n    edit: createDefaultEditLayout(schema),\n    ..._.pick(_.get(schema, ['config', 'layouts'], {}), ['list', 'edit']),\n  };\n}\n\nfunction createDefaultListLayout(schema: any) {\n  return Object.keys(schema.attributes)\n    .filter((name) => isListable(schema, name))\n    .slice(0, DEFAULT_LIST_LENGTH);\n}\n\nconst rowSize = (els: any) => els.reduce((sum: any, el: any) => sum + el.size, 0);\n\nfunction createDefaultEditLayout(schema: any) {\n  const keys = Object.keys(schema.attributes).filter((name) => hasEditableAttribute(schema, name));\n\n  return appendToEditLayout([], keys, schema);\n}\n\n/** Synchronisation functions */\n\nfunction syncLayouts(configuration: any, schema: any) {\n  if (_.isEmpty(configuration.layouts)) return createDefaultLayouts(schema);\n\n  const { list = [], editRelations = [], edit = [] } = configuration.layouts || {};\n\n  let cleanList = list.filter((attr: any) => isListable(schema, attr));\n\n  // TODO V5: remove editRelations\n  const cleanEditRelations = editRelations.filter((attr: any) =>\n    hasRelationAttribute(schema, attr)\n  );\n\n  // backward compatibility with when relations were on the side of the layout\n  // it migrates the displayed relations to the main edit layout\n  const elementsToReAppend = [...cleanEditRelations];\n  let cleanEdit: unknown[] = [];\n  for (const row of edit) {\n    const newRow: unknown[] = [];\n\n    for (const el of row) {\n      if (!hasEditableAttribute(schema, el.name)) continue;\n\n      // Check if the field is a custom field with a custom size.\n      // If so, use the custom size instead of the type size\n      const { hasFieldSize } = getService('field-sizes');\n      const fieldType = hasFieldSize(schema.attributes[el.name].customField)\n        ? schema.attributes[el.name].customField\n        : schema.attributes[el.name].type;\n\n      /* if the type of a field was changed (ex: string -> json) or a new field was added in the schema\n         and the new type doesn't allow the size of the previous type, append the field at the end of layouts\n      */\n      if (!isAllowedFieldSize(fieldType, el.size)) {\n        elementsToReAppend.push(el.name);\n        continue;\n      }\n\n      newRow.push(el);\n    }\n\n    if (newRow.length > 0) {\n      cleanEdit.push(newRow);\n    }\n  }\n\n  cleanEdit = appendToEditLayout(cleanEdit as any, elementsToReAppend, schema);\n\n  const newAttributes = _.difference(\n    Object.keys(schema.attributes),\n    Object.keys(configuration.metadatas)\n  );\n\n  /** Add new attributes where they belong */\n\n  if (cleanList.length < DEFAULT_LIST_LENGTH) {\n    // add newAttributes\n    // only add valid listable attributes\n    cleanList = _.uniq(\n      cleanList\n        .concat(newAttributes.filter((key) => isListable(schema, key)))\n        .slice(0, DEFAULT_LIST_LENGTH)\n    );\n  }\n\n  // add new attributes to edit view\n  const newEditAttributes = newAttributes.filter((key) => hasEditableAttribute(schema, key));\n\n  cleanEdit = appendToEditLayout(cleanEdit, newEditAttributes, schema);\n\n  return {\n    list: cleanList.length > 0 ? cleanList : createDefaultListLayout(schema),\n    edit: cleanEdit.length > 0 ? cleanEdit : createDefaultEditLayout(schema),\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/default-param-last\nconst appendToEditLayout = (layout: any = [], keysToAppend: any, schema: any) => {\n  if (keysToAppend.length === 0) return layout;\n  let currentRowIndex = Math.max(layout.length - 1, 0);\n\n  // init currentRow if necessary\n  if (!layout[currentRowIndex]) {\n    layout[currentRowIndex] = [];\n  }\n\n  for (const key of keysToAppend) {\n    const attribute = schema.attributes[key];\n\n    const attributeSize = getDefaultFieldSize(attribute);\n    const currenRowSize = rowSize(layout[currentRowIndex]);\n\n    if (currenRowSize + attributeSize > MAX_ROW_SIZE) {\n      currentRowIndex += 1;\n      layout[currentRowIndex] = [];\n    }\n\n    layout[currentRowIndex].push({\n      name: key,\n      size: attributeSize,\n    });\n  }\n\n  return layout;\n};\n\nexport { createDefaultLayouts, syncLayouts };\n","import { createModelConfigurationSchema } from '../../../controllers/validation';\nimport { createDefaultSettings, syncSettings } from './settings';\nimport { createDefaultMetadatas, syncMetadatas } from './metadatas';\nimport { createDefaultLayouts, syncLayouts } from './layouts';\n\nasync function validateCustomConfig(schema: any) {\n  try {\n    await createModelConfigurationSchema(schema, {\n      allowUndefined: true,\n    }).validate(schema.config);\n  } catch (error: any) {\n    throw new Error(\n      `Invalid Model configuration for model ${schema.uid}. Verify your {{ modelName }}.config.js(on) file:\\n  - ${error.message}\\n`\n    );\n  }\n}\n\nasync function createDefaultConfiguration(schema: any) {\n  await validateCustomConfig(schema);\n\n  return {\n    settings: await createDefaultSettings(schema),\n    metadatas: await createDefaultMetadatas(schema),\n    layouts: await createDefaultLayouts(schema),\n  };\n}\n\nasync function syncConfiguration(conf: any, schema: any) {\n  await validateCustomConfig(schema);\n\n  return {\n    settings: await syncSettings(conf, schema),\n    layouts: await syncLayouts(conf, schema),\n    metadatas: await syncMetadatas(conf, schema),\n  };\n}\n\nexport { createDefaultConfiguration, syncConfiguration };\n","import { intersection, difference } from 'lodash';\n\nimport type { Settings, Metadatas, Layouts } from '../../../shared/contracts/content-types';\n\nimport { createDefaultConfiguration, syncConfiguration } from './utils/configuration';\n\nexport type ConfigurationUpdate = {\n  settings: Settings;\n  metadatas: Metadatas;\n  layouts: Layouts;\n  options?: Record<string, unknown>;\n};\n\nexport default ({\n  isComponent,\n  prefix,\n  storeUtils,\n  getModels,\n}: {\n  isComponent?: boolean;\n  prefix: string;\n  storeUtils: any;\n  getModels: any;\n}) => {\n  const uidToStoreKey = (uid: string) => {\n    return `${prefix}::${uid}`;\n  };\n\n  const getConfiguration = (uid: string) => {\n    const storeKey = uidToStoreKey(uid);\n\n    return storeUtils.getModelConfiguration(storeKey);\n  };\n\n  const setConfiguration = (uid: string, input: ConfigurationUpdate) => {\n    const configuration = {\n      ...input,\n      uid,\n      isComponent: isComponent ?? undefined,\n    };\n\n    const storeKey = uidToStoreKey(uid);\n    return storeUtils.setModelConfiguration(storeKey, configuration);\n  };\n\n  const deleteConfiguration = (uid: string) => {\n    const storeKey = uidToStoreKey(uid);\n\n    return storeUtils.deleteKey(storeKey);\n  };\n\n  const syncConfigurations = async () => {\n    const models = getModels();\n\n    const configurations = await storeUtils.findByKey(\n      `plugin_content_manager_configuration_${prefix}`\n    );\n\n    const updateConfiguration = async (uid: string) => {\n      const conf = configurations.find((conf: any) => conf.uid === uid);\n\n      return setConfiguration(uid, await syncConfiguration(conf, models[uid]));\n    };\n\n    const generateNewConfiguration = async (uid: string) => {\n      return setConfiguration(uid, await createDefaultConfiguration(models[uid]));\n    };\n\n    const currentUIDS = Object.keys(models);\n    const DBUIDs = configurations.map(({ uid }: any) => uid);\n\n    const contentTypesToUpdate = intersection(currentUIDS, DBUIDs);\n    const contentTypesToAdd = difference(currentUIDS, DBUIDs);\n    const contentTypesToDelete = difference(DBUIDs, currentUIDS);\n\n    // delete old schemas\n    await Promise.all(contentTypesToDelete.map((uid) => deleteConfiguration(uid)));\n\n    // create new schemas\n    await Promise.all(contentTypesToAdd.map((uid) => generateNewConfiguration(uid)));\n\n    // update current schemas\n    await Promise.all(contentTypesToUpdate.map((uid) => updateConfiguration(uid)));\n  };\n\n  return {\n    getConfiguration,\n    setConfiguration,\n    deleteConfiguration,\n    syncConfigurations,\n  };\n};\n","import { has, isNil, mapValues } from 'lodash/fp';\n\nimport type { UID, Struct, Core } from '@strapi/types';\nimport type { Configuration } from '../../../shared/contracts/content-types';\nimport type { ConfigurationUpdate } from './configuration';\n\nimport { getService } from '../utils';\nimport storeUtils from './utils/store';\nimport createConfigurationService from './configuration';\n\nconst STORE_KEY_PREFIX = 'components';\n\nconst configurationService = createConfigurationService({\n  storeUtils,\n  isComponent: true,\n  prefix: STORE_KEY_PREFIX,\n  getModels() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return mapValues(toContentManagerModel, strapi.components);\n  },\n});\n\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\n  findAllComponents() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return Object.values(strapi.components).map(toContentManagerModel);\n  },\n\n  findComponent(uid: UID.Component) {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    const component = strapi.components[uid];\n\n    return isNil(component) ? component : toContentManagerModel(component);\n  },\n\n  async findConfiguration(component: Struct.ComponentSchema) {\n    const configuration: Configuration = await configurationService.getConfiguration(component.uid);\n\n    return {\n      uid: component.uid,\n      category: component.category,\n      ...configuration,\n    };\n  },\n\n  async updateConfiguration(\n    component: Struct.ComponentSchema,\n    newConfiguration: ConfigurationUpdate\n  ) {\n    await configurationService.setConfiguration(component.uid, newConfiguration);\n\n    return this.findConfiguration(component);\n  },\n\n  async findComponentsConfigurations(model: Struct.ComponentSchema) {\n    const componentsMap: Record<\n      string,\n      Configuration & { category: string; isComponent: boolean }\n    > = {};\n\n    const getComponentConfigurations = async (uid: UID.Component) => {\n      const component = this.findComponent(uid);\n\n      if (has(uid, componentsMap)) {\n        return;\n      }\n\n      const componentConfiguration = await this.findConfiguration(component);\n      const componentsConfigurations = await this.findComponentsConfigurations(component);\n\n      Object.assign(componentsMap, {\n        [uid]: componentConfiguration,\n        ...componentsConfigurations,\n      });\n    };\n\n    for (const key of Object.keys(model.attributes)) {\n      const attribute = model.attributes[key];\n\n      if (attribute.type === 'component') {\n        await getComponentConfigurations(attribute.component);\n      }\n\n      if (attribute.type === 'dynamiczone') {\n        for (const componentUid of attribute.components) {\n          await getComponentConfigurations(componentUid);\n        }\n      }\n    }\n\n    return componentsMap;\n  },\n\n  syncConfigurations() {\n    return configurationService.syncConfigurations();\n  },\n});\n","import { isNil, mapValues } from 'lodash/fp';\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\n\nimport type { UID, Struct, Core } from '@strapi/types';\n\nimport type { ConfigurationUpdate } from './configuration';\n\nimport { getService } from '../utils';\nimport storeUtils from './utils/store';\nimport createConfigurationService from './configuration';\n\nconst configurationService = createConfigurationService({\n  storeUtils,\n  prefix: 'content_types',\n  getModels() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return mapValues(toContentManagerModel, strapi.contentTypes);\n  },\n});\n\nconst service = ({ strapi }: { strapi: Core.Strapi }) => ({\n  findAllContentTypes() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return Object.values(strapi.contentTypes).map(toContentManagerModel);\n  },\n\n  findContentType(uid: UID.ContentType) {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    const contentType = strapi.contentTypes[uid];\n\n    return isNil(contentType) ? contentType : toContentManagerModel(contentType);\n  },\n\n  findDisplayedContentTypes() {\n    return this.findAllContentTypes().filter(\n      // TODO\n      // @ts-expect-error should be resolved from data-mapper types\n      ({ isDisplayed }: { isDisplayed: boolean }) => isDisplayed === true\n    );\n  },\n\n  findContentTypesByKind(kind: { kind: Struct.ContentTypeKind | undefined }) {\n    if (!kind) {\n      return this.findAllContentTypes();\n    }\n\n    // @ts-expect-error TODO when adding types\n    return this.findAllContentTypes().filter(contentTypesUtils.isKind(kind));\n  },\n\n  async findConfiguration(contentType: Struct.ContentTypeSchema) {\n    const configuration = await configurationService.getConfiguration(contentType.uid);\n\n    return {\n      uid: contentType.uid,\n      ...configuration,\n    };\n  },\n\n  async updateConfiguration(\n    contentType: Struct.ContentTypeSchema,\n    newConfiguration: ConfigurationUpdate\n  ) {\n    await configurationService.setConfiguration(contentType.uid, newConfiguration);\n\n    return this.findConfiguration(contentType);\n  },\n\n  findComponentsConfigurations(contentType: Struct.ContentTypeSchema) {\n    // delegate to componentService\n    return getService('components').findComponentsConfigurations(contentType);\n  },\n\n  syncConfigurations() {\n    return configurationService.syncConfigurations();\n  },\n});\n\nexport default service;\n","import { pick, getOr } from 'lodash/fp';\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\n\nimport type { Schema, Struct } from '@strapi/types';\n\nconst dtoFields = [\n  'uid',\n  'isDisplayed',\n  'apiID',\n  'kind',\n  'category',\n  'info',\n  'options',\n  'pluginOptions',\n  'attributes',\n  'pluginOptions',\n];\n\nexport default () => ({\n  toContentManagerModel(contentType: Struct.ComponentSchema) {\n    return {\n      ...contentType,\n      apiID: contentType.modelName,\n      isDisplayed: isVisible(contentType),\n      attributes: {\n        id: {\n          type: 'integer',\n        },\n        ...formatAttributes(contentType),\n      },\n    };\n  },\n\n  toDto: pick(dtoFields),\n});\n\nconst formatAttributes = (contentType: Struct.ComponentSchema) => {\n  const { getVisibleAttributes, getTimestamps, getCreatorFields } = contentTypesUtils;\n\n  // only get attributes that can be seen in the auto generated Edit view or List view\n  return getVisibleAttributes(contentType)\n    .concat(getTimestamps(contentType))\n    .concat(getCreatorFields(contentType))\n    .reduce((acc: any, key: string) => {\n      const attribute = contentType.attributes[key];\n\n      // ignore morph until they are handled in the front\n      if (attribute.type === 'relation' && attribute.relation.toLowerCase().includes('morph')) {\n        return acc;\n      }\n\n      acc[key] = formatAttribute(key, attribute);\n      return acc;\n    }, {});\n};\n\n// FIXME: not needed\nconst formatAttribute = (key: any, attribute: Schema.Attribute.AnyAttribute) => {\n  if (attribute.type === 'relation') {\n    return toRelation(attribute);\n  }\n\n  return attribute;\n};\n\n// FIXME: not needed\nconst toRelation = (attribute: Schema.Attribute.Relation) => {\n  return {\n    ...attribute,\n    type: 'relation',\n    targetModel: 'target' in attribute ? attribute.target : undefined,\n    relationType: attribute.relation,\n  };\n};\n\nconst isVisible = (model: Struct.ComponentSchema): boolean =>\n  getOr(true, 'pluginOptions.content-manager.visible', model) === true;\n","import { errors } from '@strapi/utils';\nimport type { Core, Modules } from '@strapi/types';\n\nconst { ApplicationError } = errors;\n\ntype FieldSize = Modules.CustomFields.CustomFieldServerOptions['inputSize'];\n\nconst needsFullSize: FieldSize = {\n  default: 12,\n  isResizable: false,\n};\n\nconst smallSize: FieldSize = {\n  default: 4,\n  isResizable: true,\n};\n\nconst defaultSize: FieldSize = {\n  default: 6,\n  isResizable: true,\n};\n\nconst fieldSizes: Record<string, FieldSize> = {\n  // Full row and not resizable\n  dynamiczone: needsFullSize,\n  component: needsFullSize,\n  json: needsFullSize,\n  richtext: needsFullSize,\n  blocks: needsFullSize,\n  // Small and resizable\n  checkbox: smallSize,\n  boolean: smallSize,\n  date: smallSize,\n  time: smallSize,\n  biginteger: smallSize,\n  decimal: smallSize,\n  float: smallSize,\n  integer: smallSize,\n  number: smallSize,\n  // Medium and resizable\n  datetime: defaultSize,\n  email: defaultSize,\n  enumeration: defaultSize,\n  media: defaultSize,\n  password: defaultSize,\n  relation: defaultSize,\n  string: defaultSize,\n  text: defaultSize,\n  timestamp: defaultSize,\n  uid: defaultSize,\n};\n\nconst createFieldSizesService = ({ strapi }: { strapi: Core.Strapi }) => {\n  const fieldSizesService = {\n    getAllFieldSizes() {\n      return fieldSizes;\n    },\n\n    hasFieldSize(type: string) {\n      return !!fieldSizes[type];\n    },\n\n    getFieldSize(type?: string) {\n      if (!type) {\n        throw new ApplicationError('The type is required');\n      }\n\n      const fieldSize = fieldSizes[type];\n      if (!fieldSize) {\n        throw new ApplicationError(`Could not find field size for type ${type}`);\n      }\n\n      return fieldSize;\n    },\n\n    setFieldSize(type: string, size: FieldSize) {\n      if (!type) {\n        throw new ApplicationError('The type is required');\n      }\n\n      if (!size) {\n        throw new ApplicationError('The size is required');\n      }\n\n      fieldSizes[type] = size;\n    },\n\n    setCustomFieldInputSizes() {\n      // Find all custom fields already registered\n      const customFields = strapi.get('custom-fields').getAll();\n\n      // If they have a custom field size, register it\n      // TODO types can be inferred when customFields is typed\n      Object.entries(customFields).forEach(([uid, customField]: [string, any]) => {\n        if (customField.inputSize) {\n          fieldSizesService.setFieldSize(uid, customField.inputSize);\n        }\n      });\n    },\n  };\n\n  return fieldSizesService;\n};\n\nexport default createFieldSizesService;\n","import { intersection, prop } from 'lodash/fp';\nimport { relations } from '@strapi/utils';\nimport type { Core, Struct } from '@strapi/types';\nimport type { Configuration } from '../../../shared/contracts/content-types';\n\nconst { getRelationalFields } = relations;\n\nexport default ({ strapi }: { strapi: Core.Strapi }) => {\n  const sendDidConfigureListView = async (\n    contentType: Struct.ContentTypeSchema,\n    configuration: Configuration\n  ) => {\n    const displayedFields = prop('length', configuration.layouts.list);\n    const relationalFields = getRelationalFields(contentType);\n    const displayedRelationalFields = intersection(\n      relationalFields,\n      configuration.layouts.list\n    ).length;\n\n    const data = {\n      eventProperties: { containsRelationalFields: !!displayedRelationalFields },\n    };\n\n    if (data.eventProperties.containsRelationalFields) {\n      Object.assign(data.eventProperties, {\n        displayedFields,\n        displayedRelationalFields,\n      });\n    }\n\n    try {\n      await strapi.telemetry.send('didConfigureListView', data);\n    } catch (e) {\n      // silence\n    }\n  };\n\n  return {\n    sendDidConfigureListView,\n  };\n};\n","import { async } from '@strapi/utils';\nimport type { Core, UID, Modules } from '@strapi/types';\n\nconst ACTIONS = {\n  read: 'plugin::content-manager.explorer.read',\n  create: 'plugin::content-manager.explorer.create',\n  update: 'plugin::content-manager.explorer.update',\n  delete: 'plugin::content-manager.explorer.delete',\n  publish: 'plugin::content-manager.explorer.publish',\n  unpublish: 'plugin::content-manager.explorer.publish',\n  discard: 'plugin::content-manager.explorer.update',\n} as const;\n\ntype Entity = Modules.EntityService.Result<UID.ContentType>;\ntype Query = {\n  page?: string;\n  pageSize?: string;\n  sort?: string;\n};\n\nconst createPermissionChecker =\n  (strapi: Core.Strapi) =>\n  ({ userAbility, model }: { userAbility: any; model: string }) => {\n    const permissionsManager = strapi.service('admin::permission').createPermissionsManager({\n      ability: userAbility,\n      model,\n    });\n\n    const { actionProvider } = strapi.service('admin::permission');\n\n    const toSubject = (entity?: Entity) => {\n      return entity ? permissionsManager.toSubject(entity, model) : model;\n    };\n\n    // @ts-expect-error preserve the parameter order\n    // eslint-disable-next-line @typescript-eslint/default-param-last\n    const can = (action: string, entity?: Entity, field: string) => {\n      const subject = toSubject(entity);\n      const aliases = actionProvider.unstable_aliases(action, model) as string[];\n\n      return (\n        // Test the original action to see if it passes\n        userAbility.can(action, subject, field) ||\n        // Else try every known alias if at least one of them succeed, then the user \"can\"\n        aliases.some((alias) => userAbility.can(alias, subject, field))\n      );\n    };\n\n    // @ts-expect-error preserve the parameter order\n    // eslint-disable-next-line @typescript-eslint/default-param-last\n    const cannot = (action: string, entity?: Entity, field: string) => {\n      const subject = toSubject(entity);\n      const aliases = actionProvider.unstable_aliases(action, model) as string[];\n\n      return (\n        // Test both the original action\n        userAbility.cannot(action, subject, field) &&\n        // and every known alias, if all of them fail (cannot), then the user truly \"cannot\"\n        aliases.every((alias) => userAbility.cannot(alias, subject, field))\n      );\n    };\n\n    const sanitizeOutput = (data: Entity, { action = ACTIONS.read }: { action?: string } = {}) => {\n      return permissionsManager.sanitizeOutput(data, { subject: toSubject(data), action });\n    };\n\n    const sanitizeQuery = (query: Query, { action = ACTIONS.read }: { action?: string } = {}) => {\n      return permissionsManager.sanitizeQuery(query, { subject: model, action });\n    };\n\n    const sanitizeInput = (action: string, data: any, entity?: Entity) => {\n      return permissionsManager.sanitizeInput(data, {\n        subject: entity ? toSubject(entity) : model,\n        action,\n      });\n    };\n\n    const validateQuery = (query: Query, { action = ACTIONS.read }: { action?: string } = {}) => {\n      return permissionsManager.validateQuery(query, { subject: model, action });\n    };\n\n    const validateInput = (action: string, data: any, entity?: Entity) => {\n      return permissionsManager.validateInput(data, {\n        subject: entity ? toSubject(entity) : model,\n        action,\n      });\n    };\n\n    const sanitizeCreateInput = (data: any) => sanitizeInput(ACTIONS.create, data);\n    const sanitizeUpdateInput = (entity: Entity) => (data: any) =>\n      sanitizeInput(ACTIONS.update, data, entity);\n\n    const buildPermissionQuery = (query: Query, action: { action?: string } = {}) => {\n      return permissionsManager.addPermissionsQueryTo(query, action);\n    };\n\n    const sanitizedQuery = (query: Query, action: { action?: string } = {}) => {\n      return async.pipe(\n        (q: Query) => sanitizeQuery(q, action),\n        (q: Query) => buildPermissionQuery(q, action)\n      )(query);\n    };\n\n    // Sanitized queries shortcuts\n    Object.keys(ACTIONS).forEach((action) => {\n      // @ts-expect-error TODO\n      sanitizedQuery[action] = (query: Query) => sanitizedQuery(query, ACTIONS[action]);\n    });\n\n    // Permission utils shortcuts\n    Object.keys(ACTIONS).forEach((action) => {\n      // @ts-expect-error TODO\n      can[action] = (...args: any) => can(ACTIONS[action], ...args);\n      // @ts-expect-error TODO\n      cannot[action] = (...args: any) => cannot(ACTIONS[action], ...args);\n    });\n\n    return {\n      // Permission utils\n      can, // check if you have the permission\n      cannot, // check if you don't have the permission\n      // Sanitizers\n      sanitizeOutput,\n      sanitizeQuery,\n      sanitizeCreateInput,\n      sanitizeUpdateInput,\n      // Validators\n      validateQuery,\n      validateInput,\n      // Queries Builder\n      sanitizedQuery,\n    };\n  };\n\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\n  create: createPermissionChecker(strapi),\n});\n","import { prop } from 'lodash/fp';\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\n\nimport type { Core, Struct } from '@strapi/types';\nimport { getService } from '../utils';\n\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\n  canConfigureContentType({\n    userAbility,\n    contentType,\n  }: {\n    userAbility: any;\n    contentType: Struct.ContentTypeSchema;\n  }) {\n    const action = contentTypesUtils.isSingleType(contentType)\n      ? 'plugin::content-manager.single-types.configure-view'\n      : 'plugin::content-manager.collection-types.configure-view';\n\n    return userAbility.can(action);\n  },\n\n  async registerPermissions() {\n    const displayedContentTypes = getService('content-types').findDisplayedContentTypes();\n    const contentTypesUids = displayedContentTypes.map(prop('uid'));\n\n    const actions = [\n      {\n        section: 'contentTypes',\n        displayName: 'Create',\n        uid: 'explorer.create',\n        pluginName: 'content-manager',\n        subjects: contentTypesUids,\n        options: {\n          applyToProperties: ['fields'],\n        },\n      },\n      {\n        section: 'contentTypes',\n        displayName: 'Read',\n        uid: 'explorer.read',\n        pluginName: 'content-manager',\n        subjects: contentTypesUids,\n        options: {\n          applyToProperties: ['fields'],\n        },\n      },\n      {\n        section: 'contentTypes',\n        displayName: 'Update',\n        uid: 'explorer.update',\n        pluginName: 'content-manager',\n        subjects: contentTypesUids,\n        options: {\n          applyToProperties: ['fields'],\n        },\n      },\n      {\n        section: 'contentTypes',\n        displayName: 'Delete',\n        uid: 'explorer.delete',\n        pluginName: 'content-manager',\n        subjects: contentTypesUids,\n      },\n      {\n        section: 'contentTypes',\n        displayName: 'Publish',\n        uid: 'explorer.publish',\n        pluginName: 'content-manager',\n        subjects: contentTypesUids,\n      },\n      {\n        section: 'plugins',\n        displayName: 'Configure view',\n        uid: 'single-types.configure-view',\n        subCategory: 'single types',\n        pluginName: 'content-manager',\n      },\n      {\n        section: 'plugins',\n        displayName: 'Configure view',\n        uid: 'collection-types.configure-view',\n        subCategory: 'collection types',\n        pluginName: 'content-manager',\n      },\n      {\n        section: 'plugins',\n        displayName: 'Configure Layout',\n        uid: 'components.configure-layout',\n        subCategory: 'components',\n        pluginName: 'content-manager',\n      },\n    ];\n\n    await strapi.service('admin::permission').actionProvider.registerMany(actions);\n  },\n});\n","import { merge, isEmpty, set, propEq } from 'lodash/fp';\nimport strapiUtils from '@strapi/utils';\nimport { UID, Schema, Modules } from '@strapi/types';\nimport { getService } from '../../utils';\n\nconst { isVisibleAttribute, isScalarAttribute, getDoesAttributeRequireValidation } =\n  strapiUtils.contentTypes;\nconst { isAnyToMany } = strapiUtils.relations;\nconst { PUBLISHED_AT_ATTRIBUTE } = strapiUtils.contentTypes.constants;\n\nconst isMorphToRelation = (attribute: any) =>\n  isRelation(attribute) && attribute.relation.includes('morphTo');\nconst isMedia = propEq('type', 'media');\nconst isRelation = propEq('type', 'relation');\nconst isComponent = propEq('type', 'component');\nconst isDynamicZone = propEq('type', 'dynamiczone');\n\n// TODO: Import from @strapi/types when it's available there\ntype Model = Parameters<typeof isVisibleAttribute>[0];\nexport type Populate = Modules.EntityService.Params.Populate.Any<UID.Schema>;\n\ntype PopulateOptions = {\n  initialPopulate?: Populate;\n  countMany?: boolean;\n  countOne?: boolean;\n  maxLevel?: number;\n};\n\n/**\n * Populate the model for relation\n * @param attribute - Attribute containing a relation\n * @param attribute.relation - type of relation\n * @param model - Model of the populated entity\n * @param attributeName\n * @param options - Options to apply while populating\n */\nfunction getPopulateForRelation(\n  attribute: Schema.Attribute.AnyAttribute,\n  model: Model,\n  attributeName: string,\n  { countMany, countOne, initialPopulate }: PopulateOptions\n) {\n  const isManyRelation = isAnyToMany(attribute);\n\n  if (initialPopulate) {\n    return initialPopulate;\n  }\n\n  // always populate createdBy, updatedBy, localizations etc.\n  if (!isVisibleAttribute(model, attributeName)) {\n    return true;\n  }\n\n  if ((isManyRelation && countMany) || (!isManyRelation && countOne)) {\n    return { count: true };\n  }\n\n  return true;\n}\n\n/**\n * Populate the model for Dynamic Zone components\n * @param attribute - Attribute containing the components\n * @param attribute.components - IDs of components\n * @param options - Options to apply while populating\n */\nfunction getPopulateForDZ(\n  attribute: Schema.Attribute.DynamicZone,\n  options: PopulateOptions,\n  level: number\n) {\n  // Use fragments to populate the dynamic zone components\n  const populatedComponents = (attribute.components || []).reduce(\n    (acc: any, componentUID: UID.Component) => ({\n      ...acc,\n      [componentUID]: {\n        populate: getDeepPopulate(componentUID, options, level + 1),\n      },\n    }),\n    {}\n  );\n\n  return { on: populatedComponents };\n}\n\n/**\n * Get the populated value based on the type of the attribute\n * @param attributeName - Name of the attribute\n * @param model - Model of the populated entity\n * @param model.attributes\n * @param options - Options to apply while populating\n * @param options.countMany\n * @param options.countOne\n * @param options.maxLevel\n * @param level\n */\nfunction getPopulateFor(\n  attributeName: string,\n  model: any,\n  options: PopulateOptions,\n  level: number\n): { [key: string]: boolean | object } {\n  const attribute = model.attributes[attributeName];\n\n  switch (attribute.type) {\n    case 'relation':\n      // @ts-expect-error - TODO: support populate count typing\n      return {\n        [attributeName]: getPopulateForRelation(attribute, model, attributeName, options),\n      };\n    case 'component':\n      return {\n        [attributeName]: {\n          populate: getDeepPopulate(attribute.component, options, level + 1),\n        },\n      };\n    case 'media':\n      return {\n        [attributeName]: {\n          populate: {\n            folder: true,\n          },\n        },\n      };\n    case 'dynamiczone':\n      return {\n        [attributeName]: getPopulateForDZ(attribute, options, level),\n      };\n    default:\n      return {};\n  }\n}\n\n/**\n * Deeply populate a model based on UID\n * @param uid - Unique identifier of the model\n * @param options - Options to apply while populating\n * @param level - Current level of nested call\n */\nconst getDeepPopulate = (\n  uid: UID.Schema,\n  {\n    initialPopulate = {} as any,\n    countMany = false,\n    countOne = false,\n    maxLevel = Infinity,\n  }: PopulateOptions = {},\n  level = 1\n) => {\n  if (level > maxLevel) {\n    return {};\n  }\n\n  const model = strapi.getModel(uid);\n\n  return Object.keys(model.attributes).reduce(\n    (populateAcc, attributeName: string) =>\n      merge(\n        populateAcc,\n        getPopulateFor(\n          attributeName,\n          model,\n          {\n            // @ts-expect-error - improve types\n            initialPopulate: initialPopulate?.[attributeName],\n            countMany,\n            countOne,\n            maxLevel,\n          },\n          level\n        )\n      ),\n    {}\n  );\n};\n\n/**\n * Deeply populate a model based on UID. Only populating fields that require validation.\n * @param uid - Unique identifier of the model\n * @param options - Options to apply while populating\n * @param level - Current level of nested call\n */\nconst getValidatableFieldsPopulate = (\n  uid: UID.Schema,\n  {\n    initialPopulate = {} as any,\n    countMany = false,\n    countOne = false,\n    maxLevel = Infinity,\n  }: PopulateOptions = {},\n  level = 1\n) => {\n  if (level > maxLevel) {\n    return {};\n  }\n\n  const model = strapi.getModel(uid);\n\n  return Object.entries(model.attributes).reduce((populateAcc, [attributeName, attribute]) => {\n    if (!getDoesAttributeRequireValidation(attribute)) {\n      // If the attribute does not require validation, skip it\n      return populateAcc;\n    }\n\n    if (isScalarAttribute(attribute)) {\n      return merge(populateAcc, {\n        [attributeName]: true,\n      });\n    }\n\n    return merge(\n      populateAcc,\n      getPopulateFor(\n        attributeName,\n        model,\n        {\n          // @ts-expect-error - improve types\n          initialPopulate: initialPopulate?.[attributeName],\n          countMany,\n          countOne,\n          maxLevel,\n        },\n        level\n      )\n    );\n  }, {});\n};\n\n/**\n * getDeepPopulateDraftCount works recursively on the attributes of a model\n * creating a populated object to count all the unpublished relations within the model\n * These relations can be direct to this content type or contained within components/dynamic zones\n * @param  uid of the model\n * @returns result\n * @returns result.populate\n * @returns result.hasRelations\n */\nconst getDeepPopulateDraftCount = (uid: UID.Schema) => {\n  const model = strapi.getModel(uid);\n  let hasRelations = false;\n\n  const populate = Object.keys(model.attributes).reduce((populateAcc: any, attributeName) => {\n    const attribute: Schema.Attribute.AnyAttribute = model.attributes[attributeName];\n\n    switch (attribute.type) {\n      case 'relation': {\n        // TODO: Support polymorphic relations\n        const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n        if (isMorphRelation) {\n          break;\n        }\n\n        if (isVisibleAttribute(model, attributeName)) {\n          populateAcc[attributeName] = {\n            count: true,\n            filters: { [PUBLISHED_AT_ATTRIBUTE]: { $null: true } },\n          };\n          hasRelations = true;\n        }\n        break;\n      }\n      case 'component': {\n        const { populate, hasRelations: childHasRelations } = getDeepPopulateDraftCount(\n          attribute.component\n        );\n        if (childHasRelations) {\n          populateAcc[attributeName] = {\n            populate,\n          };\n          hasRelations = true;\n        }\n        break;\n      }\n      case 'dynamiczone': {\n        const dzPopulateFragment = attribute.components?.reduce((acc, componentUID) => {\n          const { populate: componentPopulate, hasRelations: componentHasRelations } =\n            getDeepPopulateDraftCount(componentUID);\n\n          if (componentHasRelations) {\n            hasRelations = true;\n\n            return { ...acc, [componentUID]: { populate: componentPopulate } };\n          }\n\n          return acc;\n        }, {});\n\n        if (!isEmpty(dzPopulateFragment)) {\n          populateAcc[attributeName] = { on: dzPopulateFragment };\n        }\n        break;\n      }\n      default:\n    }\n\n    return populateAcc;\n  }, {});\n\n  return { populate, hasRelations };\n};\n\n/**\n *  Create a Strapi populate object which populates all attribute fields of a Strapi query.\n */\nconst getQueryPopulate = async (uid: UID.Schema, query: object): Promise<Populate> => {\n  let populateQuery: Populate = {};\n\n  await strapiUtils.traverse.traverseQueryFilters(\n    /**\n     *\n     * @param {Object} param0\n     * @param {string} param0.key - Attribute name\n     * @param {Object} param0.attribute - Attribute definition\n     * @param {string} param0.path - Content Type path to the attribute\n     * @returns\n     */\n    ({ attribute, path }: any) => {\n      // TODO: handle dynamic zones and morph relations\n      if (!attribute || isDynamicZone(attribute) || isMorphToRelation(attribute)) {\n        return;\n      }\n\n      // Populate all relations, components and media\n      if (isRelation(attribute) || isMedia(attribute) || isComponent(attribute)) {\n        const populatePath = path.attribute.replace(/\\./g, '.populate.');\n        // @ts-expect-error - lodash doesn't resolve the Populate type correctly\n        populateQuery = set(populatePath, {}, populateQuery);\n      }\n    },\n    { schema: strapi.getModel(uid), getModel: strapi.getModel.bind(strapi) },\n    query\n  );\n\n  return populateQuery;\n};\n\nconst buildDeepPopulate = (uid: UID.CollectionType) => {\n  return getService('populate-builder')(uid).populateDeep(Infinity).countRelations().build();\n};\n\nexport {\n  getDeepPopulate,\n  getDeepPopulateDraftCount,\n  getQueryPopulate,\n  buildDeepPopulate,\n  getValidatableFieldsPopulate,\n};\n","import { isNil } from 'lodash/fp';\nimport type { UID } from '@strapi/types';\nimport { type Populate, getDeepPopulate, getQueryPopulate } from './utils/populate';\n\n/**\n * Builder to create a Strapi populate object.\n *\n * @param uid - Content type UID\n *\n * @example\n * const populate = await populateBuilder('api::article.article').countRelations().build();\n * // populate = { article: { populate: { count: true } } }\n *\n */\nconst populateBuilder = (uid: UID.Schema) => {\n  let getInitialPopulate = async (): Promise<undefined | Populate> => {\n    return undefined;\n  };\n  const deepPopulateOptions = {\n    countMany: false,\n    countOne: false,\n    maxLevel: -1,\n  };\n\n  const builder = {\n    /**\n     * Populates all attribute fields present in a query.\n     * @param query - Strapi query object\n     */\n    populateFromQuery(query: object) {\n      getInitialPopulate = async () => getQueryPopulate(uid, query);\n      return builder;\n    },\n\n    /**\n     * Populate relations as count.\n     * @param [options]\n     * @param [options.toMany] - Populate XtoMany relations as count if true.\n     * @param [options.toOne] - Populate XtoOne relations as count if true.\n     */\n    countRelations({ toMany, toOne } = { toMany: true, toOne: true }) {\n      if (!isNil(toMany)) {\n        deepPopulateOptions.countMany = toMany;\n      }\n      if (!isNil(toOne)) {\n        deepPopulateOptions.countOne = toOne;\n      }\n      return builder;\n    },\n\n    /**\n     * Populate relations deeply, up to a certain level.\n     * @param [level=Infinity] - Max level of nested populate.\n     */\n    populateDeep(level = Infinity) {\n      deepPopulateOptions.maxLevel = level;\n      return builder;\n    },\n\n    /**\n     * Construct the populate object based on the builder options.\n     * @returns Populate object\n     */\n    async build() {\n      const initialPopulate = await getInitialPopulate();\n\n      if (deepPopulateOptions.maxLevel === -1) {\n        return initialPopulate;\n      }\n\n      return getDeepPopulate(uid, { ...deepPopulateOptions, initialPopulate });\n    },\n  };\n\n  return builder;\n};\n\nexport default () => populateBuilder;\n","import _ from 'lodash';\nimport slugify from '@sindresorhus/slugify';\n\nimport type { Core, Schema, UID } from '@strapi/types';\n\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\n  async generateUIDField({\n    contentTypeUID,\n    field,\n    data,\n    locale,\n  }: {\n    contentTypeUID: UID.ContentType;\n    field: string;\n    data: Record<string, any>;\n    locale?: string;\n  }) {\n    const contentType = strapi.contentTypes[contentTypeUID];\n    const { attributes } = contentType;\n\n    const {\n      targetField,\n      default: defaultValue,\n      options,\n    } = attributes[field] as Schema.Attribute.UID;\n\n    // @ts-expect-error targetField can be undefined\n    const targetValue = _.get(data, targetField);\n\n    if (!_.isEmpty(targetValue)) {\n      return this.findUniqueUID({\n        contentTypeUID,\n        field,\n        value: slugify(targetValue, options),\n        locale,\n      });\n    }\n\n    return this.findUniqueUID({\n      contentTypeUID,\n      field,\n      value: slugify(\n        _.isFunction(defaultValue) ? defaultValue() : defaultValue || contentType.modelName,\n        options\n      ),\n      locale,\n    });\n  },\n\n  async findUniqueUID({\n    contentTypeUID,\n    field,\n    value,\n    locale,\n  }: {\n    contentTypeUID: UID.ContentType;\n    field: string;\n    value: string;\n    locale?: string;\n  }) {\n    const foundDocuments = await strapi.documents(contentTypeUID).findMany({\n      filters: {\n        [field]: { $startsWith: value },\n      },\n      locale,\n      // TODO: Check UX. When modifying an entry, it only makes sense to check for collisions with other drafts\n      // However, when publishing this \"available\" UID might collide with another published entry\n      status: 'draft',\n    });\n\n    if (!foundDocuments || foundDocuments.length === 0) {\n      // If there are no documents found we can return the value as is\n      return value;\n    }\n\n    let possibleCollisions: string[];\n    if (!Array.isArray(foundDocuments)) {\n      possibleCollisions = [foundDocuments[field]];\n    } else {\n      possibleCollisions = foundDocuments.map((doc: any) => doc[field]);\n    }\n\n    // If there are no documents sharing the proposed UID, we can return the value as is\n    if (!possibleCollisions.includes(value)) {\n      return value;\n    }\n\n    let i = 1;\n    let tmpUId = `${value}-${i}`;\n    while (possibleCollisions.includes(tmpUId)) {\n      // While there are documents sharing the proposed UID, we need to find a new one\n      // by incrementing the suffix until we find a unique one\n      i += 1;\n      tmpUId = `${value}-${i}`;\n    }\n\n    return tmpUId;\n  },\n\n  async checkUIDAvailability({\n    contentTypeUID,\n    field,\n    value,\n    locale,\n  }: {\n    contentTypeUID: UID.ContentType;\n    field: string;\n    value: string;\n    locale?: string;\n  }) {\n    const documentCount = await strapi.documents(contentTypeUID).count({\n      filters: {\n        [field]: value,\n      },\n      locale,\n      // TODO: Check UX. When modifying an entry, it only makes sense to check for collisions with other drafts\n      // However, when publishing this \"available\" UID might collide with another published entry\n      status: 'draft',\n    });\n\n    if (documentCount && documentCount > 0) {\n      // If there are documents sharing the proposed UID, we can return false\n      return false;\n    }\n\n    return true;\n  },\n});\n","import { groupBy, pick } from 'lodash/fp';\n\nimport { async, contentTypes, traverseEntity } from '@strapi/utils';\nimport type { Core, UID, Modules } from '@strapi/types';\n\nimport type { DocumentMetadata } from '../../../shared/contracts/collection-types';\nimport { getValidatableFieldsPopulate } from './utils/populate';\n\nexport interface DocumentVersion {\n  id: number;\n  documentId: Modules.Documents.ID;\n  locale: string;\n  updatedAt: string | null | Date;\n  publishedAt: string | null | Date;\n}\n\nconst AVAILABLE_STATUS_FIELDS = [\n  'id',\n  'locale',\n  'updatedAt',\n  'createdAt',\n  'publishedAt',\n  'createdBy',\n  'updatedBy',\n  'status',\n];\nconst AVAILABLE_LOCALES_FIELDS = [\n  'id',\n  'locale',\n  'updatedAt',\n  'createdAt',\n  'status',\n  'publishedAt',\n  'documentId',\n];\n\nconst CONTENT_MANAGER_STATUS = {\n  PUBLISHED: 'published',\n  DRAFT: 'draft',\n  MODIFIED: 'modified',\n};\n\n/**\n * Controls the metadata properties to be returned\n *\n * If `availableLocales` is set to `true` (default), the returned metadata will include\n * the available locales of the document for its current status.\n *\n * If `availableStatus` is set to `true` (default), the returned metadata will include\n * the available status of the document for its current locale.\n */\nexport interface GetMetadataOptions {\n  availableLocales?: boolean;\n  availableStatus?: boolean;\n}\n\n/**\n * Checks if the provided document version has been modified after all other versions.\n */\nconst getIsVersionLatestModification = (\n  version?: DocumentVersion,\n  otherVersion?: DocumentVersion\n): boolean => {\n  if (!version || !version.updatedAt) {\n    return false;\n  }\n\n  const versionUpdatedAt = version?.updatedAt ? new Date(version.updatedAt).getTime() : 0;\n\n  const otherUpdatedAt = otherVersion?.updatedAt ? new Date(otherVersion.updatedAt).getTime() : 0;\n\n  return versionUpdatedAt > otherUpdatedAt;\n};\n\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\n  /**\n   * Returns available locales of a document for the current status\n   */\n  async getAvailableLocales(\n    uid: UID.ContentType,\n    version: DocumentVersion,\n    allVersions: DocumentVersion[],\n    validatableFields: string[] = []\n  ) {\n    // Group all versions by locale\n    const versionsByLocale = groupBy('locale', allVersions);\n\n    // Delete the current locale\n    delete versionsByLocale[version.locale];\n\n    // For each locale, get the ones with the same status\n    // There will not be a draft and a version counterpart if the content\n    // type does not have draft and publish\n    const model = strapi.getModel(uid);\n    const keysToKeep = [...AVAILABLE_LOCALES_FIELDS, ...validatableFields];\n\n    const traversalFunction = async (localeVersion: DocumentVersion) =>\n      traverseEntity(\n        ({ key }, { remove }) => {\n          if (keysToKeep.includes(key)) {\n            // Keep the value if it is a field to pick\n            return;\n          }\n\n          // Otherwise remove this key from the data\n          remove(key);\n        },\n        { schema: model, getModel: strapi.getModel.bind(strapi) },\n        // @ts-expect-error fix types DocumentVersion incompatible with Data\n        localeVersion\n      );\n\n    const mappingResult = await async.map(\n      Object.values(versionsByLocale),\n      async (localeVersions: DocumentVersion[]) => {\n        const mappedLocaleVersions: DocumentVersion[] = await async.map(\n          localeVersions,\n          traversalFunction\n        );\n\n        if (!contentTypes.hasDraftAndPublish(model)) {\n          return mappedLocaleVersions[0];\n        }\n\n        const draftVersion = mappedLocaleVersions.find((v) => v.publishedAt === null);\n        const otherVersions = mappedLocaleVersions.filter((v) => v.id !== draftVersion?.id);\n\n        if (!draftVersion) {\n          return;\n        }\n\n        return {\n          ...draftVersion,\n          status: this.getStatus(draftVersion, otherVersions as any),\n        };\n      }\n    );\n\n    return (\n      mappingResult\n        // Filter just in case there is a document with no drafts\n        .filter(Boolean) as unknown as DocumentMetadata['availableLocales']\n    );\n  },\n\n  /**\n   * Returns available status of a document for the current locale\n   */\n  getAvailableStatus(version: DocumentVersion, allVersions: DocumentVersion[]) {\n    // Find the other status of the document\n    const status =\n      version.publishedAt !== null\n        ? CONTENT_MANAGER_STATUS.DRAFT\n        : CONTENT_MANAGER_STATUS.PUBLISHED;\n\n    // Get version that match the current locale and not match the current status\n    const availableStatus = allVersions.find((v) => {\n      const matchLocale = v.locale === version.locale;\n      const matchStatus = status === 'published' ? v.publishedAt !== null : v.publishedAt === null;\n      return matchLocale && matchStatus;\n    });\n\n    if (!availableStatus) return availableStatus;\n\n    // Pick status fields (at fields, status, by fields), use lodash fp\n    return pick(AVAILABLE_STATUS_FIELDS, availableStatus);\n  },\n  /**\n   * Get the available status of many documents, useful for batch operations\n   * @param uid\n   * @param documents\n   * @returns\n   */\n  async getManyAvailableStatus(uid: UID.ContentType, documents: DocumentVersion[]) {\n    if (!documents.length) return [];\n\n    // The status and locale of all documents should be the same\n    const status = documents[0].publishedAt !== null ? 'published' : 'draft';\n    const locale = documents[0]?.locale;\n    const otherStatus = status === 'published' ? 'draft' : 'published';\n\n    return strapi.documents(uid).findMany({\n      filters: {\n        documentId: { $in: documents.map((d) => d.documentId).filter(Boolean) },\n      },\n      status: otherStatus,\n      locale,\n      fields: ['documentId', 'locale', 'updatedAt', 'createdAt', 'publishedAt'],\n    }) as unknown as DocumentMetadata['availableStatus'];\n  },\n\n  getStatus(version: DocumentVersion, otherDocumentStatuses?: DocumentMetadata['availableStatus']) {\n    let draftVersion: DocumentVersion | undefined;\n    let publishedVersion: DocumentVersion | undefined;\n\n    if (version.publishedAt) {\n      publishedVersion = version;\n    } else {\n      draftVersion = version;\n    }\n\n    const otherVersion = otherDocumentStatuses?.at(0);\n    if (otherVersion?.publishedAt) {\n      publishedVersion = otherVersion;\n    } else if (otherVersion) {\n      draftVersion = otherVersion;\n    }\n\n    if (!draftVersion) return CONTENT_MANAGER_STATUS.PUBLISHED;\n    if (!publishedVersion) return CONTENT_MANAGER_STATUS.DRAFT;\n\n    /*\n     * The document is modified if the draft version has been updated more\n     * recently than the published version.\n     */\n    const isDraftModified = getIsVersionLatestModification(draftVersion, publishedVersion);\n    return isDraftModified ? CONTENT_MANAGER_STATUS.MODIFIED : CONTENT_MANAGER_STATUS.PUBLISHED;\n  },\n\n  // TODO is it necessary to return metadata on every page of the CM\n  // We could refactor this so the locales are only loaded when they're\n  // needed. e.g. in the bulk locale action modal.\n  async getMetadata(\n    uid: UID.ContentType,\n    version: DocumentVersion,\n    { availableLocales = true, availableStatus = true }: GetMetadataOptions = {}\n  ) {\n    // TODO: Ignore publishedAt if availableStatus=false, and ignore locale if\n    // i18n is disabled\n    const populate = getValidatableFieldsPopulate(uid);\n    const versions = await strapi.db.query(uid).findMany({\n      where: { documentId: version.documentId },\n      populate: {\n        // Populate only fields that require validation for bulk locale actions\n        ...populate,\n        // NOTE: creator fields are selected in this way to avoid exposing sensitive data\n        createdBy: {\n          select: ['id', 'firstname', 'lastname', 'email'],\n        },\n        updatedBy: {\n          select: ['id', 'firstname', 'lastname', 'email'],\n        },\n      },\n    });\n\n    const availableLocalesResult = availableLocales\n      ? await this.getAvailableLocales(uid, version, versions, Object.keys(populate))\n      : [];\n\n    const availableStatusResult = availableStatus\n      ? this.getAvailableStatus(version, versions)\n      : null;\n\n    return {\n      availableLocales: availableLocalesResult,\n      availableStatus: availableStatusResult ? [availableStatusResult] : [],\n    };\n  },\n\n  /**\n   * Returns associated metadata of a document:\n   * - Available locales of the document for the current status\n   * - Available status of the document for the current locale\n   */\n  async formatDocumentWithMetadata(\n    uid: UID.ContentType,\n    document: DocumentVersion,\n    opts: GetMetadataOptions = {}\n  ) {\n    if (!document) {\n      return {\n        data: document,\n        meta: {\n          availableLocales: [],\n          availableStatus: [],\n        },\n      };\n    }\n\n    const hasDraftAndPublish = contentTypes.hasDraftAndPublish(strapi.getModel(uid));\n\n    // Ignore available status if the content type does not have draft and publish\n    if (!hasDraftAndPublish) {\n      opts.availableStatus = false;\n    }\n\n    const meta = await this.getMetadata(uid, document, opts);\n\n    return {\n      data: {\n        ...document,\n        // Add status to the document only if draft and publish is enabled\n        status: hasDraftAndPublish\n          ? this.getStatus(document, meta.availableStatus as any)\n          : undefined,\n      },\n      meta,\n    };\n  },\n});\n","import { castArray } from 'lodash/fp';\nimport strapiUtils from '@strapi/utils';\n\nconst { isVisibleAttribute } = strapiUtils.contentTypes;\n/**\n * sumDraftCounts works recursively on the attributes of a model counting the\n * number of draft relations\n * These relations can be direct to this content type or contained within components/dynamic zones\n * @param {Object} entity containing the draft relation counts\n * @param {String} uid of the content type\n * @returns {Number} of draft relations\n */\nconst sumDraftCounts = (entity: any, uid: any): number => {\n  const model = strapi.getModel(uid);\n\n  return Object.keys(model.attributes).reduce((sum, attributeName) => {\n    const attribute: any = model.attributes[attributeName];\n    const value = entity[attributeName];\n    if (!value) {\n      return sum;\n    }\n\n    switch (attribute.type) {\n      case 'relation': {\n        if (isVisibleAttribute(model, attributeName)) {\n          return sum + value.count;\n        }\n        return sum;\n      }\n      case 'component': {\n        const compoSum = castArray(value).reduce((acc, componentValue) => {\n          return acc + sumDraftCounts(componentValue, attribute.component);\n        }, 0);\n        return sum + compoSum;\n      }\n      case 'dynamiczone': {\n        const dzSum = value.reduce((acc: any, componentValue: any) => {\n          return acc + sumDraftCounts(componentValue, componentValue.__component);\n        }, 0);\n        return sum + dzSum;\n      }\n      default:\n        return sum;\n    }\n  }, 0);\n};\n\nexport { sumDraftCounts };\n","import { omit, pipe } from 'lodash/fp';\n\nimport { contentTypes, errors, pagination } from '@strapi/utils';\nimport type { Core, Modules, UID } from '@strapi/types';\n\nimport { buildDeepPopulate, getDeepPopulate, getDeepPopulateDraftCount } from './utils/populate';\nimport { sumDraftCounts } from './utils/draft';\n\ntype DocService = Modules.Documents.ServiceInstance;\ntype DocServiceParams<TAction extends keyof DocService> = Parameters<DocService[TAction]>[0];\nexport type Document = Modules.Documents.Result<UID.ContentType>;\n\nconst { ApplicationError } = errors;\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypes.constants;\n\nconst omitPublishedAtField = omit(PUBLISHED_AT_ATTRIBUTE);\nconst omitIdField = omit('id');\n\nconst documentManager = ({ strapi }: { strapi: Core.Strapi }) => {\n  return {\n    async findOne(\n      id: string,\n      uid: UID.CollectionType,\n      opts: Omit<DocServiceParams<'findOne'>, 'documentId'> = {}\n    ) {\n      return strapi.documents(uid).findOne({ ...opts, documentId: id });\n    },\n\n    /**\n     * Find multiple (or all) locales for a document\n     */\n    async findLocales(\n      id: string | string[] | undefined,\n      uid: UID.CollectionType,\n      opts: {\n        populate?: Modules.Documents.Params.Pick<any, 'populate'>;\n        locale?: string | string[] | '*';\n        isPublished?: boolean;\n      }\n    ) {\n      // Will look for a specific locale by default\n      const where: any = {};\n\n      // Might not have an id if querying a single type\n      if (id) {\n        where.documentId = id;\n      }\n\n      // Search in array of locales\n      if (Array.isArray(opts.locale)) {\n        where.locale = { $in: opts.locale };\n      } else if (opts.locale && opts.locale !== '*') {\n        // Look for a specific locale, ignore if looking for all locales\n        where.locale = opts.locale;\n      }\n\n      // Published is passed, so we filter on it, otherwise we don't filter\n      if (typeof opts.isPublished === 'boolean') {\n        where.publishedAt = { $notNull: opts.isPublished };\n      }\n\n      return strapi.db.query(uid).findMany({ populate: opts.populate, where });\n    },\n\n    async findMany(opts: DocServiceParams<'findMany'>, uid: UID.CollectionType) {\n      const params = { ...opts, populate: getDeepPopulate(uid) } as typeof opts;\n      return strapi.documents(uid).findMany(params);\n    },\n\n    async findPage(opts: DocServiceParams<'findMany'>, uid: UID.CollectionType) {\n      const params = pagination.withDefaultPagination(opts || {}, {\n        maxLimit: 1000,\n      });\n\n      const [documents, total = 0] = await Promise.all([\n        strapi.documents(uid).findMany(params),\n        strapi.documents(uid).count(params),\n      ]);\n\n      return {\n        results: documents,\n        pagination: pagination.transformPagedPaginationInfo(params, total),\n      };\n    },\n\n    async create(uid: UID.CollectionType, opts: DocServiceParams<'create'> = {} as any) {\n      const populate = opts.populate ?? (await buildDeepPopulate(uid));\n      const params = { ...opts, status: 'draft' as const, populate };\n\n      return strapi.documents(uid).create(params);\n    },\n\n    async update(\n      id: Modules.Documents.ID,\n      uid: UID.CollectionType,\n      opts: Omit<DocServiceParams<'update'>, 'documentId'> = {} as any\n    ) {\n      const publishData = pipe(omitPublishedAtField, omitIdField)(opts.data || {});\n      const populate = opts.populate ?? (await buildDeepPopulate(uid));\n      const params = { ...opts, data: publishData, populate, status: 'draft' };\n\n      return strapi.documents(uid).update({ ...params, documentId: id });\n    },\n\n    async clone(\n      id: Modules.Documents.ID,\n      body: Partial<Modules.Documents.Params.Data.Input<UID.CollectionType>>,\n      uid: UID.CollectionType\n    ) {\n      const populate = await buildDeepPopulate(uid);\n      const params = {\n        data: omitIdField(body),\n        populate,\n      };\n\n      return strapi\n        .documents(uid)\n        .clone({ ...params, documentId: id })\n        .then((result) => result?.entries.at(0));\n    },\n\n    /**\n     *  Check if a document exists\n     */\n    async exists(uid: UID.CollectionType, id?: string) {\n      // Collection type\n      if (id) {\n        const count = await strapi.db.query(uid).count({ where: { documentId: id } });\n        return count > 0;\n      }\n\n      // Single type\n      const count = await strapi.db.query(uid).count();\n      return count > 0;\n    },\n\n    async delete(\n      id: Modules.Documents.ID,\n      uid: UID.CollectionType,\n      opts: Omit<DocServiceParams<'delete'>, 'documentId'> = {} as any\n    ) {\n      const populate = await buildDeepPopulate(uid);\n\n      await strapi.documents(uid).delete({\n        ...opts,\n        documentId: id,\n        populate,\n      });\n      return {};\n    },\n\n    // FIXME: handle relations\n    async deleteMany(\n      documentIds: Modules.Documents.ID[],\n      uid: UID.CollectionType,\n      opts: DocServiceParams<'findMany'> & { locale?: string } = {}\n    ) {\n      const deletedEntries = await strapi.db.transaction(async () => {\n        return Promise.all(documentIds.map(async (id) => this.delete(id, uid, opts)));\n      });\n\n      return { count: deletedEntries.length };\n    },\n\n    async publish(\n      id: Modules.Documents.ID,\n      uid: UID.CollectionType,\n      opts: Omit<DocServiceParams<'publish'>, 'documentId'> = {} as any\n    ) {\n      const populate = await buildDeepPopulate(uid);\n      const params = { ...opts, populate };\n\n      return strapi\n        .documents(uid)\n        .publish({ ...params, documentId: id })\n        .then((result) => result?.entries);\n    },\n\n    async publishMany(uid: UID.ContentType, documentIds: string[], locale?: string | string[]) {\n      return strapi.db.transaction(async () => {\n        const results = await Promise.all(\n          documentIds.map((documentId) => this.publish(documentId, uid, { locale }))\n        );\n\n        const publishedEntitiesCount = results.flat().filter(Boolean).length;\n        return publishedEntitiesCount;\n      });\n    },\n\n    async unpublishMany(\n      documentIds: Modules.Documents.ID[],\n      uid: UID.CollectionType,\n      opts: Omit<DocServiceParams<'unpublish'>, 'documentId'> = {} as any\n    ) {\n      const unpublishedEntries = await strapi.db.transaction(async () => {\n        return Promise.all(\n          documentIds.map((id) =>\n            strapi\n              .documents(uid)\n              .unpublish({ ...opts, documentId: id })\n              .then((result) => result?.entries)\n          )\n        );\n      });\n\n      const unpublishedEntitiesCount = unpublishedEntries.flat().filter(Boolean).length;\n\n      // Return the number of unpublished entities\n      return { count: unpublishedEntitiesCount };\n    },\n\n    async unpublish(\n      id: Modules.Documents.ID,\n      uid: UID.CollectionType,\n      opts: Omit<DocServiceParams<'unpublish'>, 'documentId'> = {} as any\n    ) {\n      const populate = await buildDeepPopulate(uid);\n      const params = { ...opts, populate };\n\n      return strapi\n        .documents(uid)\n        .unpublish({ ...params, documentId: id })\n        .then((result) => result?.entries.at(0));\n    },\n\n    async discardDraft(\n      id: Modules.Documents.ID,\n      uid: UID.CollectionType,\n      opts: Omit<DocServiceParams<'discardDraft'>, 'documentId'> = {} as any\n    ) {\n      const populate = await buildDeepPopulate(uid);\n      const params = { ...opts, populate };\n\n      return strapi\n        .documents(uid)\n        .discardDraft({ ...params, documentId: id })\n        .then((result) => result?.entries.at(0));\n    },\n\n    async countDraftRelations(id: string, uid: UID.ContentType, locale: string) {\n      const { populate, hasRelations } = getDeepPopulateDraftCount(uid);\n\n      if (!hasRelations) {\n        return 0;\n      }\n      const document = await strapi.documents(uid).findOne({ documentId: id, populate, locale });\n      if (!document) {\n        throw new ApplicationError(\n          `Unable to count draft relations, document with id ${id} and locale ${locale} not found`\n        );\n      }\n\n      return sumDraftCounts(document, uid);\n    },\n\n    async countManyEntriesDraftRelations(\n      documentIds: Modules.Documents.ID[],\n      uid: UID.CollectionType,\n      locale: string | string[]\n    ) {\n      const { populate, hasRelations } = getDeepPopulateDraftCount(uid);\n\n      if (!hasRelations) {\n        return 0;\n      }\n\n      let localeFilter = {};\n      if (locale) {\n        localeFilter = Array.isArray(locale) ? { locale: { $in: locale } } : { locale };\n      }\n\n      const entities = await strapi.db.query(uid).findMany({\n        populate,\n        where: {\n          documentId: { $in: documentIds },\n          ...localeFilter,\n        },\n      });\n\n      const totalNumberDraftRelations: number = entities!.reduce(\n        (count: number, entity: Document) => sumDraftCounts(entity, uid) + count,\n        0\n      );\n\n      return totalNumberDraftRelations;\n    },\n  };\n};\n\nexport type DocumentManagerService = typeof documentManager;\n\nexport default documentManager;\n","import components from './components';\nimport contentTypes from './content-types';\nimport dataMapper from './data-mapper';\nimport fieldSizes from './field-sizes';\nimport metrics from './metrics';\nimport permissionChecker from './permission-checker';\nimport permission from './permission';\nimport populateBuilder from './populate-builder';\nimport uid from './uid';\nimport history from '../history';\nimport documentMetadata from './document-metadata';\nimport documentManager from './document-manager';\n\nexport default {\n  components,\n  'content-types': contentTypes,\n  'data-mapper': dataMapper,\n  'document-metadata': documentMetadata,\n  'document-manager': documentManager,\n  'field-sizes': fieldSizes,\n  metrics,\n  'permission-checker': permissionChecker,\n  permission,\n  'populate-builder': populateBuilder,\n  uid,\n  ...(history.services ? history.services : {}),\n};\n","import register from './register';\nimport bootstrap from './bootstrap';\nimport destroy from './destroy';\nimport routes from './routes';\nimport policies from './policies';\nimport controllers from './controllers';\nimport services from './services';\n\nexport default () => {\n  return {\n    register,\n    bootstrap,\n    destroy,\n    controllers,\n    routes,\n    policies,\n    services,\n  };\n};\n"],"names":["getService","strapi","permissionChecker","getContentManagerService","pagination","controllers","getDeepPopulate","uid","isVisible","contentTypes","acc","data","services","routes","action","yup","contentTypesUtils","PUBLISHED_AT_ATTRIBUTE","isHidden","isRelation","schema","key","isVisibleAttribute","path","body","documentMetadata","documentManager","isNil","document","components","relations","isComponent","mainField","res","keys","storeUtils","conf","intersection","difference","configurationService","ApplicationError","populate","count","fieldSizes","populateBuilder"],"mappings":";;;;;;;;;AAQA,MAAMA,eAAa,CAA+B,SAA6C;AAC7F,SAAO,OAAO,OAAO,iBAAiB,EAAE,QAAQ,IAAc;AAChE;ACNA,SAAS,WAA4CC,SAAqB,MAAS;AAEjF,SAAOA,QAAO,QAAQ,2BAA2B,IAAI,EAAE;AACzD;ACJA,MAAM,8BAA8B,IACjC,OAAO,EACP,MAAM;AAAA,EACL,aAAa,IAAI,OAAS,EAAA,KAAA,EAAO,SAAS;AAC5C,CAAC,EACA,SAAS;AAEC,MAAA,yBAAyB,kBAAkB,2BAA2B;ACEnF,MAAM,qBAAqB,CAAC,EAAE,MAAM,eAA6C;AAC/E,MAAI,aAAa;AACjB,MAAI,iBAAiB;AAErB,MAAI,MAAM;AACF,UAAA,aAAa,SAAS,MAAM,EAAE;AACvB,iBAAA,SAAS,MAAM,EAAE;AAE9B,QAAI,CAAC,OAAO,MAAM,UAAU,KAAK,cAAc,GAAG;AACnC,mBAAA;AAAA,IACf;AAAA,EACF;AAEA,MAAI,UAAU;AACN,UAAA,iBAAiB,SAAS,UAAU,EAAE;AAExC,QAAA,CAAC,OAAO,MAAM,cAAc,KAAK,kBAAkB,KAAK,kBAAkB,KAAK;AAChE,uBAAA;AAAA,IACnB;AAAA,EACF;AAEA,SAAO,EAAE,MAAM,YAAY,UAAU,eAAe;AACtD;AAEA,MAAM,iCAAiC,CAAC,EAAE,QAAAA,cAAsC;AACvE,SAAA;AAAA,IACL,MAAM,SAAS,KAAK;AACZ,YAAA,iBAAiB,IAAI,MAAM;AACjC,YAAM,eAAeA,QAAO,SAAS,cAAc,GAAG,SAAS;AAE3D,UAAA,gBAAgB,CAAC,gBAAgB;AAC7B,cAAA,IAAI,OAAO,eAAe,yBAAyB;AAAA,MAC3D;AAEA,UAAI,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,IAAI,MAAM,aAAa;AACzD,cAAA,IAAI,OAAO,eAAe,yCAAyC;AAAA,MAC3E;AAMA,YAAMC,qBAAoBC,aAAyB,oBAAoB,EAAE,OAAO;AAAA,QAC9E,aAAa,IAAI,MAAM;AAAA,QACvB,OAAO,IAAI,MAAM;AAAA,MAAA,CAClB;AAEG,UAAAD,mBAAkB,OAAO,QAAQ;AACnC,eAAO,IAAI;MACb;AAEA,YAAM,QACJ,MAAMA,mBAAkB,cAAc,IAAI,KAAK;AAE3C,YAAA,EAAE,SAAS,YAAAE,gBAAe,MAAM,WAAWH,SAAQ,SAAS,EAAE,iBAAiB;AAAA,QACnF,OAAO;AAAA,UACL,GAAG;AAAA,UACH,GAAG,mBAAmB,EAAE,MAAM,MAAM,MAAM,UAAU,MAAM,UAAU;AAAA,QACtE;AAAA,QACA,OAAO,EAAE,aAAa,IAAI,MAAM,YAAY;AAAA,MAAA,CAC7C;AAEK,YAAA,mBAAmB,MAAM,MAAM;AAAA,QACnC;AAAA,QACA,OAAO,YAA6E;AAC3E,iBAAA;AAAA,YACL,GAAG;AAAA,YACH,MAAM,MAAMC,mBAAkB,eAAe,QAAQ,IAAI;AAAA,YACzD,WAAW,QAAQ,YACf,KAAK,CAAC,MAAM,aAAa,YAAY,YAAY,OAAO,GAAG,QAAQ,SAAS,IAC5E;AAAA,UAAA;AAAA,QAER;AAAA,MAAA;AAGK,aAAA;AAAA,QACL,MAAM;AAAA,QACN,MAAM,EAAE,YAAAE,YAAW;AAAA,MAAA;AAAA,IAEvB;AAAA,IAEA,MAAM,eAAe,KAAK;AACxB,YAAM,UAAU,IAAI;AAEd,YAAA,uBAAuB,QAAQ,MAAM,yBAAyB;AAEpE,YAAMF,qBAAoBC,aAAyB,oBAAoB,EAAE,OAAO;AAAA,QAC9E,aAAa,IAAI,MAAM;AAAA,QACvB,OAAO,QAAQ,KAAK;AAAA,MAAA,CACrB;AAEG,UAAAD,mBAAkB,OAAO,UAAU;AAC/B,cAAA,IAAI,OAAO;MACnB;AAEA,YAAM,mBAAmB,MAAM,WAAWD,SAAQ,SAAS,EAAE;AAAA,QAC3D,QAAQ,OAAO;AAAA,MAAA;AAGV,aAAA;AAAA,QACL,MAAM,EAAE,YAAY,iBAAiB,WAAW;AAAA,MAAA;AAAA,IAEpD;AAAA,EAAA;AAEJ;ACjHO,MAAMI,gBAAc;AAAA,EACzB,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAKrB;ACTO,MAAM,sBAAsB;AAC5B,MAAM,mBAAmB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;ACAA,MAAM,yBAAyB;AAOxB,MAAM,qBAAqB,CAAC,EAAE,QAAAJ,cAAsC;AAKnE,QAAA,0BAA0B,CAC9B,yBACA,gCACG;AAEH,UAAM,uCAAuC;AAAA,MAC3C;AAAA,MACA;AAAA,IAAA;AAGI,UAAA,qCAAqC,CACzC,UACA,WACG;AACH,aAAO,SAAS;AAAA,QACd,CAAC,0BAA0B,YAAY;AACZ,mCAAA,OAAO,IAAI,OAAO,OAAO;AAE3C,iBAAA;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MAAA;AAAA,IACH;AAGI,UAAA,oBAAoB,OAAO,KAAK,uBAAuB;AACvD,UAAA,kCAAkC,OAAO,KAAK,oCAAoC;AAElF,UAAA,sBAAsB,WAAW,iCAAiC,iBAAiB;AACzF,UAAM,QAAQ;AAAA,MACZ;AAAA,MACA;AAAA,IAAA;AAGI,UAAA,kBAAkB,WAAW,mBAAmB,+BAA+B;AAC/E,UAAA,UAAU,mCAAmC,iBAAiB,uBAAuB;AAEpF,WAAA,EAAE,OAAO;EAAQ;AASpB,QAAA,0BAA0B,OAC9B,qBACA,cACG;AACC,QAAA,MAAM,QAAQ,mBAAmB,GAAG;AACtC,UAAI,oBAAoB,WAAW;AAAU,eAAA;AAEvC,YAAA,8BAA8B,MAAM,QAAQ;AAAA,QAChD,oBAAoB,IAAI,CAAC,aAAa;AACpC,iBAAOA,QAAO,UAAU,UAAU,MAAM,EAAE,QAAQ;AAAA,YAChD,YAAY,SAAS;AAAA,YACrB,QAAQ,SAAS,UAAU;AAAA,UAAA,CAC5B;AAAA,QAAA,CACF;AAAA,MAAA;AAGH,aAAO,4BAA4B;AAAA,QACjC,CAAC,aAAa,aAAa;AAAA,MAAA;AAAA,IAE/B;AAEA,WAAOA,QAAO,UAAU,UAAU,MAAM,EAAE,QAAQ;AAAA,MAChD,YAAY,oBAAoB;AAAA,MAChC,QAAQ,oBAAoB,UAAU;AAAA,IAAA,CACvC;AAAA,EAAA;AASG,QAAA,uBAAuB,OAC3B,qBACA,cACG;AACH,QAAI,UAAU,UAAU;AAChB,YAAA,2BAA2B,MAAM,QAAQ;AAAA;AAAA,QAE7C,oBAAoB,IAAI,CAAC,UAAU;AACjC,iBAAOA,QAAO,GAAG,MAAM,qBAAqB,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,MAAM,GAAA,EAAM,CAAA;AAAA,QAAA,CAClF;AAAA,MAAA;AAGH,aAAO,yBAAyB,OAAO,CAAC,UAAU,SAAS,IAAI;AAAA,IACjE;AAEA,WAAOA,QAAO,GACX,MAAM,qBAAqB,EAC3B,QAAQ,EAAE,OAAO,EAAE,IAAI,oBAAoB,GAAA,EAAM,CAAA;AAAA,EAAA;AAGtD,QAAM,iBAAiBA,QAAO,OAAO,MAAM,GAAG,QAAQ,SAAS;AAC/D,QAAM,yBAAyBA,QAAO,OAAO,MAAM,GAAG,QAAQ,eAAe;AAE7E,QAAM,mBAAmB,YAAa,iBAAiB,eAAe,qBAAqB;AAE3F,QAAM,yBAAyB,CAAC,UAC9B,yBAAyB,uBAAuB,uBAAuB,KAAK,IAAI;AAOlF,QAAM,sBAAsB,YAEtB;AACJ,QAAI,CAAC;AAAgB,aAAO;AAE5B,UAAM,UAAW,MAAM,eAAe,KAAA,KAAW,CAAA;AACjD,WAAO,QAAQ;AAAA,MACb,CACE,KACA,WACG;AACC,YAAA,OAAO,IAAI,IAAI,EAAE,MAAM,OAAO,MAAM,MAAM,OAAO;AAE9C,eAAA;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IAAA;AAAA,EACH;AAQF,QAAM,mBAAmB,MAAM;AAC7B,UAAM,gBAAgBA,QAAO,GAAG,SAAS,IAAI,qBAAqB;AAClE,UAAM,uBACJ,OAAO,kBAAkB,YAAY,eAAe,QAAQ;AAC9D,UAAM,oBAA4BA,QAAO,OAAO,IAAI,6BAA6B;AAG7E,QAAA,qBAAqB,oBAAoB,sBAAsB;AAC1D,aAAA;AAAA,IACT;AAGO,WAAA,KAAK,IAAI,sBAAsB,sBAAsB;AAAA,EAAA;AAGxD,QAAA,mBAAmB,OACvB,gBACA,aACG;AACH,UAAM,0BAA0BA,QAAO,OAAO,iBAAiB,EAAE,QAAQ,mBAAmB;AAC5F,UAAM,OAAO,MAAM,wBAAwB,YAAY,gBAAgB,QAAQ;AAE/E,WAAO,wBAAwB,UAAU,UAAU,KAAK,eAAe;AAAA,EAAA;AAWzE,QAAMK,mBAAkB,CAACC,MAAiB,oBAAoB,UAAU;AAChE,UAAA,QAAQN,QAAO,SAASM,IAAG;AACjC,UAAM,aAAa,OAAO,QAAQ,MAAM,UAAU;AAC5C,UAAA,gBAAgB,oBAAoB,WAAW;AAErD,WAAO,WAAW,OAAO,CAAC,KAAU,CAAC,eAAe,SAAS,MAAM;AACjE,cAAQ,UAAU,MAAM;AAAA,QACtB,KAAK,YAAY;AAEf,gBAAM,kBAAkB,UAAU,SAAS,YAAY,EAAE,WAAW,OAAO;AAC3E,cAAI,iBAAiB;AACnB;AAAA,UACF;AAEA,gBAAMC,aAAYC,eAAa,mBAAmB,OAAO,aAAa;AACtE,cAAID,YAAW;AACT,gBAAA,aAAa,IAAI,EAAE,CAAC,aAAa,GAAG,CAAC,cAAc,UAAU,aAAa;UAChF;AACA;AAAA,QACF;AAAA,QAEA,KAAK,SAAS;AACR,cAAA,aAAa,IAAI,EAAE,CAAC,aAAa,GAAG,CAAC,IAAI;AAC7C;AAAA,QACF;AAAA,QAEA,KAAK,aAAa;AACV,gBAAA,WAAWF,iBAAgB,UAAU,SAAS;AAChD,cAAA,aAAa,IAAI,EAAE;AACvB;AAAA,QACF;AAAA,QAEA,KAAK,eAAe;AAElB,gBAAM,uBAAuB,UAAU,cAAc,CAAI,GAAA;AAAA,YACvD,CAACI,MAAU,iBAAgC;AACzCA,mBAAI,YAAY,IAAI,EAAE,UAAUJ,iBAAgB,YAAY;AACrDI,qBAAAA;AAAAA,YACT;AAAA,YACA,CAAC;AAAA,UAAA;AAGH,cAAI,aAAa,IAAI,EAAE,IAAI,oBAAoB;AAC/C;AAAA,QACF;AAAA,MAGF;AAEO,aAAA;AAAA,IACT,GAAG,CAAE,CAAA;AAAA,EAAA;AAOD,QAAA,qBAAqB,OAAO,WAAyD;AACzF,WACE,OAEG,MAAM,GAAG,EAAE,EACX;AAAA,MACC,OAAO,4BAA4B,UAAU;AAC3C,cAAM,sBAAsB,MAAM;AAGlC,YAAI,CAAC,OAAO;AACH,iBAAA;AAAA,QACT;AAEA,cAAM,eAAe,MAAMT,QAAO,GAC/B,MAAM,qBAAqB,EAC3B,QAAQ,EAAE,OAAO,EAAE,IAAI,MAAM,GAAA,EAAM,CAAA;AAEtC,YAAI,cAAc;AACI,8BAAA,QAAQ,KAAK,YAAY;AAAA,QAAA,OACxC;AAEL,8BAAoB,KAAK,gBAAgB;AAAA,QAC3C;AAEO,eAAA;AAAA,MACT;AAAA,MACA,QAAQ,QAA0B;AAAA,QAChC,SAAS,CAAC;AAAA,QACV,MAAM,EAAE,cAAc,EAAE;AAAA,MAAA,CACzB;AAAA,IAAA;AAAA,EACH;AAQA,QAAA,uBAAuB,OAC3B,QAIA,oBAC8B;AAC9B,WACE,OAEG,MAAM,GAAG,EAAE,EACX;AAAA,MACC,OAAO,4BAA4B,UAAU;AAC3C,cAAM,sBAAsB,MAAM;AAGlC,YAAI,CAAC,OAAO;AACH,iBAAA;AAAA,QACT;AAEA,cAAM,eAAe,MAAMA,QACxB,UAAU,gBAAgB,MAAM,EAChC,QAAQ,EAAE,YAAY,MAAM,YAAY,QAAQ,MAAM,UAAU,QAAW;AAE9E,YAAI,cAAc;AAChB,8BAAoB,QAAQ,KAAK;AAAA,YAC/B,GAAG;AAAA,YACH,QAAQ,MAAM,iBAAiB,gBAAgB,QAAQ,YAAY;AAAA,UAAA,CACpE;AAAA,QAAA,OACI;AAEL,8BAAoB,KAAK,gBAAgB;AAAA,QAC3C;AAEO,eAAA;AAAA,MACT;AAAA,MACA,QAAQ,QAA0B;AAAA,QAChC,SAAS,CAAC;AAAA,QACV,MAAM,EAAE,cAAc,EAAE;AAAA,MAAA,CACzB;AAAA,IAAA;AAAA,EACH;AAIC,SAAA;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,iBAAAK;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ;ACrUA,MAAM,uBAAuB,CAAC,EAAE,QAAAL,cAAsC;AACpE,QAAM,QAAQA,QAAO,GAAG,MAAM,mBAAmB;AACjD,QAAM,eAAe,mBAAmB,EAAE,QAAAA,QAAQ,CAAA;AAE3C,SAAA;AAAA,IACL,MAAM,cAAc,oBAA0D;AAC5E,YAAM,MAAM,OAAO;AAAA,QACjB,MAAM;AAAA,UACJ,GAAG;AAAA,UACH,+BAAe,KAAK;AAAA,UACpB,WAAWA,QAAO,eAAe,IAAI,GAAG,OAAO,KAAK;AAAA,QACtD;AAAA,MAAA,CACD;AAAA,IACH;AAAA,IAEA,MAAM,iBAAiB,QAGpB;AACD,YAAM,QAAQA,QAAO,SAAS,OAAO,MAAM,WAAW;AAChD,YAAA,yBAAyB,aAAa,uBAAuB,KAAK;AAClE,YAAA,gBAAgB,MAAM,aAAa;AAEzC,UAAI,SAAS;AACb,UAAI,wBAAwB;AACjB,iBAAA,OAAO,MAAM,UAAU;AAAA,MAClC;AAEM,YAAA,CAAC,EAAE,SAAS,YAAAG,YAAA,GAAc,gBAAgB,IAAI,MAAM,QAAQ,IAAI;AAAA,QACpE,MAAM,SAAS;AAAA,UACb,GAAG,OAAO;AAAA,UACV,OAAO;AAAA,YACL,MAAM;AAAA,cACJ,EAAE,aAAa,OAAO,MAAM,YAAY;AAAA,cACxC,GAAI,OAAO,MAAM,aAAa,CAAC,EAAE,mBAAmB,OAAO,MAAM,WAAY,CAAA,IAAI,CAAC;AAAA,cAClF,GAAI,SAAS,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC;AAAA,YAC/B;AAAA,UACF;AAAA,UACA,UAAU,CAAC,WAAW;AAAA,UACtB,SAAS,CAAC,EAAE,WAAW,QAAQ;AAAA,QAAA,CAChC;AAAA,QACD,aAAa,oBAAoB;AAAA,MAAA,CAClC;AACK,YAAA,yBAAyB,OAC7B,UAC0C;AAC1C,cAAM,qBAAqB,MAAM,OAAO,QAAQ,MAAM,MAAM,EAAE;AAAA,UAC5D,OAAO,0BAA0B,CAAC,cAAc,eAAe,MAAM;AAC7D,kBAAA,iBAAiB,MAAM,KAAK,YAAY;AAC9C,kBAAM,kBAAkB,MAAM,QAAQ,cAAc,IAChD,iBACA,CAAC,cAAc;AAEf,gBAAA,gBAAgB,SAAS,SAAS;AACpC,oBAAMF,qBAAoBC,aAAyB,oBAAoB,EAAE,OAAO;AAAA,gBAC9E,aAAa,OAAO,MAAM;AAAA,gBAC1B,OAAO;AAAA,cAAA,CACR;AAED,oBAAM,WAAW,MAAM,aAAa,mBAAmB,eAAe;AAChE,oBAAA,mBAAmB,MAAM,QAAQ;AAAA,gBACrC,SAAS,QAAQ,IAAI,CAAC,UAAUD,mBAAkB,eAAe,KAAK,CAAC;AAAA,cAAA;AAGlE,qBAAA;AAAA,gBACL,GAAI,MAAM;AAAA,gBACV,CAAC,YAAY,GAAG;AAAA,kBACd,SAAS;AAAA,kBACT,MAAM,SAAS;AAAA,gBACjB;AAAA,cAAA;AAAA,YAEJ;AAIE,gBAAA,gBAAgB,SAAS,cACzB,gBAAgB,aAAa,gBAC7B,gBAAgB,aAAa,eAC7B;AAKI,kBAAA,gBAAgB,WAAW,eAAe;AACtC,sBAAA,aAAa,MAAM,QAAQ;AAAA,kBAC/B,gBAAgB,IAAI,CAAC,mBAAmB;AACtC,wBAAI,kBAAkB,MAAM;AACnB,6BAAA;AAAA,oBACT;AAEA,2BAAOD,QACJ,MAAM,aAAa,EACnB,QAAQ,EAAE,OAAO,EAAE,IAAI,eAAe,GAAG,EAAG,CAAA;AAAA,kBAAA,CAChD;AAAA,gBAAA;AAGI,uBAAA;AAAA,kBACL,GAAI,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAMV,CAAC,YAAY,GAAG;AAAA,gBAAA;AAAA,cAEpB;AAEA,oBAAMC,qBAAoBC,aAAyB,oBAAoB,EAAE,OAAO;AAAA,gBAC9E,aAAa,OAAO,MAAM;AAAA,gBAC1B,OAAO,gBAAgB;AAAA,cAAA,CACxB;AAEK,oBAAA,WAAW,MAAM,aAAa;AAAA,gBAClC;AAAA,gBACA;AAAA,cAAA;AAEI,oBAAA,mBAAmB,MAAM,QAAQ;AAAA,gBACrC,SAAS,QAAQ,IAAI,CAAC,UAAUD,mBAAkB,eAAe,KAAK,CAAC;AAAA,cAAA;AAGlE,qBAAA;AAAA,gBACL,GAAI,MAAM;AAAA,gBACV,CAAC,YAAY,GAAG;AAAA,kBACd,SAAS;AAAA,kBACT,MAAM,SAAS;AAAA,gBACjB;AAAA,cAAA;AAAA,YAEJ;AAGO,mBAAA;AAAA,UACT;AAAA,UACA,QAAQ,QAAQ,MAAM,IAAI;AAAA,QAAA;AAGrB,eAAA;AAAA,MAAA;AAGH,YAAA,mBAAmB,MAAM,QAAQ;AAAA,QACpC,QAAwC,IAAI,OAAO,WAAW;AACtD,iBAAA;AAAA,YACL,GAAG;AAAA,YACH,MAAM,MAAM,uBAAuB,MAAM;AAAA,YACzC,MAAM;AAAA,cACJ,mBAAmB,aAAa;AAAA,gBAC9B,OAAO;AAAA,gBACPD,QAAO,SAAS,OAAO,MAAM,WAAW,EAAE;AAAA,cAC5C;AAAA,YACF;AAAA,YACA,QAAQ,OAAO,SAAS,iBAAiB,OAAO,MAAM,IAAI;AAAA,UAAA;AAAA,QAC5D,CACD;AAAA,MAAA;AAGI,aAAA;AAAA,QACL,SAAS;AAAA,QACT,YAAAG;AAAA,MAAA;AAAA,IAEJ;AAAA,IAEA,MAAM,eAAe,WAAoB;AACjC,YAAA,UAAU,MAAM,MAAM,QAAQ,EAAE,OAAO,EAAE,IAAI,UAAU,EAAA,CAAG;AAChE,YAAM,8BAA8BH,QAAO,SAAS,QAAQ,WAAW,EAAE;AACzE,YAAM,aAAa,aAAa;AAAA,QAC9B,QAAQ;AAAA,QACR;AAAA,MAAA;AAIF,YAAM,6BAA6B,OAAO,KAAK,WAAW,KAAK,EAAE;AAAA,QAC/D,CAAC,aAAa,aAAa;AACzB,sBAAY,QAAQ,IAAI;AACjB,iBAAA;AAAA,QACT;AAAA;AAAA,QAEA,gBAAgB,QAAQ,IAAI;AAAA,MAAA;AAE9B,YAAM,4BAA4B;AAAA,QAChC;AAAA,QACA;AAAA,MAAA;AAIF,YAAM,UAAU,MAAM,OAAO,OAAO,QAAQ,yBAAyB,CAAC;AACtE,YAAM,8BAA8B,MAAM;AAAA,QACxC,OACE,4BACA,CAAC,MAAM,SAAS,MACb;AACG,gBAAA,sBAAsB,QAAQ,KAAK,IAAI;AAC7C,cAAI,CAAC,qBAAqB;AACjB,mBAAA;AAAA,UACT;AAEA,cACE,UAAU,SAAS;AAAA,UAEnB,UAAU,aAAa,gBACvB,UAAU,aAAa,eACvB;AACA,kBAAMU,QAAO,MAAM,aAAa,wBAAwB,qBAAqB,SAAS;AACtF,uCAA2B,IAAI,IAAIA;AAAAA,UACrC;AAEI,cAAA,UAAU,SAAS,SAAS;AAC9B,kBAAMA,QAAO,MAAM,aAAa,qBAAqB,qBAAqB,SAAS;AACnF,uCAA2B,IAAI,IAAIA;AAAAA,UACrC;AAEO,iBAAA;AAAA,QACT;AAAA;AAAA,QAEA,gBAAgB,0BAA0B;AAAA,MAAA;AAGtC,YAAA,OAAO,KAAK,CAAC,MAAM,GAAG,OAAO,KAAK,WAAW,OAAO,CAAC,GAAG,2BAA2B;AACzF,YAAM,mBAAmB,MAAMV,QAAO,UAAU,QAAQ,WAAW,EAAE,OAAO;AAAA,QAC1E,YAAY,QAAQ;AAAA,QACpB,QAAQ,QAAQ;AAAA,QAChB;AAAA,MAAA,CACD;AAED,UAAI,CAAC,kBAAkB;AACf,cAAA,IAAI,OAAO,iBAAiB,2BAA2B;AAAA,MAC/D;AAEO,aAAA;AAAA,IACT;AAAA,EAAA;AAEJ;ACtOA,MAAM,6BAA6B,CACjC,YAIG;AAEC,MAAA,CAAC,OAAO,eAAe,IAAA,GAAO,QAAQ,IAAI,WAAW,kBAAkB,GAAG;AACrE,WAAA;AAAA,EACT;AAGA,MACE,QAAQ,WAAW,YACnB,QAAQ,WAAW,YACnB,QAAQ,WAAW,WACnB,QAAQ,WAAW,aACnB,QAAQ,WAAW,eACnB,QAAQ,WAAW,gBACnB;AACO,WAAA;AAAA,EACT;AASE,MAAA,QAAQ,WAAW,YACnB,OAAO,eAAe,IAAI,GAAG,QAAQ,IAAI,SAAS,kBAAkB,GACpE;AACO,WAAA;AAAA,EACT;AAGA,MAAI,CAAC,QAAQ,YAAY,IAAI,WAAW,OAAO,GAAG;AACzC,WAAA;AAAA,EACT;AAEO,SAAA;AACT;AAOA,MAAM,aAAa,CAACM,SAA4B;AAC9C,QAAM,mBAAmB,OAAO,SAASA,IAAG,EAAE;AAG9C,QAAM,oBAAoB,OAAO,KAAK,gBAAgB,EAAE;AAAA,IACtD,CAAC,yBAAyB,QAAQ;AAC1B,YAAA,cAAc,iBAAiB,GAAG;AAEpC,UAAA,YAAY,SAAS,aAAa;AACpC,cAAM,kBAAkB,OAAO,SAAS,YAAY,SAAS,EAAE;AACxD,eAAA;AAAA,UACL,GAAG;AAAA,UACH,CAAC,YAAY,SAAS,GAAG;AAAA,QAAA;AAAA,MAE7B;AAGO,aAAA;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EAAA;AAGI,SAAA;AAAA,IACL,QAAQ,KAAK,kBAAkB,gBAAgB;AAAA,IAC/C;AAAA,EAAA;AAEJ;AAEA,MAAM,0BAA0B,CAAC,EAAE,QAAAN,cAAsC;AACvE,QAAM,QAGF;AAAA,IACF,kBAAkB;AAAA,IAClB,eAAe;AAAA,EAAA;AAGjB,QAAM,eAAe,mBAAmB,EAAE,QAAAA,QAAQ,CAAA;AAE3C,SAAA;AAAA,IACL,MAAM,YAAY;AAEhB,UAAI,MAAM,eAAe;AACvB;AAAA,MACF;AAEAA,cAAO,UAAU,IAAI,OAAO,SAAS,SAAS;AACtC,cAAA,SAAU,MAAM;AAElB,YAAA,CAAC,2BAA2B,OAAO,GAAG;AACjC,iBAAA;AAAA,QACT;AAGM,cAAA,aACJ,QAAQ,WAAW,YAAY,QAAQ,WAAW,UAC9C,OAAO,aACP,QAAQ,OAAO;AAGf,cAAA,gBAAgB,MAAM,aAAa;AACzC,cAAM,UAAU,UAAU,QAAQ,QAAQ,UAAU,aAAa;AAC7D,YAAA,CAAC,QAAQ,QAAQ;AACZ,iBAAA;AAAA,QACT;AAGM,cAAAM,OAAM,QAAQ,YAAY;AAC1B,cAAA,UAAU,WAAWA,IAAG;AACxB,cAAA,QAAQN,QAAO,SAASM,IAAG;AAE3B,cAAA,yBAAyB,aAAa,uBAAuB,KAAK;AAGxE,cAAM,gBAAgB,MAAMN,QAAO,GAAG,MAAMM,IAAG,EAAE,SAAS;AAAA,UACxD,OAAO;AAAA,YACL;AAAA,YACA,GAAI,yBAAyB,EAAE,QAAQ,EAAE,KAAK,QAAU,EAAA,IAAI,CAAC;AAAA,YAC7D,GAAIE,eAAa,mBAAmBR,QAAO,aAAaM,IAAG,CAAC,IACxD,EAAE,aAAa,KAAK,IACpB,CAAC;AAAA,UACP;AAAA,UACA,UAAU,aAAa;AAAA,YAAgBA;AAAA,YAAK;AAAA;AAAA,UAA8B;AAAA,QAAA,CAC3E;AAED,cAAMN,QAAO,GAAG,YAAY,OAAO,EAAE,eAAe;AAIlD,mBAAS,YAAY;AACnB,uBAAW,SAAS,eAAe;AACjC,oBAAM,SAAS,MAAM,aAAa,iBAAiBM,MAAK,KAAK;AAE7D,oBAAM,WAAWN,SAAQ,SAAS,EAAE,cAAc;AAAA,gBAChD,aAAaM;AAAA,gBACb,MAAM,KAAK,kBAAkB,KAAK;AAAA,gBAClC,mBAAmB;AAAA,gBACnB,QAAQ,MAAM;AAAA,gBACd;AAAA,gBACA,GAAG;AAAA,cAAA,CACJ;AAAA,YACH;AAAA,UAAA,CACD;AAAA,QAAA,CACF;AAEM,eAAA;AAAA,MAAA,CACR;AAGK,YAAA,mBAAmB,YAAY,aAAa,MAAM;AACtD,cAAM,8BAA8B,aAAa,iBAAA,IAAqB,KAAK,KAAK,KAAK;AACrF,cAAM,iBAAiB,IAAI,KAAK,KAAK,IAAA,IAAQ,2BAA2B;AAExEN,gBAAO,GAAG,MAAM,mBAAmB,EAAE,WAAW;AAAA,UAC9C,OAAO;AAAA,YACL,YAAY;AAAA,cACV,KAAK,eAAe,YAAY;AAAA,YAClC;AAAA,UACF;AAAA,QAAA,CACD;AAAA,MAAA,CACF;AAED,YAAM,gBAAgB;AAAA,IACxB;AAAA,IAEA,MAAM,UAAU;AACd,UAAI,MAAM,kBAAkB;AAC1B,cAAM,iBAAiB;MACzB;AAAA,IACF;AAAA,EAAA;AAEJ;AChMO,MAAMW,aAAW;AAAA,EACtB,SAAS;AAAA,EACT,YAAY;AACd;ACLA,MAAM,OAAO,EAAE,YAAY,mBAAmB,MAAM,QAAQ;AAE5D,MAAM,uBAA8D;AAAA,EAClE,MAAM;AAAA,EACN,QAAQ;AAAA,IACN;AAAA,MACE,QAAQ;AAAA,MACR;AAAA,MACA,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC,6BAA6B;AAAA,MAC1C;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR;AAAA,MACA,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC,6BAA6B;AAAA,MAC1C;AAAA,IACF;AAAA,EACF;AACF;ACnBO,MAAMC,WAAS;AAAA,EACpB,mBAAmB;AACrB;ACNA,MAAM,iBAAwB;AAAA,EAC5B,KAAK;AAAA,EACL,WAAW;AAAA,EACX,cAAc;AAAA,EACd,YAAY;AAAA,IACV,IAAI;AAAA,MACF,MAAM;AAAA,IACR;AAAA,IACA,aAAa;AAAA,MACX,MAAM;AAAA,MACN,QAAQ,EAAE,aAAa,KAAK;AAAA,IAC9B;AAAA,IACA,mBAAmB;AAAA,MACjB,MAAM;AAAA;AAAA,MAEN,QAAQ,EAAE,aAAa,MAAM;AAAA,IAC/B;AAAA,IACA,QAAQ;AAAA,MACN,MAAM;AAAA,IACR;AAAA,IACA,QAAQ;AAAA,MACN,MAAM;AAAA,MACN,MAAM,CAAC,SAAS,aAAa,UAAU;AAAA,IACzC;AAAA,IACA,MAAM;AAAA,MACJ,MAAM;AAAA,IACR;AAAA,IACA,QAAQ;AAAA,MACN,MAAM;AAAA,IACR;AAAA,IACA,WAAW;AAAA,MACT,MAAM;AAAA,MACN,SAAS,MAAM,oBAAI,KAAK;AAAA,IAC1B;AAAA;AAAA;AAAA,IAGA,WAAW;AAAA,MACT,MAAM;AAAA,MACN,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,cAAc;AAAA,IAChB;AAAA,EACF;AACF;ACnCA,MAAM,aAAa,MAAoC;AACrD,MAAI,OAAO,GAAG,SAAS,UAAU,qBAAqB,GAAG;AAChD,WAAA;AAAA,MACL,SAAS,EAAE,QAAAZ,WAAU;AACnBA,gBAAO,IAAI,QAAQ,EAAE,IAAI,cAAc;AAAA,MACzC;AAAA,MACA,UAAU,EAAE,QAAAA,WAAU;AAETA,mBAAAA,SAAQ,YAAY,EAAE,UAAU;AAAA,MAC7C;AAAA,MACA,QAAQ,EAAE,QAAAA,WAAU;AACPA,mBAAAA,SAAQ,YAAY,EAAE,QAAQ;AAAA,MAC3C;AAAA,MAAA,aACAI;AAAAA,MAAA,UACAO;AAAAA,MAAA,QACAC;AAAAA,IAAA;AAAA,EAEJ;AAMO,SAAA;AAAA,IACL,SAAS,EAAE,QAAAZ,WAAU;AACnBA,cAAO,IAAI,QAAQ,EAAE,IAAI,cAAc;AAAA,IACzC;AAAA,EAAA;AAEJ;AAEA,MAAA,UAAe,WAAW;ACtC1B,MAAM,WAA4C,OAAO,EAAE,QAAAA,cAAa;AACtE,QAAM,QAAQ,WAAW,EAAE,QAAAA,QAAQ,CAAA;AACrC;ACLA,MAAM,yBAAyB;AAAA,EAC7B,eAAe;AAAA,EACf,iBAAiB;AACnB;ACCA,MAAA,YAAe,YAAY;AAClB,SAAA,QAAQ,sBAAsB,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAC/D,WAAO,IAAI,cAAc,EAAE,gBAAgB,KAAK,KAAK;AAAA,EAAA,CACtD;AAEUD,eAAA,aAAa,EAAE;AACpB,QAAAA,aAAW,YAAY,EAAE;AACzB,QAAAA,aAAW,eAAe,EAAE;AAC5B,QAAAA,aAAW,YAAY,EAAE;AAE/B,QAAM,QAAQ,YAAY,EAAE,OAAQ,CAAA;AACtC;ACZA,MAAM,UAA0C,OAAO,EAAE,QAAAC,cAAa;AACpE,QAAM,QAAQ,UAAU,EAAE,QAAAA,QAAQ,CAAA;AACpC;ACGA,MAAA,UAAe,OAAO,KAAc,SAAe;AAC3C,QAAA,EAAE,MAAM,IAAgC,IAAI;AAE5C,QAAA,KAAkB,OAAO,aAAa,KAAK;AAEjD,MAAI,CAAC,IAAI;AACP,WAAO,IAAI,KAAK,EAAE,OAAO,uBAAA,GAA0B,GAAG;AAAA,EACxD;AAEI,MAAAI;AACJ,MAAI,CAAC,GAAG,UAAU,GAAG,WAAW,SAAS;AACvC,IAAAA,eAAc,OAAO,MAAM;AAAA,EAAA,OACtB;AACL,IAAAA,eAAc,OAAO,OAAO,GAAG,MAAM,EAAE;AAAA,EACzC;AAEM,QAAA,EAAE,MAAM,IAA2B,IAAI;AAEzC,MAAA,OAAO,MAAM,YAAY,UAAU;AACrC,WAAO,KAAK;AAAA,EACd;AAEA,QAAM,CAAA,EAAG,MAAM,IAAI,MAAM,QAAQ,MAAM,GAAG;AAEtC,MAAA;AACJ,MAAI,CAAC,GAAG,UAAU,GAAG,WAAW,SAAS;AACxB,mBAAA,OAAO,OAAO,IAAI,gBAAgB,GAAG,SAAS,YAAY,MAAM,EAAE;AAAA,EAAA,OAC5E;AACU,mBAAA,OAAO,OAAO,GAAG,MAAM,EAAE,OAAO,UAAU,GAAG,SAAS,YAAY,MAAM,EAAE;AAAA,EAC3F;AAEI,MAAA,CAAC,MAAM,YAAY,GAAG;AACxB,UAAM,CAAC,YAAYS,OAAM,IAAI,aAAa,MAAM,GAAG;AAEnD,QAAI,cAAcA,SAAQ;AACjB,aAAAT,aAAY,WAAW,YAAa,CAAA,EAAES,OAAM,EAAE,KAAK,IAAI;AAAA,IAChE;AAAA,EACF;AAEA,QAAM,KAAK;AACb;AC9CA,MAAe,QAAA;AAAA,EACb,MAAM;AAAA,EACN,QAAQ;AAAA,IACN;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC,6BAA6B;AAAA,MAC1C;AAAA,IACF;AAAA,IAEA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IAEA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC;AAAA,MACb;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC,6BAA6B;AAAA,MAC1C;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,UAAU,CAAC,6BAA6B;AAAA,MAC1C;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,uCAAuC,EAAE;AAAA,UAC/D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ;AAAA,cACN,SAAS;AAAA,gBACP;AAAA,gBACA;AAAA,cACF;AAAA,cACA,eAAe;AAAA,YACjB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,0CAA0C,EAAE;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,0CAA0C,EAAE;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,uCAAuC,EAAE;AAAA,UAC/D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,uCAAuC,EAAE;AAAA,UAC/D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,uCAAuC,EAAE;AAAA,UAC/D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,0CAA0C,EAAE;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,0CAA0C,EAAE;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,0CAA0C,EAAE;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,yCAAyC,EAAE;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,0CAA0C,EAAE;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,0CAA0C,EAAE;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,uCAAuC,EAAE;AAAA,UAC/D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,QACN,aAAa,CAAC,OAAO;AAAA,QACrB,UAAU;AAAA,UACR;AAAA,UACA;AAAA,YACE,MAAM;AAAA,YACN,QAAQ,EAAE,SAAS,CAAC,uCAAuC,EAAE;AAAA,UAC/D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;ACpcA,MAAe,SAAA;AAAA,EACb;AAAA,EACA,GAAI,QAAQ,SAAS,QAAQ,SAAS,CAAC;AACzC;ACJA,MAAM,uBAAuBC,MAAI,OAAO;AAAA,EACtC,SAASA,MAAI,MAAA,EAAQ,GAAGA,MAAI,QAAQ;AAAA,EACpC,eAAeA,MAAI,QAAQ;AAC7B,CAAC;AAEY,MAAA,8BAA8B,sBAAsB,oBAAoB;ACHrF,MAAM,EAAE,aAAiB,IAAA;AAEzB,MAAA,iBAAe,aAAa;AAAA,EAC1B,MAAM;AAAA,EACN,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMX,QAAQ,KAAc,SAAS,IAAI;AACjC,UAAM,EAAE,UAAU,CAAI,GAAA,gBAAgB,UACpC;AAEI,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAuB,IAAI;AAEnC,UAAA,eAAe,gBACjB,QAAQ,KAAK,CAAC,WAAW,YAAY,IAAI,QAAQ,KAAK,CAAC,IACvD,QAAQ,MAAM,CAAC,WAAW,YAAY,IAAI,QAAQ,KAAK,CAAC;AAErD,WAAA;AAAA,EACT;AACF,CAAC;ACzBD,MAAe,WAAA;AAAA,EACb;AACF;ACAA,MAAM,EAAE,yBAAyB,sBAA0B,IAAAC;AAC3D,MAAM,EAAA,wBAAEC,0BAAwB,sBAAsB,qBAAA,IACpDD,eAAkB;AAEpB,MAAM,gBAAgB,CAAC,aAAa,QAAQ,SAAS,YAAY,eAAe,QAAQ;AACxF,MAAM,qBAAqB,CAAC,YAAY,WAAW;AAEnD,MAAM,gBAAgB,CAAC,QAAQ,YAAY,YAAY,eAAe,QAAQ;AAC9E,MAAM,qBAAqB,CAAC,YAAY,aAAa,aAAa,YAAY;AAG9E,MAAM,WAAW,CAAC,QAAa,SAAc;AAC3C,MAAI,CAAC,EAAE,IAAI,OAAO,YAAY,IAAI,GAAG;AAC5B,WAAA;AAAA,EACT;AAEME,QAAAA,YAAW,EAAE,IAAI,QAAQ,CAAC,UAAU,cAAc,MAAM,QAAQ,GAAG,KAAK;AAC9E,MAAIA,cAAa,MAAM;AACd,WAAA;AAAA,EACT;AAEO,SAAA;AACT;AAEA,MAAM,aAAa,CAAC,QAAa,SAAc;AAC7C,MAAI,CAAC,EAAE,IAAI,OAAO,YAAY,IAAI,GAAG;AAC5B,WAAA;AAAA,EACT;AAEI,MAAA,SAAS,QAAQ,IAAI,GAAG;AACnB,WAAA;AAAA,EACT;AAEM,QAAA,YAAY,OAAO,WAAW,IAAI;AACxC,MAAI,cAAc,SAAS,UAAU,IAAI,GAAG;AACnC,WAAA;AAAA,EACT;AAEI,MAAAC,aAAW,SAAS,KAAK,CAAC,mBAAmB,SAAS,UAAU,YAAY,GAAG;AAC1E,WAAA;AAAA,EACT;AAEO,SAAA;AACT;AAEA,MAAM,aAAa,CAAC,QAAa,SAAc;AAC7C,MAAI,CAAC,EAAE,IAAI,OAAO,YAAY,IAAI,GAAG;AAC5B,WAAA;AAAA,EACT;AAEI,MAAA,OAAO,cAAc,eAAe,SAAS;AAAa,WAAA;AAExD,QAAA,YAAY,OAAO,WAAW,IAAI;AACxC,MAAI,cAAc,SAAS,UAAU,IAAI,GAAG;AACnC,WAAA;AAAA,EACT;AAEI,MAAAA,aAAW,SAAS,KAAK,CAAC,mBAAmB,SAAS,UAAU,YAAY,GAAG;AAC1E,WAAA;AAAA,EACT;AAEO,SAAA;AACT;AAEA,MAAM,eAAe,CAAC,QAAa,SAAc;AACxC,SAAA,WAAW,QAAQ,IAAI;AAChC;AAEA,MAAMX,cAAY,CAAC,QAAa,SAAc;AAC5C,MAAI,CAAC,EAAE,IAAI,OAAO,YAAY,IAAI,GAAG;AAC5B,WAAA;AAAA,EACT;AAEI,MAAA,SAAS,QAAQ,IAAI,GAAG;AACnB,WAAA;AAAA,EACT;AAEA,MAAI,YAAY,QAAQ,IAAI,KAAK,SAAS,MAAM;AACvC,WAAA;AAAA,EACT;AAEI,MAAA,mBAAmB,IAAI,GAAG;AACrB,WAAA;AAAA,EACT;AAEI,MAAA,eAAe,QAAQ,IAAI,GAAG;AACzB,WAAA;AAAA,EACT;AAEO,SAAA;AACT;AAEA,MAAM,qBAAqB,CAAC,SAAcS,6BAA2B;AAErE,MAAM,cAAc,CAAC,QAAa,SAAc;AAC9C,MAAI,CAAC,EAAE,IAAI,OAAO,YAAY,IAAI,GAAG;AAC5B,WAAA;AAAA,EACT;AAEM,QAAA,aAAaD,eAAkB,cAAc,MAAM;AACzD,MAAI,CAAC,cAAc,CAAC,MAAM,QAAQ,UAAU,GAAG;AACtC,WAAA;AAAA,EACT;AAEI,MAAA,WAAW,SAAS,IAAI,GAAG;AACtB,WAAA;AAAA,EACT;AACF;AAEA,MAAM,iBAAiB,CAAC,QAAa,SAAc;AACjD,MAAI,CAAC,EAAE,IAAI,OAAO,YAAY,IAAI,GAAG;AAC5B,WAAA;AAAA,EACT;AAEM,QAAA,gBAAgBA,eAAkB,iBAAiB,MAAM;AAC/D,MAAI,CAAC,iBAAiB,CAAC,MAAM,QAAQ,aAAa,GAAG;AAC5C,WAAA;AAAA,EACT;AAEI,MAAA,cAAc,SAAS,IAAI,GAAG;AACzB,WAAA;AAAA,EACT;AACF;AAEA,MAAMG,eAAa,CAAC,cAAmB,UAAU,SAAS;AAE1D,MAAM,uBAAuB,CAAC,QAAa,SAAc;AACvD,MAAI,CAAC,EAAE,IAAI,OAAO,YAAY,IAAI,GAAG;AAC5B,WAAA;AAAA,EACT;AAEI,MAAA,SAAS,QAAQ,IAAI,GAAG;AACnB,WAAA;AAAA,EACT;AAEA,MAAI,CAACX,YAAU,QAAQ,IAAI,GAAG;AACrB,WAAA;AAAA,EACT;AAEA,SAAOW,aAAW,OAAO,WAAW,IAAI,CAAC;AAC3C;AAEA,MAAM,uBAAuB,CAAC,QAAa,SAAc;AACvD,MAAI,CAAC,EAAE,IAAI,OAAO,YAAY,IAAI,GAAG;AAC5B,WAAA;AAAA,EACT;AAEI,MAAA,SAAS,QAAQ,IAAI,GAAG;AACnB,WAAA;AAAA,EACT;AAEA,MAAI,CAACX,YAAU,QAAQ,IAAI,GAAG;AACrB,WAAA;AAAA,EACT;AAEO,SAAA;AACT;AAEA,MAAM,2BAA2B,CAAC,WAAgB;AACzC,SAAA,OAAO,KAAK,OAAO,cAAc,CAAA,CAAE,EAAE,KAAK,CAAC,QAAQ;AACxD,UAAM,EAAE,KAAS,IAAA,OAAO,WAAW,GAAG;AAC/B,WAAA,SAAS,YAAY,QAAQ;AAAA,EAAA,CACrC;AACH;AAEA,MAAM,sBAAsB,CAAC,WAAgB,yBAAyB,MAAM,KAAK;AAQjF,MAAM,wBAAwB,CAAC,WAAgB;AAC7C,QAAM,kBAAkB,OAAO,KAAK,OAAO,UAAU,EAAE,OAAO,CAAC,QAAQ,WAAW,QAAQ,GAAG,CAAC;AAE9F,QAAM,QAAQ,OAAO,SAAS,OAAO,GAAG;AACxC,QAAM,+BAA+B;AAAA,IACnC,wBAAwB,KAAK;AAAA,IAC7B,sBAAsB,KAAK;AAAA,EAAA;AAGtB,SAAA;AAAA,IACL;AAAA,IACA,GAAG;AAAA,IACH,GAAG;AAAA,IACH;AAAA,IACA;AAAA,EAAA;AAEJ;AC3LA,MAAM,mBAAmB;AAAA,EACvB,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,UAAU;AACZ;AAEA,MAAM,iBAAiB;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,MAAM,mBAAmB,KAAK,CAAC,OAAO,CAAI,GAAA,iBAAiB,GAAG,KAAK,cAAc,CAAC,CAAC;AAEnF,eAAe,mBAAmB,QAAa,OAAY;AACnD,QAAA,cAAc,GAAG,MAAM,KAAK;AAE5B,QAAA,4BAA4B,CAAC,EAAE,QAAAY,SAAQ,IAAI,GAAQ,EAAE,aAAkB;AACrE,UAAA,qBAAqB,sBAAsBA,OAAM;AACvD,QAAI,CAAC,mBAAmB,SAAS,GAAG,GAAG;AACrC,aAAO,GAAG;AAAA,IACZ;AAAA,EAAA;AAGI,QAAA,iBAAiB,MAAM,SAAS;AAAA,IACpC;AAAA,IACA,EAAE,QAAQ,UAAU,OAAO,SAAS,KAAK,MAAM,EAAE;AAAA,IACjD;AAAA,EAAA;AAIK,SAAA,QAAQ,aAAa,cAAc;AAC5C;AAEA,MAAM,wBAAwB,OAAO,WAAgB;AAC7C,QAAA,eAAe,oBAAoB,MAAM;AAExC,SAAA;AAAA,IACL,GAAG;AAAA,IACH,WAAW;AAAA,IACX,eAAe;AAAA,IACf,kBAAkB;AAAA,IAClB,GAAG,iBAAiB,MAAM;AAAA,EAAA;AAE9B;AAEA,MAAM,eAAe,OAAO,eAAoB,WAAgB;AAC1D,MAAA,QAAQ,cAAc,QAAQ;AAAG,WAAO,sBAAsB,MAAM;AAElE,QAAA,eAAe,oBAAoB,MAAM;AAEzC,QAAA,EAAE,YAAY,cAAc,gBAAgB,iBAAiB,cAAc,YAAY;AAEtF,SAAA;AAAA,IACL,GAAG,cAAc;AAAA,IACjB,WAAW,WAAW,QAAQ,SAAS,IAAI,YAAY;AAAA,IACvD,eAAgB,MAAM,mBAAmB,QAAQ,aAAa,IAAK,gBAAgB;AAAA,EAAA;AAEvF;AC7DA,MAAA,iCAAe,CAAC,QAAa,OAAO,CAAA,MAClCL,MACG,SACA,MAAM;AAAA,EACL,UAAU,qBAAqB,MAAM,EAAE,QAAQ,IAAI,EAAE,SAAS;AAAA,EAC9D,WAAW,oBAAoB,MAAM,EAAE,QAAQ,IAAI,EAAE,SAAS;AAAA,EAC9D,SAAS,oBAAoB,QAAQ,IAAI,EAAE,QAAQ,IAAI,EAAE,SAAS;AAAA,EAClE,SAASA,MAAI,OAAO,EAAE,SAAS;AACjC,CAAC,EACA,UAAU;AAEf,MAAM,uBAAuB,CAAC,WAAgB;AAC5C,QAAM,kBAAkB,OAAO,KAAK,OAAO,UAAU,EAAE,OAAO,CAAC,QAAQ,WAAW,QAAQ,GAAG,CAAC;AAEvF,SAAAA,MACJ,OAAO,EACP,MAAM;AAAA,IACL,UAAUA,MAAI,QAAQ,EAAE,SAAS;AAAA,IACjC,YAAYA,MAAI,QAAQ,EAAE,SAAS;AAAA,IACnC,UAAUA,MAAI,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,IAAI,GAAG,EAAE,SAAS;AAAA,IAC3D,YAAYA,MAAI,QAAQ,EAAE,SAAS;AAAA;AAAA,IAEnC,WAAWA,MAAI,OAAS,EAAA,MAAM,gBAAgB,OAAO,IAAI,CAAC,EAAE,QAAQ,IAAI;AAAA;AAAA,IAExE,eAAeA,MACZ,OAAA,EACA;AAAA,MAAK;AAAA,MAA2B;AAAA,MAAyC,OAAO,UAC/E,mBAAmB,QAAQ,KAAK;AAAA,IAAA,EAEjC,QAAQ,IAAI;AAAA,IACf,kBAAkBA,MAAI,OAAA,EAAS,MAAM,CAAC,OAAO,MAAM,CAAC,EAAE,QAAQ,KAAK;AAAA,EAAA,CACpE,EACA,UAAU;AACf;AAEA,MAAM,sBAAsB,CAAC,WAAgB;AACpC,SAAAA,MAAI,SAAS;AAAA,IAClB,OAAO,KAAK,OAAO,UAAU,EAAE,OAAO,CAAC,KAAU,QAAQ;AACvD,UAAI,GAAG,IAAIA,MACR,OAAA,EACA,MAAM;AAAA,QACL,MAAMA,MACH,OAAO,EACP,MAAM;AAAA,UACL,OAAOA,MAAI,OAAO;AAAA,UAClB,aAAaA,MAAI,OAAO;AAAA,UACxB,aAAaA,MAAI,OAAO;AAAA,UACxB,UAAUA,MAAI,QAAQ;AAAA,UACtB,SAASA,MAAI,QAAQ;AAAA,UACrB,WAAWA,MAAI,KAAK,CAAC,UAAU;AAC7B,gBAAI,CAAC,OAAO;AACV,qBAAOA,MAAI;YACb;AAEM,kBAAA,eAAef,aAAW,eAAe,EAAE;AAAA,cAC/C,OAAO,WAAW,GAAG,EAAE;AAAA,YAAA;AAGzB,gBAAI,CAAC,cAAc;AACjB,qBAAOe,MAAI;YACb;AAEA,kBAAM,kBAAkB,OAAO,KAAK,aAAa,UAAU,EAAE;AAAA,cAAO,CAACM,SACnE,WAAW,cAAcA,IAAG;AAAA,YAAA;AAGvB,mBAAAN,MAAI,SAAS,MAAM,gBAAgB,OAAO,IAAI,CAAC,EAAE,QAAQ,IAAI;AAAA,UAAA,CACrE;AAAA,QAAA,CACF,EACA,UAAU,EACV,SAAS;AAAA,QACZ,MAAMA,MACH,OAAO,EACP,MAAM;AAAA,UACL,OAAOA,MAAI,OAAO;AAAA,UAClB,YAAYA,MAAI,QAAQ;AAAA,UACxB,UAAUA,MAAI,QAAQ;AAAA,QAAA,CACvB,EACA,UAAU,EACV,SAAS;AAAA,MAAA,CACb,EACA,UAAU;AAEN,aAAA;AAAA,IACT,GAAG,EAAE;AAAA,EAAA;AAET;AAEA,MAAM,kBAAkB,CAAC,EAAE,iBAAiB,MAAM,IAAI,CAAA,OAAQ;AAAA,EAC5D,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM,CAAC,QAAc,mBAAmB,QAAQ,QAAQ,SAAY,OAAO,MAAM,QAAQ,GAAG;AAC9F;AAEA,MAAM,sBAAsB,CAAC,QAAa,OAAO,OAAO;AACtD,QAAM,kBAAkB,OAAO,KAAK,OAAO,UAAU,EAAE,OAAO,CAAC,QAAQ,WAAW,QAAQ,GAAG,CAAC;AAE9F,QAAM,iBAAiB,OAAO,KAAK,OAAO,UAAU,EAAE;AAAA,IAAO,CAAC,QAC5D,qBAAqB,QAAQ,GAAG;AAAA,EAAA;AAG3B,SAAAA,MAAI,OAAO,EAAE,MAAM;AAAA,IACxB,MAAMA,MACH,MAAA,EACA;AAAA,MACCA,MAAI,QAAQ;AAAA,QACVA,MACG,OAAO,EACP,MAAM;AAAA,UACL,MAAMA,MAAI,OAAA,EAAS,MAAM,cAAc,EAAE,SAAS;AAAA,UAClD,MAAMA,MAAI,OAAO,EAAE,UAAU,WAAW,SAAS;AAAA,QAClD,CAAA,EACA,UAAU;AAAA,MACf;AAAA,IAAA,EAED,KAAK,gBAAgB,IAAI,CAAC;AAAA,IAC7B,MAAMA,MAAI,MAAM,EAAE,GAAGA,MAAI,OAAA,EAAS,MAAM,eAAe,CAAC,EAAE,KAAK,gBAAgB,IAAI,CAAC;AAAA,EAAA,CACrF;AACH;AC1HA,MAAM,EAAE,iBAAiB,gBAAoB,IAAA;AAC7C,MAAM,QAAQ,CAAC,cAAc,gBAAgB;AAK7C,MAAM,aAAaA,MAAI,SAAS,MAAM,KAAK,EAAE;AAE7C,MAAM,wBAAwBA,MAC3B,OAAO;AAAA,EACN,aAAaA,MAAI,MAAM,EAAE,GAAGA,MAAI,SAAS,CAAC,EAAE,IAAI,CAAC,EAAE,SAAS;AAC9D,CAAC,EACA,SAAS;AAEZ,MAAM,yBAAyBA,MAAI,OAAO;AAAA,EACxC,gBAAgBA,MAAI,OAAO,EAAE,SAAS;AAAA,EACtC,OAAOA,MAAI,OAAO,EAAE,SAAS;AAAA,EAC7B,MAAMA,MAAI,OAAO,EAAE,SAAS;AAC9B,CAAC;AAED,MAAM,kCAAkCA,MAAI,OAAO;AAAA,EACjD,gBAAgBA,MAAI,OAAO,EAAE,SAAS;AAAA,EACtC,OAAOA,MAAI,OAAO,EAAE,SAAS;AAAA,EAC7B,OAAOA,MACJ,OAAA,EACA,QAAQ,oBAAoB,EAC5B,SAAS;AACd,CAAC;AAED,MAAM,mBAAmB,CAAC,gBAAqB,UAAe;AACtD,QAAA,QAAQ,OAAO,aAAa,cAAc;AAEhD,MAAI,CAAC,OAAO;AACJ,UAAA,IAAI,gBAAgB,uBAAuB;AAAA,EACnD;AAEA,MACE,CAAC,EAAE,IAAI,OAAO,CAAC,cAAc,KAAK,CAAC,KACnC,EAAE,IAAI,OAAO,CAAC,cAAc,OAAO,MAAM,CAAC,MAAM,OAChD;AACA,UAAM,IAAI,gBAAgB,GAAG,KAAK,oCAAoC;AAAA,EACxE;AACF;AAcA,MAAM,eAAe,kBAAkB,UAAU;AACjD,MAAM,0BAA0B,kBAAkB,qBAAqB;AACvE,MAAM,2BAA2B,kBAAkB,sBAAsB;AACzE,MAAM,oCAAoC,kBAAkB,+BAA+B;AC3D3F,MAAM,sBAAEO,qBAAmB,IAAI,YAAY;AAQ3C,SAAS,cAAc,OAAY,eAAoB,MAA0C;AAE/F,MAAI,CAACA,qBAAmB,OAAO,aAAa,GAAG;AAE7C,WAAO;EACT;AAMA,QAAM,EAAE,UAAU,YAAY,SAAa,IAAA,MAAM,WAAW,aAAa;AAEzE,MACE,CAAC,YAAY,WAAW,EAAE,SAAS,QAAQ,KAC3C,CAAC,UAAU,UAAU,EAAE,KAAK,CAAC,QAAQ,OAAO,IAAI,GAChD;AACO,WAAA,CAAC,CAAC,CAAC,GAAG,MAAM,aAAa,GAAG,UAAU,CAAC;AAAA,EAChD;AAEA,SAAO;AACT;AAEA,MAAM,6BAA6B,CACjCf,MACA,aAAuB,OACM;AACvB,QAAA,QAAQ,OAAO,SAASA,IAAG;AAEjC,QAAM,mBAAmB,OAAO,KAAK,MAAM,UAAU,EAAE;AAAA,IACrD,CAAC,KAAK,kBAAkB;AAChB,YAAA,YAAiB,MAAM,WAAW,aAAa;AACrD,YAAM,gBAAgB,CAAC,GAAG,YAAY,aAAa;AAEnD,cAAQ,UAAU,MAAM;AAAA,QACtB,KAAK;AACI,iBAAA,CAAC,GAAG,KAAK,GAAG,cAAc,OAAO,eAAe,UAAU,CAAC;AAAA,QACpE,KAAK;AACI,iBAAA,CAAC,GAAG,KAAK,GAAG,2BAA2B,UAAU,WAAW,aAAa,CAAC;AAAA,QACnF,KAAK;AACI,iBAAA;AAAA,YACL,GAAG;AAAA,YACH,IAAI,UAAU,cAAc,CAAA,GAAI;AAAA,cAAQ,CAAC,iBACvC,2BAA2B,cAAc;AAAA,gBACvC,GAAG;AAAA,gBACH,OAAO,SAAS,YAAY,EAAE,KAAK;AAAA,cAAA,CACpC;AAAA,YACH;AAAA,UAAA;AAAA,QAEJ,KAAK;AACH,iBAAO,CAAC,GAAG,KAAK,CAAC,eAAe,QAAQ,CAAC;AAAA,QAC3C;AACE,cAAI,WAAW,QAAQ;AACrB,mBAAO,CAAC,GAAG,KAAK,CAAC,eAAe,QAAQ,CAAC;AAAA,UAC3C;AACO,iBAAA;AAAA,MACX;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EAAA;AAGI,SAAA;AACT;AASA,MAAM,4BACJ,CAACA,MAAUL,uBACX,CAAC,MAAW,OAAO,OAAY;AACvB,QAAA,QAAQ,OAAO,SAASK,IAAG;AACjC,QAAM,YAAY,CAACgB,UAAcrB,mBAAkB,IAAI,OAAO,MAAMqB,KAAI;AAEjE,SAAA,OAAO,KAAK,MAAM,UAAU,EAAE,OAAO,CAACC,OAAM,kBAAkB;AAC7D,UAAA,YAAY,MAAM,WAAW,aAAa;AAChD,UAAM,gBAAgB,CAAC,GAAG,MAAM,aAAa,EAAE,KAAK,GAAG;AAGvD,QAAI,CAACF,qBAAmB,OAAO,aAAa,GAAG;AACtCE,aAAAA;AAAAA,IACT;AAEA,YAAQ,UAAU,MAAM;AAAA,MAEtB,KAAK,YAAY;AACf,YAAI,UAAU,aAAa;AAAUA,iBAAAA;AACrC,eAAO,IAAI,eAAe,EAAE,KAAK,CAAC,EAAA,GAAKA,KAAI;AAAA,MAC7C;AAAA,MAEA,KAAK,aAAa;AAChB,eAAO,0BAA0B,UAAU,WAAWtB,kBAAiB,EAAEsB,OAAM;AAAA,UAC7E,GAAG;AAAA,UACH;AAAA,QAAA,CACM;AAAA,MACV;AAAA,MAEA,SAAS;AACP,YAAI,UAAU,aAAa;AAAUA,iBAAAA;AAC9B,eAAA,IAAI,eAAe,MAAMA,KAAI;AAAA,MACtC;AAAA,IACF;AAAA,KACC,IAAI;AACT;AC/GF,MAAM,qBAAqBT,MAAI,OAAO,EAAE,SAAS;AAEjD,MAAM,uBAAuBA,MAAI;AAAA,EAAK,CAAC,UACrC,MAAM,QAAQ,KAAK,IAAIA,MAAI,MAAA,EAAQ,GAAG,mBAAmB,SAAA,CAAU,IAAI;AACzE;AAEA,MAAM,eAAeA,MAAI,QAAQ,MAAM,CAAC,SAAS,WAAW,GAAG,gBAAgB;AAMlE,MAAA,6BAA6B,OACxC,SACA,OACA,OAAgB,EAAE,sBAAsB,YACrC;AACG,QAAA,EAAE,qBAAyB,IAAA;AAC3B,QAAA,EAAE,QAAQ,QAAQ,gBAAgB,GAAG,KAAK,IAAI,WAAW;AAEzD,QAAA,gBAAgBN,eAAa,mBAAmB,OAAO,SAAS,KAAK,CAAC,IACxE,SACA;AACE,QAAA,SAAS,mBAAmB,SAAY,iBAAiB;AAE/D,QAAM,SAASM,MAAI,OAAO,EAAE,MAAM;AAAA,IAChC,QAAQ,uBAAuB,uBAAuB;AAAA,IACtD,QAAQ;AAAA,EAAA,CACT;AAEG,MAAA;AACI,UAAA,kBAAkB,QAAQ,EAAE,QAAQ,MAAM,YAAY,MAAA,CAAO,EAAE,OAAO;AAE5E,WAAO,EAAE,QAAQ,QAAQ,GAAG,KAAK;AAAA,WAC1B,OAAY;AACnB,UAAM,IAAI,OAAO,gBAAgB,qBAAqB,MAAM,OAAO,EAAE;AAAA,EACvE;AACF;AC5BO,MAAM,6BAA6B,OACxCb,oBACAK,MACA,UACA,OAA2B,CAAA,MACxB;AACG,QAAAkB,oBAAmBzB,aAAW,mBAAmB;AAEvD,QAAM,gBAAgB,MAAMyB,kBAAiB,2BAA2BlB,MAAK,UAAU,IAAI;AAEvF,MAAA;AAAA,IACF,MAAM,EAAE,kBAAkB,gBAAgB;AAAA,EACxC,IAAA;AAEJ,QAAM,oBAAoBL,mBAAkB;AAE5C,qBAAmB,MAAM,MAAM;AAAA,IAC7B;AAAA,IACA,OAAO,mBAA4C,kBAAkB,cAAc;AAAA,EAAA;AAGrF,oBAAkB,MAAM,MAAM;AAAA,IAC5B;AAAA,IACA,OAAO,mBAA4C,kBAAkB,cAAc;AAAA,EAAA;AAG9E,SAAA;AAAA,IACL,GAAG;AAAA,IACH,MAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF;AAAA,EAAA;AAEJ;AC5BA,MAAM,iBAAiB,OAAO,KAAU,SAAmB;AACzD,QAAM,EAAE,aAAa,SAAS,IAAI;AAC5B,QAAA,EAAE,MAAM,IAAI,IAAI;AAChB,QAAA,EAAE,KAAK,IAAI,IAAI;AAEf,QAAAwB,mBAAkB1B,aAAW,kBAAkB;AAC/C,QAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,MAAAE,mBAAkB,OAAO,UAAU;AAC/B,UAAA,IAAI,OAAO;EACnB;AAEA,QAAM,sBAAsBA,mBAAkB;AAC9C,QAAM,aAAa,iBAAiB,EAAE,KAAM,CAAA;AAC5C,QAAM,aAAa,MAAM,KAAK,qBAAqB,UAAiB;AAC9D,QAAA,gBAAgB,MAAM,WAAW,IAAI;AAE3C,QAAM,EAAE,QAAQ,WAAW,MAAM,2BAA2B,MAAM,KAAK;AAEhE,SAAAwB,iBAAgB,OAAO,OAAO;AAAA,IACnC,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA,UAAU,MAAM;AAAA,EAAA,CACjB;AAMH;AAYA,MAAM,iBAAiB,OAAO,KAAU,SAAmB;AACzD,QAAM,EAAE,aAAa,SAAS,IAAI;AAClC,QAAM,EAAE,IAAI,UAAU,IAAI;AACpB,QAAA,EAAE,KAAK,IAAI,IAAI;AAEf,QAAAA,mBAAkB1B,aAAW,kBAAkB;AAC/C,QAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,MAAAE,mBAAkB,OAAO,UAAU;AAC/B,UAAA,IAAI,OAAO;EACnB;AAGA,QAAM,kBAAkB,MAAMA,mBAAkB,eAAe,OAAO,IAAI,KAAK;AACzE,QAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC;AAEH,QAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAG/D,QAAM,CAAC,iBAAiB,cAAc,IAAI,MAAM,QAAQ,IAAI;AAAA,IAC1D0B,iBAAgB,QAAQ,IAAI,OAAO,EAAE,UAAU,QAAQ,QAAQ,SAAS;AAAA,IACxEA,iBAAgB,OAAO,OAAO,EAAE;AAAA,EAAA,CACjC;AAED,MAAI,CAAC,gBAAgB;AACb,UAAA,IAAI,OAAO;EACnB;AAIA,MAAI,iBAAiB;AACnB,QAAIxB,mBAAkB,OAAO,OAAO,eAAe,GAAG;AAC9C,YAAA,IAAI,OAAO;IACnB;AAAA,EACS,WAAAA,mBAAkB,OAAO,UAAU;AACtC,UAAA,IAAI,OAAO;EACnB;AAEA,QAAM,sBAAsB,kBACxBA,mBAAkB,oBAAoB,eAAe,IACrDA,mBAAkB;AACtB,QAAM,aAAa,iBAAiB,EAAE,MAAM,WAAW,MAAM;AAC7D,QAAM,aAAa,MAAM,KAAK,qBAAqB,UAAiB;AAC9D,QAAA,gBAAgB,MAAM,WAAW,IAAI;AAE3C,SAAOwB,iBAAgB,OAAO,iBAAiB,cAAc,IAAI,OAAO;AAAA,IACtE,MAAM;AAAA,IACN,UAAU,MAAM;AAAA,IAChB;AAAA,EAAA,CACD;AACH;AAEA,MAAe,kBAAA;AAAA,EACb,MAAM,KAAK,KAAU;AACb,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AAChB,UAAA,EAAE,MAAM,IAAI,IAAI;AAEhB,UAAAD,oBAAmBzB,aAAW,mBAAmB;AACjD,UAAA0B,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,QAAQ;AACnC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,KAAK,KAAK;AAEnE,UAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC,aAAa,CAAC,EACd,eAAe,EAAE,OAAO,OAAO,QAAQ,KAAA,CAAM,EAC7C;AAEH,UAAM,EAAE,QAAQ,WAAW,MAAM,2BAA2B,OAAO,KAAK;AAExE,UAAM,EAAE,SAAS,WAAW,YAAAI,YAAW,IAAI,MAAMsB,iBAAgB;AAAA,MAC/D,EAAE,GAAG,iBAAiB,UAAU,QAAQ,OAAO;AAAA,MAC/C;AAAA,IAAA;AAII,UAAA,2BAA2B,MAAMD,kBAAiB;AAAA,MACtD;AAAA,MACA;AAAA,IAAA;AAGI,UAAA,YAAY,CAAC,aAAkB;AAEnC,YAAM,oBAAoB,yBAAyB;AAAA,QACjD,CAAC,MAAW,EAAE,eAAe,SAAS;AAAA,MAAA;AAGxC,eAAS,SAASA,kBAAiB,UAAU,UAAU,iBAAiB;AACjE,aAAA;AAAA,IAAA;AAGH,UAAA,UAAU,MAAM,MAAM;AAAA,MAC1B;AAAA,MACA,MAAM,KAAKvB,mBAAkB,gBAAgB,SAAS;AAAA,IAAA;AAGxD,QAAI,OAAO;AAAA,MACT;AAAA,MACA,YAAAE;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,MAAM,QAAQ,KAAU;AAChB,UAAA,EAAE,YAAY,IAAI,IAAI;AAC5B,UAAM,EAAE,OAAO,OAAO,IAAI;AAEpB,UAAAsB,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,QAAQ;AACnC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,KAAK,IAAI,KAAK;AAC7E,UAAM,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC,aAAa,QAAQ,EACrB,iBACA,MAAM;AAEH,UAAA,EAAE,QAAQ,WAAW,MAAM,2BAA2B,IAAI,OAAO,KAAK;AAE5E,UAAM,UAAU,MAAM0B,iBAAgB,QAAQ,IAAI,OAAO;AAAA,MACvD;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,QAAI,CAAC,SAAS;AAEZ,YAAM,SAAS,MAAMA,iBAAgB,OAAO,OAAO,EAAE;AACrD,UAAI,CAAC,QAAQ;AACX,eAAO,IAAI;MACb;AAGM,YAAA,EAAE,KAAK,IAAI,MAAM;AAAA,QACrBxB;AAAA,QACA;AAAA;AAAA,QAEA,EAAE,YAAY,IAAI,QAAQ,aAAa,KAAK;AAAA,QAC5C,EAAE,kBAAkB,MAAM,iBAAiB,MAAM;AAAA,MAAA;AAGnD,UAAI,OAAO,EAAE,MAAM,IAAI,KAAK;AAE5B;AAAA,IACF;AAGA,QAAIA,mBAAkB,OAAO,KAAK,OAAO,GAAG;AAC1C,aAAO,IAAI;IACb;AAGA,UAAM,oBAAoB,MAAMA,mBAAkB,eAAe,OAAO;AACxE,QAAI,OAAO,MAAM,2BAA2BA,oBAAmB,OAAO,iBAAiB;AAAA,EACzF;AAAA,EAEA,MAAM,OAAO,KAAU;AACf,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AAEhB,UAAAA,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAExF,UAAM,CAAC,cAAc,QAAQ,IAAI,MAAM,QAAQ,IAAI;AAAA,MACjD,OAAO,GAAG,MAAM,KAAK,EAAE,MAAM;AAAA,MAC7B,eAAe,GAAG;AAAA,IAAA,CACnB;AAED,UAAM,oBAAoB,MAAME,mBAAkB,eAAe,QAAQ;AACzE,QAAI,SAAS;AACb,QAAI,OAAO,MAAM,2BAA2BA,oBAAmB,OAAO,mBAAmB;AAAA;AAAA,MAEvF,kBAAkB;AAAA,MAClB,iBAAiB;AAAA,IAAA,CAClB;AAED,QAAI,iBAAiB,GAAG;AACf,aAAA,UAAU,KAAK,kCAAkC;AAAA,QACtD,iBAAiB,EAAE,MAAM;AAAA,MAAA,CAC1B;AAAA,IACH;AAAA,EACF;AAAA,EAEA,MAAM,OAAO,KAAU;AACf,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AAEhB,UAAAA,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAElF,UAAA,iBAAiB,MAAM,eAAe,GAAG;AAE/C,UAAM,mBAAmB,MAAME,mBAAkB,eAAe,cAAc;AAC9E,QAAI,OAAO,MAAM,2BAA2BA,oBAAmB,OAAO,gBAAgB;AAAA,EACxF;AAAA,EAEA,MAAM,MAAM,KAAU;AACpB,UAAM,EAAE,aAAa,SAAS,IAAI;AAClC,UAAM,EAAE,OAAO,UAAU,GAAA,IAAO,IAAI;AAC9B,UAAA,EAAE,KAAK,IAAI,IAAI;AAEf,UAAAwB,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,UAAU;AACrC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,OAAO,IAAI,KAAK;AACzE,UAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC;AAEH,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAC/D,UAAM,WAAW,MAAM0B,iBAAgB,QAAQ,IAAI,OAAO;AAAA,MACxD;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,IAAA,CACT;AAED,QAAI,CAAC,UAAU;AACb,aAAO,IAAI;IACb;AAEA,UAAM,sBAAsBxB,mBAAkB;AAC9C,UAAM,aAAa,iBAAiB,EAAE,KAAM,CAAA;AACtC,UAAA,sBAAsB,0BAA0B,OAAOA,kBAAiB;AAC9E,UAAM,aAAa,MAAM,KAAK,qBAAqB,YAAmB,mBAAmB;AACnF,UAAA,gBAAgB,MAAM,WAAW,IAAI;AAE3C,UAAM,iBAAiB,MAAMwB,iBAAgB,MAAM,SAAS,YAAY,eAAe,KAAK;AAE5F,UAAM,oBAAoB,MAAMxB,mBAAkB,eAAe,cAAc;AAC/E,QAAI,OAAO,MAAM,2BAA2BA,oBAAmB,OAAO,mBAAmB;AAAA;AAAA,MAEvF,kBAAkB;AAAA,MAClB,iBAAiB;AAAA,IAAA,CAClB;AAAA,EACH;AAAA,EAEA,MAAM,UAAU,KAAU;AAClB,UAAA,EAAE,MAAM,IAAI,IAAI;AAGhB,UAAA,mBAAmB,2BAA2B,KAAK;AAErD,QAAA,iBAAiB,SAAS,GAAG;AAC/B,aAAO,IAAI;AAAA,QACT;AAAA,QAEA;AAAA,UACE;AAAA,QACF;AAAA,MAAA;AAAA,IAEJ;AAEM,UAAA,KAAK,MAAM,GAAG;AAAA,EACtB;AAAA,EAEA,MAAM,OAAO,KAAU;AACf,UAAA,EAAE,YAAY,IAAI,IAAI;AAC5B,UAAM,EAAE,IAAI,UAAU,IAAI;AAEpB,UAAAwB,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,UAAU;AACrC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,OAAO,IAAI,KAAK;AACzE,UAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC;AAEH,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,IAAI,OAAO,KAAK;AAG9D,UAAA,kBAAkB,MAAM0B,iBAAgB,YAAY,IAAI,OAAO,EAAE,UAAU,OAAA,CAAQ;AAErF,QAAA,gBAAgB,WAAW,GAAG;AAChC,aAAO,IAAI;IACb;AAEA,eAAW,YAAY,iBAAiB;AACtC,UAAIxB,mBAAkB,OAAO,OAAO,QAAQ,GAAG;AAC7C,eAAO,IAAI;MACb;AAAA,IACF;AAEM,UAAA,SAAS,MAAMwB,iBAAgB,OAAO,IAAI,OAAO,EAAE,QAAQ;AAEjE,QAAI,OAAO,MAAMxB,mBAAkB,eAAe,MAAM;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,QAAQ,KAAU;AAChB,UAAA,EAAE,YAAY,IAAI,IAAI;AAE5B,UAAM,EAAE,IAAI,UAAU,IAAI;AACpB,UAAA,EAAE,KAAK,IAAI,IAAI;AAEf,UAAAwB,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,WAAW;AACtC,aAAO,IAAI;IACb;AAEA,UAAM,oBAAoB,MAAM,OAAO,GAAG,YAAY,YAAY;AAEhE,YAAM,kBAAkB,MAAMA,mBAAkB,eAAe,QAAQ,IAAI,KAAK;AAChF,YAAM,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC,aAAa,QAAQ,EACrB,iBACA,MAAM;AAEL,UAAA;AAEJ,YAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAazD,YAAA,WAAW2B,QAAM,EAAE;AACzB,UAAI,UAAU;AACR,YAAAzB,mBAAkB,OAAO,UAAU;AAC/B,gBAAA,IAAI,OAAO;QACnB;AAEA,mBAAW,MAAM,eAAe,KAAK,EAAE,SAAU,CAAA;AAAA,MACnD;AAEA,YAAM,WAAW,CAAC;AAClB,UAAI,UAAU;AACD,mBAAA,MAAMwB,iBAAgB,QAAQ,IAAK,OAAO,EAAE,UAAU,QAAQ;AAEzE,YAAI,CAAC,UAAU;AACP,gBAAA,IAAI,OAAO,cAAc,oBAAoB;AAAA,QACrD;AAGA,YAAIxB,mBAAkB,IAAI,OAAO,QAAQ,GAAG;AAC1C,gBAAM,eAAe,GAAG;AAAA,QAC1B;AAAA,MACF;AAEA,UAAIA,mBAAkB,OAAO,QAAQ,QAAQ,GAAG;AACxC,cAAA,IAAI,OAAO;MACnB;AAEA,YAAM,gBAAgB,MAAMwB,iBAAgB,QAAQ,SAAS,YAAY,OAAO;AAAA,QAC9E;AAAA;AAAA;AAAA,MAAA,CAGD;AAED,UAAI,CAAC,iBAAiB,cAAc,WAAW,GAAG;AAC1C,cAAA,IAAI,OAAO,cAAc,0CAA0C;AAAA,MAC3E;AAEA,aAAO,cAAc,CAAC;AAAA,IAAA,CACvB;AAED,UAAM,oBAAoB,MAAMxB,mBAAkB,eAAe,iBAAiB;AAClF,QAAI,OAAO,MAAM,2BAA2BA,oBAAmB,OAAO,iBAAiB;AAAA,EACzF;AAAA,EAEA,MAAM,YAAY,KAAU;AACpB,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AAChB,UAAA,EAAE,KAAK,IAAI,IAAI;AACf,UAAA,EAAE,YAAgB,IAAA;AAExB,UAAM,wBAAwB,IAAI;AAE5B,UAAAwB,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,WAAW;AACtC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,QAAQ,IAAI,KAAK;AAChF,UAAM,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC,aAAa,QAAQ,EACrB,iBACA,MAAM;AAET,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,OAAO;AAAA,MAC/D,sBAAsB;AAAA,IAAA,CACvB;AAED,UAAM,iBAAiB,YAAY;AAAA,MAAI,CAAC,eACtC0B,iBAAgB,YAAY,YAAY,OAAO,EAAE,UAAU,QAAQ,aAAa,OAAO;AAAA,IAAA;AAEzF,UAAM,YAAY,MAAM,QAAQ,IAAI,cAAc,GAAG;AAErD,eAAW,UAAU,UAAU;AAC7B,UAAI,CAAC,QAAQ;AACX,eAAO,IAAI;MACb;AAEA,UAAIxB,mBAAkB,OAAO,QAAQ,MAAM,GAAG;AAC5C,eAAO,IAAI;MACb;AAAA,IACF;AAEA,UAAM,QAAQ,MAAMwB,iBAAgB,YAAY,OAAO,aAAa,MAAM;AACtE,QAAA,OAAO,EAAE;EACf;AAAA,EAEA,MAAM,cAAc,KAAU;AACtB,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AAChB,UAAA,EAAE,KAAK,IAAI,IAAI;AACf,UAAA,EAAE,YAAgB,IAAA;AAExB,UAAM,wBAAwB,IAAI;AAE5B,UAAAA,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,aAAa;AACxC,aAAO,IAAI;IACb;AAEA,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,OAAO;AAAA,MAC/D,sBAAsB;AAAA,IAAA,CACvB;AAED,UAAM,iBAAiB,YAAY;AAAA,MAAI,CAAC,eACtCwB,iBAAgB,YAAY,YAAY,OAAO,EAAE,QAAQ,aAAa,MAAM;AAAA,IAAA;AAE9E,UAAM,YAAY,MAAM,QAAQ,IAAI,cAAc,GAAG;AAErD,eAAW,UAAU,UAAU;AAC7B,UAAI,CAAC,QAAQ;AACX,eAAO,IAAI;MACb;AAEA,UAAIxB,mBAAkB,OAAO,QAAQ,MAAM,GAAG;AAC5C,eAAO,IAAI;MACb;AAAA,IACF;AAEA,UAAM,cAAc,SAAS,IAAI,CAAC,aAAa,SAAS,UAAU;AAE5D,UAAA,EAAE,UAAU,MAAMwB,iBAAgB,cAAc,aAAa,OAAO,EAAE,OAAA,CAAQ;AAEhF,QAAA,OAAO,EAAE;EACf;AAAA,EAEA,MAAM,UAAU,KAAU;AAClB,UAAA,EAAE,YAAY,IAAI,IAAI;AAC5B,UAAM,EAAE,IAAI,UAAU,IAAI;AACpB,UAAA;AAAA,MACJ,MAAM,EAAE,cAAc,GAAG,KAAK;AAAA,IAAA,IAC5B,IAAI;AAEF,UAAAA,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,aAAa;AACxC,aAAO,IAAI;IACb;AAEA,QAAI,gBAAgBA,mBAAkB,OAAO,QAAA,GAAW;AACtD,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,UAAU,IAAI,KAAK;AAE5E,UAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC;AAGH,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAC/D,UAAM,WAAW,MAAM0B,iBAAgB,QAAQ,IAAI,OAAO;AAAA,MACxD;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,IAAA,CACT;AAED,QAAI,CAAC,UAAU;AACP,YAAA,IAAI,OAAO;IACnB;AAEA,QAAIxB,mBAAkB,OAAO,UAAU,QAAQ,GAAG;AAC1C,YAAA,IAAI,OAAO;IACnB;AAEA,QAAI,gBAAgBA,mBAAkB,OAAO,QAAQ,QAAQ,GAAG;AACxD,YAAA,IAAI,OAAO;IACnB;AAEM,UAAA,OAAO,GAAG,YAAY,YAAY;AACtC,UAAI,cAAc;AAChB,cAAMwB,iBAAgB,aAAa,SAAS,YAAY,OAAO,EAAE,QAAQ;AAAA,MAC3E;AAEI,UAAA,OAAO,MAAM,MAAM;AAAA,QACrB,CAACE,cAAaF,iBAAgB,UAAUE,UAAS,YAAY,OAAO,EAAE,QAAQ;AAAA,QAC9E1B,mBAAkB;AAAA,QAClB,CAAC0B,cAAa,2BAA2B1B,oBAAmB,OAAO0B,SAAQ;AAAA,QAC3E,QAAQ;AAAA,IAAA,CACX;AAAA,EACH;AAAA,EAEA,MAAM,QAAQ,KAAU;AAChB,UAAA,EAAE,YAAY,IAAI,IAAI;AAC5B,UAAM,EAAE,IAAI,UAAU,IAAI;AACpB,UAAA,EAAE,KAAK,IAAI,IAAI;AAEf,UAAAF,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,WAAW;AACtC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,QAAQ,IAAI,KAAK;AAC1E,UAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC;AAEH,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAC/D,UAAM,WAAW,MAAM0B,iBAAgB,QAAQ,IAAI,OAAO;AAAA,MACxD;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,IAAA,CACT;AAGD,QAAI,CAAC,UAAU;AACb,aAAO,IAAI;IACb;AAEA,QAAIxB,mBAAkB,OAAO,QAAQ,QAAQ,GAAG;AAC9C,aAAO,IAAI;IACb;AAEI,QAAA,OAAO,MAAM,MAAM;AAAA,MACrB,CAAC0B,cAAaF,iBAAgB,aAAaE,UAAS,YAAY,OAAO,EAAE,QAAQ;AAAA,MACjF1B,mBAAkB;AAAA,MAClB,CAAC0B,cAAa,2BAA2B1B,oBAAmB,OAAO0B,SAAQ;AAAA,MAC3E,QAAQ;AAAA,EACZ;AAAA,EAEA,MAAM,WAAW,KAAU;AACnB,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AACtB,UAAM,EAAE,OAAO,SAAS,IAAI;AACtB,UAAA,EAAE,YAAgB,IAAA;AAExB,UAAM,wBAAwB,IAAI;AAE5B,UAAAF,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,UAAU;AACrC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,OAAO,KAAK;AACrE,UAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC;AAEH,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAE/D,UAAM,kBAAkB,MAAM0B,iBAAgB,YAAY,aAAa,OAAO;AAAA,MAC5E;AAAA,MACA;AAAA,IAAA,CACD;AAEG,QAAA,gBAAgB,WAAW,GAAG;AAChC,aAAO,IAAI;IACb;AAEA,eAAW,YAAY,iBAAiB;AACtC,UAAIxB,mBAAkB,OAAO,OAAO,QAAQ,GAAG;AAC7C,eAAO,IAAI;MACb;AAAA,IACF;AAGA,UAAM,qBAAqB,gBAAgB,IAAI,CAAC,aAAa,SAAS,UAAU;AAE1E,UAAA,EAAE,UAAU,MAAMwB,iBAAgB,WAAW,oBAAoB,OAAO,EAAE,OAAA,CAAQ;AAEpF,QAAA,OAAO,EAAE;EACf;AAAA,EAEA,MAAM,oBAAoB,KAAU;AAC5B,UAAA,EAAE,YAAY,IAAI,IAAI;AAC5B,UAAM,EAAE,OAAO,OAAO,IAAI;AAEpB,UAAAA,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,QAAQ;AACnC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,KAAK,IAAI,KAAK;AACvE,UAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC;AAEG,UAAA,EAAE,QAAQ,WAAW,MAAM,2BAA2B,IAAI,OAAO,KAAK;AACtE,UAAA,SAAS,MAAM0B,iBAAgB,QAAQ,IAAI,OAAO,EAAE,UAAU,QAAQ,OAAA,CAAQ;AAEpF,QAAI,CAAC,QAAQ;AACX,aAAO,IAAI;IACb;AAEA,QAAIxB,mBAAkB,OAAO,KAAK,MAAM,GAAG;AACzC,aAAO,IAAI;IACb;AAEA,UAAM,SAAS,MAAMwB,iBAAgB,oBAAoB,IAAI,OAAO,MAAM;AAEnE,WAAA;AAAA,MACL,MAAM;AAAA,IAAA;AAAA,EAEV;AAAA,EAEA,MAAM,+BAA+B,KAAU;AACvC,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,MAAM,IAAI,QAAQ,MAAM;AACxB,UAAA,SAAS,IAAI,QAAQ,MAAM;AAC3B,UAAA,EAAE,MAAM,IAAI,IAAI;AAEhB,UAAAA,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,QAAQ;AACnC,aAAO,IAAI;IACb;AAEM,UAAA,YAAY,MAAMwB,iBAAgB;AAAA,MACtC;AAAA,QACE,SAAS;AAAA,UACP,YAAY;AAAA,QACd;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,IAAA;AAGF,QAAI,CAAC,WAAW;AACd,aAAO,IAAI;IACb;AAEA,UAAM,SAAS,MAAMA,iBAAgB,+BAA+B,KAAK,OAAO,MAAM;AAE/E,WAAA;AAAA,MACL,MAAM;AAAA,IAAA;AAAA,EAEV;AACF;ACxuBA,MAAe,eAAA;AAAA,EACb,eAAe,KAAU;AACvB,UAAMG,cAAa7B,aAAW,YAAY,EAAE,kBAAkB;AAC9D,UAAM,EAAE,MAAA,IAAUA,aAAW,aAAa;AAE1C,QAAI,OAAO,EAAE,MAAM6B,YAAW,IAAI,KAAK;EACzC;AAAA,EAEA,MAAM,2BAA2B,KAAU;AACnC,UAAA,EAAE,KAAAtB,KAAI,IAAI,IAAI;AAEd,UAAA,mBAAmBP,aAAW,YAAY;AAE1C,UAAA,YAAY,iBAAiB,cAAcO,IAAG;AAEpD,QAAI,CAAC,WAAW;AACP,aAAA,IAAI,SAAS,oBAAoB;AAAA,IAC1C;AAEA,UAAM,gBAAgB,MAAM,iBAAiB,kBAAkB,SAAS;AACxE,UAAM,2BAA2B,MAAM,iBAAiB,6BAA6B,SAAS;AAE9F,QAAI,OAAO;AAAA,MACT,MAAM;AAAA,QACJ,WAAW;AAAA,QACX,YAAY;AAAA,MACd;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,MAAM,6BAA6B,KAAU;AACrC,UAAA,EAAE,KAAAA,KAAI,IAAI,IAAI;AACd,UAAA,EAAE,KAAK,IAAI,IAAI;AAEf,UAAA,mBAAmBP,aAAW,YAAY;AAE1C,UAAA,YAAY,iBAAiB,cAAcO,IAAG;AAEpD,QAAI,CAAC,WAAW;AACP,aAAA,IAAI,SAAS,oBAAoB;AAAA,IAC1C;AAEI,QAAA;AACA,QAAA;AACF,cAAQ,MAAM,+BAA+B,SAAS,EAAE,SAAS,MAAM;AAAA,QACrE,YAAY;AAAA,QACZ,cAAc;AAAA,QACd,QAAQ;AAAA,MAAA,CACT;AAAA,aACM,OAAY;AACZ,aAAA,IAAI,WAAW,MAAM;AAAA,QAC1B,MAAM;AAAA,QACN,QAAQ,MAAM;AAAA,MAAA,CACf;AAAA,IACH;AAEA,UAAM,mBAAmB,MAAM,iBAAiB,oBAAoB,WAAW,KAAK;AAEhF,QAAA,OAAO,EAAE,MAAM,iBAAiB;AAAA,EACtC;AACF;AC3DA,MAAM,mBAAmB,IAAI,gBAAgB;AAC7C,MAAM,mBAAmB,KAAK,gBAAgB;AAC9C,MAAM,qBAAqB,MAAM,gBAAgB;AAEjD,MAAM,iBAAiB,CAAC,aACtB,iBAAiB,QAAQ,IAAI,mBAAmB,iBAAiB,QAAQ,GAAG,QAAQ,IAAI;AAE1F,MAAe,eAAA;AAAA,EACb,MAAM,iBAAiB,KAAU;AACzB,UAAA,EAAE,KAAK,IAAI,IAAI;AAEjB,QAAA;AACF,YAAM,aAAa,IAAI;AAAA,aAChB,OAAO;AACd,aAAO,IAAI,KAAK,EAAE,SAAS,GAAG;AAAA,IAChC;AAEA,UAAME,gBAAeT,aAAW,eAAe,EAAE,uBAAuB,IAAI;AAC5E,UAAM,EAAE,MAAA,IAAUA,aAAW,aAAa;AAE1C,QAAI,OAAO,EAAE,MAAMS,cAAa,IAAI,KAAK;EAC3C;AAAA,EAEA,MAAM,yBAAyB,KAAU;AACvC,UAAM,EAAE,qBAAqB,kBAAkB,IAAIT,aAAW,eAAe;AAEvE,UAAAS,gBAAe,MAAM;AACrB,UAAA,iBAAiB,MAAM,QAAQ;AAAA,MACnCA,cAAa,IAAI,OAAO,gBAAqB;AAC3C,cAAM,EAAE,KAAAF,MAAK,SAAA,IAAa,MAAM,kBAAkB,WAAW;AACtD,eAAA,EAAE,KAAAA,MAAK;MAAS,CACxB;AAAA,IAAA;AAGH,QAAI,OAAO;AAAA,MACT,MAAM;AAAA,IAAA;AAAA,EAEV;AAAA,EAEA,MAAM,6BAA6B,KAAU;AACrC,UAAA,EAAE,KAAAA,KAAI,IAAI,IAAI;AAEd,UAAA,qBAAqBP,aAAW,eAAe;AAErD,UAAM,cAAc,MAAM,mBAAmB,gBAAgBO,IAAG;AAEhE,QAAI,CAAC,aAAa;AACT,aAAA,IAAI,SAAS,sBAAsB;AAAA,IAC5C;AAEA,UAAM,gBAAgB,MAAM,mBAAmB,kBAAkB,WAAW;AAE5E,UAAM,0BAA0B;AAAA,MAC9B,GAAG;AAAA,MACH,WAAW,UAAU,gBAAgB,cAAc,SAAS;AAAA,IAAA;AAG9D,UAAMsB,cAAa,MAAM,mBAAmB,6BAA6B,WAAW;AAEpF,QAAI,OAAO;AAAA,MACT,MAAM;AAAA,QACJ,aAAa;AAAA,QACb,YAAAA;AAAA,MACF;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,MAAM,+BAA+B,KAAU;AACvC,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,KAAAtB,KAAI,IAAI,IAAI;AACd,UAAA,EAAE,KAAK,IAAI,IAAI;AAEf,UAAA,qBAAqBP,aAAW,eAAe;AAC/C,UAAA,iBAAiBA,aAAW,SAAS;AAE3C,UAAM,cAAc,MAAM,mBAAmB,gBAAgBO,IAAG;AAEhE,QAAI,CAAC,aAAa;AACT,aAAA,IAAI,SAAS,sBAAsB;AAAA,IAC5C;AAEI,QAAA,CAACP,aAAW,YAAY,EAAE,wBAAwB,EAAE,aAAa,YAAY,CAAC,GAAG;AACnF,aAAO,IAAI;IACb;AAEI,QAAA;AACA,QAAA;AACF,cAAQ,MAAM,+BAA+B,WAAW,EAAE,SAAS,MAAM;AAAA,QACvE,YAAY;AAAA,QACZ,cAAc;AAAA,QACd,QAAQ;AAAA,MAAA,CACT;AAAA,aACM,OAAY;AACZ,aAAA,IAAI,WAAW,MAAM;AAAA,QAC1B,MAAM;AAAA,QACN,QAAQ,MAAM;AAAA,MAAA,CACf;AAAA,IACH;AAEA,UAAM,mBAAmB,MAAM,mBAAmB,oBAAoB,aAAa,KAAK;AAElF,UAAA,eAAe,yBAAyB,aAAa,gBAAgB;AAE3E,UAAM,0BAA0B;AAAA,MAC9B,GAAG;AAAA,MACH,WAAW,UAAU,gBAAgB,iBAAiB,SAAS;AAAA,IAAA;AAGjE,UAAM6B,cAAa,MAAM,mBAAmB,6BAA6B,WAAW;AAEpF,QAAI,OAAO;AAAA,MACT,MAAM;AAAA,QACJ,aAAa;AAAA,QACb,YAAAA;AAAA,MACF;AAAA,IAAA;AAAA,EAEJ;AACF;ACvHA,MAAe,OAAA;AAAA,EACb,YAAY,KAAU;AACpB,UAAM,EAAE,MAAA,IAAU7B,aAAW,aAAa;AAC1C,UAAM,EAAE,kBAAA,IAAsBA,aAAW,YAAY;AACrD,UAAM,EAAE,iBAAA,IAAqBA,aAAW,aAAa;AACrD,UAAM,EAAE,oBAAA,IAAwBA,aAAW,eAAe;AAE1D,QAAI,OAAO;AAAA,MACT,MAAM;AAAA,QACJ,YAAY,iBAAiB;AAAA,QAC7B,YAAY,kBAAA,EAAoB,IAAI,KAAK;AAAA,QACzC,cAAc,oBAAA,EAAsB,IAAI,KAAK;AAAA,MAC/C;AAAA,IAAA;AAAA,EAEJ;AACF;ACfA,MAAM,8BAA8Be,MACjC,OAAO,EACP,MAAM;AAAA,EACL,WAAWA,MAAI,OAAO;AAAA,EACtB,IAAIA,MAAI,SAAS;AAAA,EACjB,IAAIA,MAAI,OAAO;AAAA,EACf,WAAWA,MAAI,MAAA,EAAQ,GAAGA,MAAI,UAAU;AAAA,EACxC,cAAcA,MAAI,MAAA,EAAQ,GAAGA,MAAI,UAAU;AAAA,EAC3C,MAAMA,MAAI,OAAA,EAAS,QAAQ,EAAE,IAAI,CAAC;AAAA,EAClC,UAAUA,MAAI,OAAA,EAAS,QAAA,EAAU,IAAI,CAAC,EAAE,IAAI,GAAG;AAAA,EAC/C,QAAQA,MAAI,OAAO,EAAE,SAAS;AAAA,EAC9B,QAAQA,MAAI,SAAS,MAAM,CAAC,aAAa,OAAO,CAAC,EAAE,SAAS;AAC9D,CAAC,EACA,SAAS;AAEZ,MAAM,6BAA6BA,MAChC,OAAO,EACP,MAAM;AAAA,EACL,MAAMA,MAAI,OAAA,EAAS,QAAQ,EAAE,IAAI,CAAC;AAAA,EAClC,UAAUA,MAAI,OAAA,EAAS,QAAA,EAAU,IAAI,CAAC,EAAE,IAAI,GAAG;AAAA,EAC/C,QAAQA,MAAI,OAAO,EAAE,SAAS;AAAA,EAC9B,QAAQA,MAAI,SAAS,MAAM,CAAC,aAAa,OAAO,CAAC,EAAE,SAAS;AAC9D,CAAC,EACA,SAAS;AAEZ,MAAM,wBAAwB,kBAAkB,6BAA6B,EAAE,QAAQ,MAAO,CAAA;AAC9F,MAAM,uBAAuB,kBAAkB,4BAA4B,EAAE,QAAQ,OAAO;ACnB5F,MAAM,EAAA,wBAAEE,0BAAwB,yBAAyBR,eAAa;AAUtE,MAAM,mBAAmB,CAAC,QAAa,kBAAuB;AACrD,SAAA,UAAU,OAAO,WAAW,CAAA;AACnC,SAAO,QAAQ,OAAO,OAAO,QAAQ,QAAQ;AACtC,SAAA,QAAQ,KAAK,KAAK,aAAa;AACxC;AAEA,MAAM,oBAAoB,CAAC,OAAY,WAAgB,gBAAqB;AAC1E,QAAMP,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO;AAAA,IAChE;AAAA,IACA,OAAO,MAAM;AAAA,EAAA,CACd;AAGK,QAAA,sBAAsB,WAAW,OAAO,SAAS;AAEvD,QAAM,mBAAmBE,mBAAkB,IAAI,KAAK,MAAM,SAAS;AAE/D,MAAA,CAAC,uBAAuB,CAAC,kBAAkB;AAEtC,WAAA;AAAA,EACT;AAKI,MAAA,MAAM,QAAQ,kCAAkC;AAC3C,WAAA;AAAA,EACT;AAEO,SAAA;AACT;AAEA,MAAM,uBAAuB,OAAOK,MAAsBuB,eAAgC;AACxF,MAAI,CAACrB,eAAa,mBAAmB,OAAO,aAAaF,IAAG,CAAC,GAAG;AACvDuB,WAAAA;AAAAA,EACT;AAEM,QAAAL,oBAAmBzB,aAAW,mBAAmB;AACvD,QAAM,2BAA2B,MAAMyB,kBAAiB,uBAAuBlB,MAAKuB,UAAS;AAEtFA,SAAAA,WAAU,IAAI,CAAC,aAA6B;AACjD,UAAM,oBAAoB,yBAAyB;AAAA,MACjD,CAAC,sBAAsC,kBAAkB,eAAe,SAAS;AAAA,IAAA;AAG5E,WAAA;AAAA,MACL,GAAG;AAAA,MACH,QAAQL,kBAAiB,UAAU,UAAU,iBAAiB;AAAA,IAAA;AAAA,EAChE,CACD;AACH;AAEA,MAAM,uBAAuB,CAAC,QAAgBlB,SAAoB;AAC1D,QAAA,QAAQ,OAAO,SAASA,IAAG;AAKjC,MAAI,CAAC,SAAS,CAACE,eAAa,mBAAmB,KAAK,GAAG;AACrD,WAAO;EACT;AAGO,SAAA,WAAW,cAAc,EAAE,UAAU,SAAS,EAAE,OAAO;AAChE;AAEA,MAAM,iBAAiB,CAAC,WAAuB,WAA4B,WAAoB;AACvF,QAAA,cAAc,OAAO,SAAS,SAAS;AACvC,QAAA,cAAc,OAAO,SAAS,SAAS;AAE7C,QAAM,cAAc,OAAO,OAAO,MAAM,EAAE,QAAQ,eAAe,EAAE;AAC7D,QAAA,oBAAoB,YAAY,WAAW;AAC3C,QAAA,oBAAoB,YAAY,WAAW;AAEjD,MAAI,kBAAkB;AAElB,MAAA,CAAC,eAAe,CAAC;AAAqC,sBAAA;AAEnD,SAAA;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EAAA;AAEJ;AAEA,MAAM,iBAAiB,CACrB,WACA,WACG;AACG,QAAA,cAAc,OAAO,SAAS,SAAS;AAE7C,QAAM,OAAOA,eAAa;AACpB,QAAA,aAAa,KAAK,WAAW;AAGnC,MAAI,CAAC;AAAmB,WAAA,EAAE,QAAQ;AAElC,UAAQ,QAAQ;AAAA,IACd,KAAK;AACI,aAAA,EAAE,QAAQ;IACnB;AAES,aAAA,EAAE,QAAQ;EACrB;AACF;AAEA,MAAe,YAAA;AAAA,EACb,MAAM,8BAA8B,KAAU,IAAc;AACpD,UAAA,EAAE,YAAY,IAAI,IAAI;AAC5B,UAAM,EAAE,OAAO,gBAAgB,IAAI;AAE7B,UAAA,eAAe,OAAO,SAAS,KAAK;AAC1C,QAAI,CAAC,cAAc;AACjB,YAAM,IAAI,OAAO,gBAAgB,aAAa,KAAK,gBAAgB;AAAA,IACrE;AAEM,UAAA,YAAiB,aAAa,WAAW,WAAW;AAC1D,QAAI,CAAC,aAAa,UAAU,SAAS,YAAY;AAC/C,YAAM,IAAI,OAAO;AAAA,QACf,wBAAwB,WAAW,qBAAqB,KAAK;AAAA,MAAA;AAAA,IAEjE;AAEA,UAAM,YAAY;AAClB,UAAM,YAAY,UAAU;AAE5B,UAAM,EAAE,QAAQ,mBAAmB,kBAAsB,IAAA;AAAA,MACvD;AAAA,MACA;AAAA,MACA,IAAI,SAAS,OAAO;AAAA,IAAA;AAEhB,UAAA,EAAE,OAAW,IAAA,eAAe,WAAW,IAAI,SAAS,OAAO,MAAM;AAEvE,UAAMP,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO;AAAA,MAChE;AAAA,MACA;AAAA,IAAA,CACD;AAEK,UAAA+B,eAAc,aAAa,cAAc;AAC/C,QAAI,CAACA,cAAa;AAChB,UAAI7B,mBAAkB,OAAO,KAAK,MAAM,WAAW,GAAG;AACpD,eAAO,IAAI;MACb;AAAA,IACF;AAEA,QAAI,UAAkC;AAEtC,QAAI,IAAI;AACN,YAAM,QAA6B,CAAA;AAEnC,UAAI,CAAC6B,cAAa;AAChB,cAAM,aAAa;AAEnB,YAAI,QAAQ;AACJ,gBAAA,cAAc,qBAAqB,QAAQ,SAAS;AAAA,QAC5D;AAEA,YAAI,UAAU,mBAAmB;AAC/B,gBAAM,SAAS;AAAA,QACjB;AAAA,MAAA,OACK;AAGL,cAAM,KAAK;AAAA,MACb;AAEA,YAAM,kBAAkB,MAAM7B,mBAAkB,eAAe,KAAK,IAAI,KAAK;AACvE,YAAA,WAAW,MAAMF,aAAW,kBAAkB,EAAE,KAAK,EACxD,kBAAkB,eAAe,EACjC;AAEH,YAAM,gBAAgB,MAAM,OAAO,GAAG,MAAM,KAAK,EAAE,QAAQ;AAAA,QACzD;AAAA,QACA;AAAA,MAAA,CACD;AAMD,UAAI,CAAC,eAAe;AACZ,cAAA,IAAI,OAAO;MACnB;AAEA,UAAI,CAAC+B,cAAa;AAChB,YAAI7B,mBAAkB,OAAO,KAAK,eAAe,WAAW,GAAG;AACvD,gBAAA,IAAI,OAAO;QACnB;AAAA,MACF;AAEA,gBAAU,cAAc;AAAA,IAC1B;AAEA,UAAM,cAAc6B,eAChB,MAAM/B,aAAW,YAAY,EAAE,kBAAkB,YAAY,IAC7D,MAAMA,aAAW,eAAe,EAAE,kBAAkB,YAAY;AAE9D,UAAA,eAAe,OAAO,SAAS,SAAS;AAE9C,UAAM,YAAY;AAAA,MAChB,KAAK,aAAa,WAAW,iBAAiB;AAAA,MAC9C,CAACgC,eAAcA,cAAa;AAAA,MAC5B,CAACA,eAAc,kBAAkB,cAAcA,YAAW,WAAW;AAAA,MACrE,WAAW;AAEb,UAAM,iBAAiB,KAAK;AAAA,MAC1B;AAAA,MACAf;AAAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,QAAI,mBAAmB;AACrB,qBAAe,KAAK,QAAQ;AAAA,IAC9B;AAEO,WAAA;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ,EAAE,QAAQ,aAAa;AAAA,MAC/B,QAAQ,EAAE,QAAQ,cAAc,aAAa,kBAAkB;AAAA,MAC/D;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAc,KAAU;AAC5B,UAAM,EAAE,GAAO,IAAA,IAAI,QAAQ;AAErB,UAAA,sBAAsB,IAAI,QAAQ,KAAK;AAEvC,UAAA;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,QACN,QAAQ,EAAE,KAAK,WAAW,WAAW,gBAAgB;AAAA,MACvD;AAAA,MACA,QAAQ;AAAA,QACN,QAAQ,EAAE,KAAK,UAAU;AAAA,QACzB,aAAa;AAAA,MACf;AAAA,IACE,IAAA,MAAM,KAAK,8BAA8B,KAAK,EAAE;AAE9C,UAAA,EAAE,WAAW,cAAc,IAAI,GAAG,UAAU,IAAI,QAAQ;AAE9D,UAAMf,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO;AAAA,MAChE,aAAa,IAAI,MAAM;AAAA,MACvB,OAAO;AAAA,IAAA,CACR;AACD,UAAM,kBAAkB,MAAME,mBAAkB,eAAe,KAAK,KAAK;AAEzE,UAAM,cAAc;AAAA,MAClB,MAAM;AAAA;AAAA,MAEN,QAAQ;AAAA,MACR,GAAG;AAAA,IAAA;AAKL,qBAAiB,aAAa;AAAA,MAC5B,aAAa,qBAAqB,QAAQ,SAAS;AAAA,IAAA,CACpD;AAGD,UAAM,iBAAiB,qBAAqB;AAC5C,QAAI,gBAAgB;AACD,uBAAA,aAAa,EAAE,OAAA,CAAQ;AAAA,IAC1C;AAEA,QAAI,IAAI;AAON,YAAM,WAAW,OAAO,GAAG,aAAa,SAAS;AAG3C,YAAA,QAAQ,SAAS;AAEvB,YAAM,QAA6B;AAAA,QACjC,CAAC,GAAG,KAAK,KAAK,GAAG,EAAE,UAAU,KAAK;AAAA,QAClC,CAAC,GAAG,KAAK,cAAc,GAAG,EAAE,UAAU,KAAK;AAAA,MAAA;AAO7C,UAAI,oBAAoB,eAAe;AACrC,cAAM,cAAc;AAAA,MAAA,OACf;AACL,cAAM,KAAK;AAAA,MACb;AAGA,UAAI,QAAQ;AACV,cAAM,GAAG,KAAK,eAAe,IAAI,qBAAqB,QAAQ,SAAS;AAAA,MACzE;AACA,UAAI,gBAAgB;AACZ,cAAA,GAAG,KAAK,SAAS,IAAI;AAAA,MAC7B;AAOK,WAAA,cAAc,UAAU,OAAO,GAAG;AACrC,cAAM,GAAG,KAAK,KAAK,EAAE,SAAS;AAAA,MAChC;AAEA,YAAM,eAAe,SAClB,MAAM,KAAK,EACX,KAAK,EAAE,OAAO,YAAY,CAAC,EAC3B,OAAO,GAAG,KAAK,KAAK,EACpB;AAEH,uBAAiB,aAAa;AAAA,QAC5B,IAAI,EAAE,QAAQ,aAAa;AAAA,MAAA,CAC5B;AAAA,IACH;AAMA,QAAI,IAAI;AACN,YAAM,UAAU,iBAAiB,SAAS,MAAM,OAAO,IAAI,MAAM,UAAU;AAC1D,uBAAA,aAAa,EAAE,CAAC,SAAS,GAAG,EAAE,CAAC,OAAO,GAAG,GAAG,EAAA,CAAG;AAAA,IAClE;AAEI,QAAA,WAAW,SAAS,GAAG;AAEzB,uBAAiB,aAAa;AAAA,QAC5B,IAAI,EAAE,QAAQ,KAAK,SAAS,EAAE;AAAA,MAAA,CAC/B;AAAA,IACH;AAEA,UAAM,MAAM,MAAM,OAAO,GACtB,MAAM,SAAS,EACf,SAAS,OAAO,IAAI,cAAc,EAAE,UAAU,WAAW,WAAW,CAAC;AAExE,QAAI,OAAO;AAAA,MACT,GAAG;AAAA,MACH,SAAS,MAAM,qBAAqB,WAAW,IAAI,OAAO;AAAA,IAAA;AAAA,EAE9D;AAAA,EAEA,MAAM,aAAa,KAAU;AACrB,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,GAAG,IAAI,IAAI;AAEb,UAAA,qBAAqB,IAAI,QAAQ,KAAK;AAEtC,UAAA;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,QACN,QAAQ,EAAE,KAAK,UAAU;AAAA,MAC3B;AAAA,MACA,QAAQ;AAAA,QACN,QAAQ,EAAE,KAAK,UAAU;AAAA,MAC3B;AAAA,IACE,IAAA,MAAM,KAAK,8BAA8B,KAAK,EAAE;AAEpD,UAAM,kBAAkB,MAAMF,aAAW,oBAAoB,EAC1D,OAAO,EAAE,aAAa,OAAO,UAAW,CAAA,EACxC,eAAe,KAAK,EAAE,QAAQ,gBAAgB;AASjD,UAAM,UAAU,OAAO,GAAG,MAAM,SAAS;AACzC,UAAM,gBAAgB8B,YAAU,YAAY,SAAS,IACjD,IAAI,SAA+C,QAAQ,UAAU,GAAG,IAAI,IAC5E,IAAI,SACF,QACG,KAAK,GAAG,IAAI,EAEZ,KAAK,CAACG,UAAS,EAAE,SAASA,OAAM,CAACA,IAAG,IAAI,KAAK;AAWtD,UAAM,MAAM,MAAM,cAAc,EAAE,IAAI,WAAW,aAAa;AAAA,MAC5D,QAAQ,CAAC,MAAM,cAAc,UAAU,aAAa;AAAA,MACpD,UAAU;AAAA,MACV,MAAM,IAAI,QAAQ,MAAM;AAAA,MACxB,UAAU,IAAI,QAAQ,MAAM;AAAA,IAAA,CAC7B;AAMD,UAAM,YAAY,IAAI,QAAQ,IAAI,CAAC,SAAc,KAAK,EAAE;AACxD,qBAAiB,iBAAiB,EAAE,IAAI,EAAE,KAAK,aAAa;AAQ5D,UAAM,eAAe,MAAM,cAAc,EAAE,IAAI,WAAW,aAAa;AAAA,MACrE,GAAG,OAAO,IAAI,cAAc,EAAE,UAAU,WAAW,eAAe;AAAA,MAClE,UAAU;AAAA,IAAA,CACX;AAEK,UAAA,iBAAiB,OAAO,MAAM,OAAO,aAAa,SAAS,IAAI,OAAO,CAAC;AAE7E,QAAI,OAAO;AAAA,MACT,YAAY,IAAI,cAAc;AAAA,QAC5B,MAAM;AAAA,QACN,WAAW;AAAA,QACX,UAAU;AAAA,QACV,OAAO,eAAe;AAAA,MACxB;AAAA,MACA,SAAS,MAAM,qBAAqB,WAAW,cAAc;AAAA,IAAA;AAAA,EAEjE;AACF;AC3cA,MAAM,yBAAyB,OAAO,OAAY,UAAe;AAC/D,SAAOjC,aAAW,kBAAkB,EAAE,KAAK,EACxC,kBAAkB,KAAK,EACvB,aAAa,QAAQ,EACrB,iBACA,MAAM;AACX;AAEA,MAAM,eAAe,OAAO,OAAYO,MAAqB,OAAY,CAAA,MAAO;AACxE,QAAAmB,mBAAkB1B,aAAW,kBAAkB;AACrD,QAAM,WAAW,MAAM,uBAAuB,OAAOO,IAAG;AAExD,SACEmB,iBACG,SAAS,EAAE,GAAG,MAAM,SAAS,GAAGnB,IAAG,EAEnC,KAAK,CAAC,cAAmB,UAAU,CAAC,CAAC;AAE5C;AAEA,MAAM,yBAAyB,OAAO,KAAU,SAA+B;AAC7E,QAAM,EAAE,MAAM,gBAAgB,IAAI;AAC5B,QAAA,EAAE,MAAM,IAAI,IAAI;AACtB,QAAM,EAAE,MAAM,UAAU,IAAI;AAEtB,QAAAmB,mBAAkB1B,aAAW,kBAAkB;AAC/C,QAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAExF,MAAIE,mBAAkB,OAAO,OAAA,KAAYA,mBAAkB,OAAO,UAAU;AACpE,UAAA,IAAI,OAAO;EACnB;AAEA,QAAM,iBAAiB,MAAMA,mBAAkB,eAAe,OAAO,KAAK;AAE1E,QAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAG/D,QAAM,CAAC,iBAAiB,oBAAoB,IAAI,MAAM,QAAQ,IAAI;AAAA,IAChE,aAAa,gBAAgB,OAAO,EAAE,QAAQ,QAAQ,SAAS;AAAA;AAAA,IAE/D,OAAO,GAAG,MAAM,KAAK,EAAE,QAAQ,EAAE,QAAQ,CAAC,YAAY,GAAG;AAAA,EAAA,CAC1D;AAED,QAAM,aAAa,sBAAsB;AAEzC,QAAM,sBAAsB,kBACxBA,mBAAkB,oBAAoB,eAAe,IACrDA,mBAAkB;AAEtB,QAAM,aAAa,kBACf,iBAAiB,EAAE,MAAM,WAAW,KAAK,CAAC,IAC1C,iBAAiB,EAAE,KAAM,CAAA;AAE7B,QAAM,aAAa,MAAM,KAAK,qBAAqB,UAAiB;AAIpE,MAAI,iBAAiB;AACnB,QAAIA,mBAAkB,OAAO,OAAO,eAAe,GAAG;AAC9C,YAAA,IAAI,OAAO;IACnB;AAAA,EACS,WAAAA,mBAAkB,OAAO,UAAU;AACtC,UAAA,IAAI,OAAO;EACnB;AAEM,QAAA,gBAAgB,MAAM,WAAW,IAAI;AAE3C,MAAI,CAAC,YAAY;AACR,WAAAwB,iBAAgB,OAAO,OAAO;AAAA,MACnC,MAAM;AAAA,MACN,GAAG;AAAA,MACH;AAAA,IAAA,CACD;AAAA,EACH;AAEO,SAAAA,iBAAgB,OAAO,YAAY,OAAO;AAAA,IAC/C,MAAM;AAAA,IACN,UAAU,MAAM;AAAA,IAChB;AAAA,EAAA,CACD;AACH;AAEA,MAAe,cAAA;AAAA,EACb,MAAM,KAAK,KAAU;AACb,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AACtB,UAAM,EAAE,QAAQ,CAAA,MAAO,IAAI;AAErB,UAAAxB,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,QAAQ;AACnC,aAAO,IAAI;IACb;AAEA,UAAM,kBAAkB,MAAMA,mBAAkB,eAAe,KAAK,KAAK;AACzE,UAAM,EAAE,QAAQ,WAAW,MAAM,2BAA2B,OAAO,KAAK;AAElE,UAAA,UAAU,MAAM,aAAa,iBAAiB,OAAO,EAAE,QAAQ,QAAQ;AAG7E,QAAI,CAAC,SAAS;AACR,UAAAA,mBAAkB,OAAO,UAAU;AACrC,eAAO,IAAI;MACb;AAEM,YAAA,WAAW,MAAM,OAAO,GAAG,MAAM,KAAK,EAAE,QAAQ,CAAA,CAAE;AAExD,UAAI,CAAC,UAAU;AACb,eAAO,IAAI;MACb;AAGM,YAAA,EAAE,KAAK,IAAI,MAAM;AAAA,QACrBA;AAAA,QACA;AAAA;AAAA,QAEA,EAAE,IAAI,SAAS,YAAY,QAAQ,aAAa,KAAK;AAAA,QACrD,EAAE,kBAAkB,MAAM,iBAAiB,MAAM;AAAA,MAAA;AAEnD,UAAI,OAAO,EAAE,MAAM,IAAI,KAAK;AAC5B;AAAA,IACF;AAEA,QAAIA,mBAAkB,OAAO,KAAK,OAAO,GAAG;AAC1C,aAAO,IAAI;IACb;AAEA,UAAM,oBAAoB,MAAMA,mBAAkB,eAAe,OAAO;AACxE,QAAI,OAAO,MAAM,2BAA2BA,oBAAmB,OAAO,iBAAiB;AAAA,EACzF;AAAA,EAEA,MAAM,eAAe,KAAU;AACvB,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AAEhB,UAAAA,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAElF,UAAA,WAAW,MAAM,uBAAuB,GAAG;AACjD,UAAM,oBAAoB,MAAME,mBAAkB,eAAe,QAAQ;AACzE,QAAI,OAAO,MAAM,2BAA2BA,oBAAmB,OAAO,iBAAiB;AAAA,EACzF;AAAA,EAEA,MAAM,OAAO,KAAU;AACf,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AACtB,UAAM,EAAE,QAAQ,CAAA,MAAO,IAAI;AAErB,UAAAwB,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,UAAU;AACrC,aAAO,IAAI;IACb;AAEA,UAAM,iBAAiB,MAAMA,mBAAkB,eAAe,OAAO,KAAK;AAC1E,UAAM,WAAW,MAAM,uBAAuB,gBAAgB,KAAK;AAEnE,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,OAAO,KAAK;AAChE,UAAM,kBAAkB,MAAMwB,iBAAgB,YAAY,QAAW,OAAO;AAAA,MAC1E;AAAA,MACA;AAAA,IAAA,CACD;AAEG,QAAA,gBAAgB,WAAW,GAAG;AAChC,aAAO,IAAI;IACb;AAEA,eAAW,YAAY,iBAAiB;AACtC,UAAIxB,mBAAkB,OAAO,OAAO,QAAQ,GAAG;AAC7C,eAAO,IAAI;MACb;AAAA,IACF;AAEM,UAAA,gBAAgB,MAAMwB,iBAAgB,OAAO,gBAAgB,GAAG,CAAC,EAAE,YAAY,OAAO;AAAA,MAC1F;AAAA,IAAA,CACD;AAED,QAAI,OAAO,MAAMxB,mBAAkB,eAAe,aAAa;AAAA,EACjE;AAAA,EAEA,MAAM,QAAQ,KAAU;AAChB,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AACtB,UAAM,EAAE,QAAQ,CAAA,MAAO,IAAI;AAErB,UAAAwB,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,WAAW;AACtC,aAAO,IAAI;IACb;AAEA,UAAM,oBAAoB,MAAM,OAAO,GAAG,YAAY,YAAY;AAChE,YAAM,iBAAiB,MAAMA,mBAAkB,eAAe,QAAQ,KAAK;AAC3E,YAAM,WAAW,MAAM,uBAAuB,gBAAgB,KAAK;AACnE,YAAM,WAAW,MAAM,uBAAuB,KAAK,EAAE,SAAU,CAAA;AAE/D,UAAI,CAAC,UAAU;AACP,cAAA,IAAI,OAAO;MACnB;AAEA,UAAIA,mBAAkB,OAAO,QAAQ,QAAQ,GAAG;AACxC,cAAA,IAAI,OAAO;MACnB;AAEA,YAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,UAAU,KAAK;AAC7D,YAAA,gBAAgB,MAAMwB,iBAAgB,QAAQ,SAAS,YAAY,OAAO,EAAE,OAAA,CAAQ;AAEnF,aAAA,cAAc,GAAG,CAAC;AAAA,IAAA,CAC1B;AAED,UAAM,oBAAoB,MAAMxB,mBAAkB,eAAe,iBAAiB;AAClF,QAAI,OAAO,MAAM,2BAA2BA,oBAAmB,OAAO,iBAAiB;AAAA,EACzF;AAAA,EAEA,MAAM,UAAU,KAAU;AAClB,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AAChB,UAAA;AAAA,MACJ,MAAM,EAAE,cAAc,GAAG,KAAK;AAAA,MAC9B,QAAQ,CAAC;AAAA,IAAA,IACP,IAAI;AAEF,UAAAwB,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,aAAa;AACxC,aAAO,IAAI;IACb;AAEA,QAAI,gBAAgBA,mBAAkB,OAAO,QAAA,GAAW;AACtD,aAAO,IAAI;IACb;AAEA,UAAM,iBAAiB,MAAMA,mBAAkB,eAAe,UAAU,KAAK;AAC7E,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAE/D,UAAM,WAAW,MAAM,aAAa,gBAAgB,OAAO,EAAE,QAAQ;AAErE,QAAI,CAAC,UAAU;AACb,aAAO,IAAI;IACb;AAEA,QAAIA,mBAAkB,OAAO,UAAU,QAAQ,GAAG;AAChD,aAAO,IAAI;IACb;AAEA,QAAI,gBAAgBA,mBAAkB,OAAO,QAAQ,QAAQ,GAAG;AAC9D,aAAO,IAAI;IACb;AAEM,UAAA,OAAO,GAAG,YAAY,YAAY;AACtC,UAAI,cAAc;AAChB,cAAMwB,iBAAgB,aAAa,SAAS,YAAY,OAAO,EAAE,QAAQ;AAAA,MAC3E;AAEI,UAAA,OAAO,MAAM,MAAM;AAAA,QACrB,CAACE,cAAaF,iBAAgB,UAAUE,UAAS,YAAY,OAAO,EAAE,QAAQ;AAAA,QAC9E1B,mBAAkB;AAAA,QAClB,CAAC0B,cAAa,2BAA2B1B,oBAAmB,OAAO0B,SAAQ;AAAA,QAC3E,QAAQ;AAAA,IAAA,CACX;AAAA,EACH;AAAA,EAEA,MAAM,QAAQ,KAAU;AAChB,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AACtB,UAAM,EAAE,MAAM,QAAQ,CAAC,EAAA,IAAM,IAAI;AAE3B,UAAAF,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAEpF,QAAAE,mBAAkB,OAAO,WAAW;AACtC,aAAO,IAAI;IACb;AAEA,UAAM,iBAAiB,MAAMA,mBAAkB,eAAe,QAAQ,KAAK;AAC3E,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,MAAM,KAAK;AAEzD,UAAA,WAAW,MAAM,aAAa,gBAAgB,OAAO,EAAE,QAAQ,QAAQ,YAAA,CAAa;AAG1F,QAAI,CAAC,UAAU;AACb,aAAO,IAAI;IACb;AAEA,QAAIA,mBAAkB,OAAO,QAAQ,QAAQ,GAAG;AAC9C,aAAO,IAAI;IACb;AAEI,QAAA,OAAO,MAAM,MAAM;AAAA,MACrB,CAAC0B,cAAaF,iBAAgB,aAAaE,UAAS,YAAY,OAAO,EAAE,QAAQ;AAAA,MACjF1B,mBAAkB;AAAA,MAClB,CAAC0B,cAAa,2BAA2B1B,oBAAmB,OAAO0B,SAAQ;AAAA,MAC3E,QAAQ;AAAA,EACZ;AAAA,EAEA,MAAM,oBAAoB,KAAU;AAC5B,UAAA,EAAE,YAAY,IAAI,IAAI;AACtB,UAAA,EAAE,MAAM,IAAI,IAAI;AAChB,UAAA,EAAE,MAAM,IAAI,IAAI;AAChB,UAAAF,mBAAkB1B,aAAW,kBAAkB;AAC/C,UAAAE,qBAAoBF,aAAW,oBAAoB,EAAE,OAAO,EAAE,aAAa,OAAO;AAExF,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,OAAO,KAAK;AAE5D,QAAAE,mBAAkB,OAAO,QAAQ;AACnC,aAAO,IAAI;IACb;AAEA,UAAM,WAAW,MAAM,aAAa,IAAI,KAAK;AAC7C,QAAI,CAAC,UAAU;AACb,aAAO,IAAI;IACb;AAEA,QAAIA,mBAAkB,OAAO,KAAK,QAAQ,GAAG;AAC3C,aAAO,IAAI;IACb;AAEA,UAAM,SAAS,MAAMwB,iBAAgB,oBAAoB,SAAS,YAAY,OAAO,MAAM;AAEpF,WAAA;AAAA,MACL,MAAM;AAAA,IAAA;AAAA,EAEV;AACF;ACpUA,MAAe,QAAA;AAAA,EACb,MAAM,YAAY,KAAU;AACpB,UAAA,EAAE,gBAAgB,OAAO,SAAS,MAAM,yBAAyB,IAAI,QAAQ,IAAI;AAEvF,UAAM,EAAE,QAAQ,CAAA,MAAO,IAAI;AAC3B,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,OAAO,cAA4B;AAEjF,UAAA,iBAAiB,gBAAgB,KAAK;AAEtC,UAAA,aAAa1B,aAAW,KAAK;AAEnC,QAAI,OAAO;AAAA,MACT,MAAM,MAAM,WAAW,iBAAiB,EAAE,gBAAgB,OAAO,MAAM,QAAQ;AAAA,IAAA;AAAA,EAEnF;AAAA,EAEA,MAAM,qBAAqB,KAAU;AACnC,UAAM,EAAE,gBAAgB,OAAO,MAAA,IAAU,MAAM;AAAA,MAC7C,IAAI,QAAQ;AAAA,IAAA;AAGd,UAAM,EAAE,QAAQ,CAAA,MAAO,IAAI;AAC3B,UAAM,EAAE,OAAO,IAAI,MAAM,2BAA2B,OAAO,cAA4B;AAEjF,UAAA,iBAAiB,gBAAgB,KAAK;AAEtC,UAAA,aAAaA,aAAW,KAAK;AAE7B,UAAA,cAAc,MAAM,WAAW,qBAAqB;AAAA,MACxD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,QAAI,OAAO;AAAA,MACT;AAAA,MACA,YAAY,CAAC,cACT,MAAM,WAAW,cAAc,EAAE,gBAAgB,OAAO,OAAO,OAAO,CAAC,IACvE;AAAA,IAAA;AAAA,EAER;AACF;AC3CA,MAAe,cAAA;AAAA,EACb,oBAAoB;AAAA,EAAA,YACpB6B;AAAAA,EACA,iBAAiB;AAAA,EACjB;AAAA,EACA;AAAA,EACA,gBAAgB;AAAA,EAAA,KAChBtB;AAAAA,EACA,GAAI,QAAQ,cAAc,QAAQ,cAAc,CAAC;AACnD;AChBA,MAAM,OAAO;AAAA,EACX,eAAe;AACjB;AAEA,MAAM,WAAW,MAAM,OAAO,MAAM,EAAE,MAAM,UAAU,MAAM,kBAAA,CAAmB;AAG/E,MAAM,eAAe;AAAA,EACnB,UAAU,CAAC;AAAA,EACX,WAAW,CAAC;AAAA,EACZ,SAAS,CAAC;AACZ;AAEA,MAAM,mBAAmB,CAAC,QAAa,GAAG,KAAK,aAAa,IAAI,GAAG;AAEnE,MAAM,wBAAwB,OAAO,QAAa;AAC1C,QAAA,SAAS,MAAM,SAAA,EAAW,IAAI,EAAE,KAAK,iBAAiB,GAAG,EAAA,CAAG;AAClE,SAAO,EAAE,MAAM,CAAC,GAAG,cAAc,MAAM;AACzC;AAEA,MAAM,wBAAwB,OAAO,KAAa,UAAe;AAC/D,QAAM,eAAgB,MAAM,SAAS,EAAE,IAAI,EAAE,KAAK,iBAAiB,GAAG,GAAG,KAAM;AACzE,QAAA,gBAAgB,EAAE,GAAG;AAE3B,SAAO,KAAK,KAAK,EAAE,QAAQ,CAACc,SAAQ;AAClC,QAAI,MAAMA,IAAG,MAAM,QAAQ,MAAMA,IAAG,MAAM,QAAW;AACnD,QAAE,IAAI,eAAeA,MAAK,MAAMA,IAAG,CAAC;AAAA,IACtC;AAAA,EAAA,CACD;AAED,MAAI,CAAC,EAAE,QAAQ,eAAe,YAAY,GAAG;AACpC,WAAA,WAAW,IAAI;AAAA,MACpB,KAAK,iBAAiB,GAAG;AAAA,MACzB,OAAO;AAAA,IAAA,CACR;AAAA,EACH;AACF;AAEA,MAAM,YAAY,CAAC,QAAa;AAC9B,SAAO,OAAO,GACX,MAAM,oBAAoB,EAC1B,OAAO,EAAE,OAAO,EAAE,KAAK,wCAAwC,GAAG,GAAA,EAAM,CAAA;AAC7E;AAEA,MAAM,YAAY,OAAO,QAAa;AACpC,QAAM,UAAU,MAAM,OAAO,GAAG,MAAM,oBAAoB,EAAE,SAAS;AAAA,IACnE,OAAO;AAAA,MACL,KAAK;AAAA,QACH,aAAa;AAAA,MACf;AAAA,IACF;AAAA,EAAA,CACD;AAEM,SAAA,QAAQ,IAAI,CAAC,EAAE,MAAY,MAAA,KAAK,MAAM,KAAK,CAAC;AACrD;AAEA,MAAM,uBAAuB,MAAM,UAAU,sCAAsC;AAEnF,MAAe,aAAA;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;ACxDA,SAAS,uBAAuB,QAAa;AACpC,SAAA;AAAA,IACL,GAAG,OAAO,KAAK,OAAO,UAAU,EAAE,OAAO,CAAC,KAAU,SAAS;AAC3D,UAAI,IAAI,IAAI,sBAAsB,QAAQ,IAAI;AACvC,aAAA;AAAA,IACT,GAAG,EAAE;AAAA,IACL,IAAI;AAAA,MACF,MAAM,CAAC;AAAA,MACP,MAAM;AAAA,QACJ,OAAO;AAAA,QACP,YAAY;AAAA,QACZ,UAAU;AAAA,MACZ;AAAA,IACF;AAAA,EAAA;AAEJ;AAEA,SAAS,sBAAsB,QAAa,MAAW;AACrD,QAAM,OAAO;AAAA,IACX,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa;AAAA,IACb,SAASb,YAAU,QAAQ,IAAI;AAAA,IAC/B,UAAU;AAAA,EAAA;AAGN,QAAA,kBAAkB,OAAO,WAAW,IAAI;AAC1C,MAAAW,aAAW,eAAe,GAAG;AACzB,UAAA,EAAE,YAAgB,IAAA;AAElB,UAAA,eAAe,gBAAgB,WAAW;AAEhD,QAAI,cAAc;AACX,WAAA,YAAY,oBAAoB,YAAY;AAAA,IACnD;AAAA,EACF;AAEE,IAAA;AAAA,IACA;AAAA,IACA,EAAE,KAAK,EAAE,IAAI,QAAQ,CAAC,UAAU,aAAa,MAAM,MAAM,GAAG,CAAE,CAAA,GAAG;AAAA,MAC/D;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAAA,EAAA;AAGH,QAAM,OAAO;AAAA;AAAA,IAEX,OAAO;AAAA;AAAA,IAEP,YAAY,aAAa,QAAQ,IAAI;AAAA;AAAA,IAErC,UAAU,WAAW,QAAQ,IAAI;AAAA,IACjC,GAAG,EAAE,KAAK,EAAE,IAAI,QAAQ,CAAC,UAAU,aAAa,MAAM,MAAM,GAAG,CAAE,CAAA,GAAG;AAAA,MAClE;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAAA,EAAA;AAGI,SAAA,EAAE,MAAM;AACjB;AAIA,eAAe,cAAc,eAAoB,QAAa;AAE5D,MAAI,EAAE,QAAQ,cAAc,SAAS,GAAG;AACtC,WAAO,uBAAuB,MAAM;AAAA,EACtC;AAGM,QAAA,qBAAqB,EAAE,KAAK,cAAc,WAAW,OAAO,KAAK,OAAO,UAAU,CAAC;AAGnF,QAAA,oBAAoB,EAAE,MAAM,CAAA,GAAI,uBAAuB,MAAM,GAAG,kBAAkB;AAGlF,QAAA,eAAe,OAAO,KAAK,iBAAiB,EAAE,OAAO,CAAC,KAAK,QAAQ;AACvE,UAAM,EAAE,MAAM,KAAK,IAAI,kBAAkB,GAAG;AACtC,UAAA,OAAO,OAAO,WAAW,GAAG;AAE5B,UAAA,cAAc,EAAE,MAAM;AAE5B,QAAI,KAAK,YAAY,CAAC,WAAW,QAAQ,GAAG,GAAG;AAC7C,QAAE,IAAI,aAAa,CAAC,QAAQ,UAAU,GAAG,KAAK;AAC9C,QAAE,IAAI,KAAK,CAAC,GAAG,GAAG,WAAW;AAAA,IAC/B;AAEA,QAAI,KAAK,cAAc,CAAC,aAAa,QAAQ,GAAG,GAAG;AACjD,QAAE,IAAI,aAAa,CAAC,QAAQ,YAAY,GAAG,KAAK;AAChD,QAAE,IAAI,KAAK,CAAC,GAAG,GAAG,WAAW;AAAA,IAC/B;AAEA,QAAI,CAAC,EAAE,IAAI,MAAM,WAAW;AAAU,aAAA;AAGlC,QAAA,CAACA,aAAW,IAAI,GAAG;AACnB,QAAA,IAAI,aAAa,QAAQ,EAAE,KAAK,MAAM,CAAC,WAAW,CAAC,CAAC;AACtD,QAAE,IAAI,KAAK,CAAC,GAAG,GAAG,WAAW;AACtB,aAAA;AAAA,IACT;AAGA,QAAI,KAAK,cAAc;AAAa,aAAA;AAG9B,UAAA,eAAe,gBAAgB,KAAK,WAAW;AAErD,QAAI,CAAC;AAAqB,aAAA;AAEtB,QAAA,CAAC,WAAW,cAAc,KAAK,SAAS,KAAK,CAAC,WAAW,cAAc,KAAK,SAAS,GAAG;AACxF,QAAA,IAAI,aAAa,CAAC,QAAQ,WAAW,GAAG,oBAAoB,YAAY,CAAC;AAC3E,QAAE,IAAI,KAAK,CAAC,GAAG,GAAG,WAAW;AACtB,aAAA;AAAA,IACT;AAEO,WAAA;AAAA,EACT,GAAG,CAAE,CAAA;AAEE,SAAA,EAAE,OAAO,mBAAmB,YAAY;AACjD;AAEA,MAAM,kBAAkB,CAAC,gBAAqB;AAC5C,SAAOnB,aAAW,eAAe,EAAE,gBAAgB,WAAW;AAChE;ACvIA,MAAM,sBAAsB;AAC5B,MAAM,eAAe;AAErB,MAAM,qBAAqB,CAAC,MAAW,SAAc;AACnD,QAAM,EAAE,aAAA,IAAiBA,aAAW,aAAa;AAC3C,QAAA,YAAY,aAAa,IAAI;AAGnC,MAAI,CAAC,UAAU,eAAe,SAAS,UAAU,SAAS;AACjD,WAAA;AAAA,EACT;AAGA,SAAO,QAAQ;AACjB;AAEA,MAAM,sBAAsB,CAAC,cAAmB;AAC9C,QAAM,EAAE,cAAc,aAAa,IAAIA,aAAW,aAAa;AAGxD,SAAA,aAAa,aAAa,UAAU,WAAW,IAAI,UAAU,cAAc,UAAU,IAAI,EAC7F;AACL;AAEA,eAAe,qBAAqB,QAAa;AACxC,SAAA;AAAA;AAAA,IAEL,MAAM,wBAAwB,MAAM;AAAA;AAAA,IAEpC,MAAM,wBAAwB,MAAM;AAAA,IACpC,GAAG,EAAE,KAAK,EAAE,IAAI,QAAQ,CAAC,UAAU,SAAS,GAAG,CAAE,CAAA,GAAG,CAAC,QAAQ,MAAM,CAAC;AAAA,EAAA;AAExE;AAEA,SAAS,wBAAwB,QAAa;AAC5C,SAAO,OAAO,KAAK,OAAO,UAAU,EACjC,OAAO,CAAC,SAAS,WAAW,QAAQ,IAAI,CAAC,EACzC,MAAM,GAAG,mBAAmB;AACjC;AAEA,MAAM,UAAU,CAAC,QAAa,IAAI,OAAO,CAAC,KAAU,OAAY,MAAM,GAAG,MAAM,CAAC;AAEhF,SAAS,wBAAwB,QAAa;AAC5C,QAAMkC,QAAO,OAAO,KAAK,OAAO,UAAU,EAAE,OAAO,CAAC,SAAS,qBAAqB,QAAQ,IAAI,CAAC;AAE/F,SAAO,mBAAmB,CAAA,GAAIA,OAAM,MAAM;AAC5C;AAIA,SAAS,YAAY,eAAoB,QAAa;AAChD,MAAA,EAAE,QAAQ,cAAc,OAAO;AAAG,WAAO,qBAAqB,MAAM;AAExE,QAAM,EAAE,OAAO,IAAI,gBAAgB,CAAI,GAAA,OAAO,CAAA,MAAO,cAAc,WAAW;AAE1E,MAAA,YAAY,KAAK,OAAO,CAAC,SAAc,WAAW,QAAQ,IAAI,CAAC;AAGnE,QAAM,qBAAqB,cAAc;AAAA,IAAO,CAAC,SAC/C,qBAAqB,QAAQ,IAAI;AAAA,EAAA;AAK7B,QAAA,qBAAqB,CAAC,GAAG,kBAAkB;AACjD,MAAI,YAAuB,CAAA;AAC3B,aAAW,OAAO,MAAM;AACtB,UAAM,SAAoB,CAAA;AAE1B,eAAW,MAAM,KAAK;AACpB,UAAI,CAAC,qBAAqB,QAAQ,GAAG,IAAI;AAAG;AAI5C,YAAM,EAAE,aAAA,IAAiBlC,aAAW,aAAa;AACjD,YAAM,YAAY,aAAa,OAAO,WAAW,GAAG,IAAI,EAAE,WAAW,IACjE,OAAO,WAAW,GAAG,IAAI,EAAE,cAC3B,OAAO,WAAW,GAAG,IAAI,EAAE;AAK/B,UAAI,CAAC,mBAAmB,WAAW,GAAG,IAAI,GAAG;AACxB,2BAAA,KAAK,GAAG,IAAI;AAC/B;AAAA,MACF;AAEA,aAAO,KAAK,EAAE;AAAA,IAChB;AAEI,QAAA,OAAO,SAAS,GAAG;AACrB,gBAAU,KAAK,MAAM;AAAA,IACvB;AAAA,EACF;AAEY,cAAA,mBAAmB,WAAkB,oBAAoB,MAAM;AAE3E,QAAM,gBAAgB,EAAE;AAAA,IACtB,OAAO,KAAK,OAAO,UAAU;AAAA,IAC7B,OAAO,KAAK,cAAc,SAAS;AAAA,EAAA;AAKjC,MAAA,UAAU,SAAS,qBAAqB;AAG1C,gBAAY,EAAE;AAAA,MACZ,UACG,OAAO,cAAc,OAAO,CAAC,QAAQ,WAAW,QAAQ,GAAG,CAAC,CAAC,EAC7D,MAAM,GAAG,mBAAmB;AAAA,IAAA;AAAA,EAEnC;AAGM,QAAA,oBAAoB,cAAc,OAAO,CAAC,QAAQ,qBAAqB,QAAQ,GAAG,CAAC;AAE7E,cAAA,mBAAmB,WAAW,mBAAmB,MAAM;AAE5D,SAAA;AAAA,IACL,MAAM,UAAU,SAAS,IAAI,YAAY,wBAAwB,MAAM;AAAA,IACvE,MAAM,UAAU,SAAS,IAAI,YAAY,wBAAwB,MAAM;AAAA,EAAA;AAE3E;AAGA,MAAM,qBAAqB,CAAC,SAAc,IAAI,cAAmB,WAAgB;AAC/E,MAAI,aAAa,WAAW;AAAU,WAAA;AACtC,MAAI,kBAAkB,KAAK,IAAI,OAAO,SAAS,GAAG,CAAC;AAG/C,MAAA,CAAC,OAAO,eAAe,GAAG;AACrB,WAAA,eAAe,IAAI;EAC5B;AAEA,aAAW,OAAO,cAAc;AACxB,UAAA,YAAY,OAAO,WAAW,GAAG;AAEjC,UAAA,gBAAgB,oBAAoB,SAAS;AACnD,UAAM,gBAAgB,QAAQ,OAAO,eAAe,CAAC;AAEjD,QAAA,gBAAgB,gBAAgB,cAAc;AAC7B,yBAAA;AACZ,aAAA,eAAe,IAAI;IAC5B;AAEO,WAAA,eAAe,EAAE,KAAK;AAAA,MAC3B,MAAM;AAAA,MACN,MAAM;AAAA,IAAA,CACP;AAAA,EACH;AAEO,SAAA;AACT;ACxJA,eAAe,qBAAqB,QAAa;AAC3C,MAAA;AACF,UAAM,+BAA+B,QAAQ;AAAA,MAC3C,gBAAgB;AAAA,IACjB,CAAA,EAAE,SAAS,OAAO,MAAM;AAAA,WAClB,OAAY;AACnB,UAAM,IAAI;AAAA,MACR,yCAAyC,OAAO,GAAG;AAAA,MAA0D,MAAM,OAAO;AAAA;AAAA,IAAA;AAAA,EAE9H;AACF;AAEA,eAAe,2BAA2B,QAAa;AACrD,QAAM,qBAAqB,MAAM;AAE1B,SAAA;AAAA,IACL,UAAU,MAAM,sBAAsB,MAAM;AAAA,IAC5C,WAAW,MAAM,uBAAuB,MAAM;AAAA,IAC9C,SAAS,MAAM,qBAAqB,MAAM;AAAA,EAAA;AAE9C;AAEA,eAAe,kBAAkB,MAAW,QAAa;AACvD,QAAM,qBAAqB,MAAM;AAE1B,SAAA;AAAA,IACL,UAAU,MAAM,aAAa,MAAM,MAAM;AAAA,IACzC,SAAS,MAAM,YAAY,MAAM,MAAM;AAAA,IACvC,WAAW,MAAM,cAAc,MAAM,MAAM;AAAA,EAAA;AAE/C;ACtBA,MAAA,6BAAe,CAAC;AAAA,EACd,aAAA+B;AAAA,EACA;AAAA,EACA,YAAAI;AAAA,EACA;AACF,MAKM;AACE,QAAA,gBAAgB,CAAC5B,SAAgB;AAC9B,WAAA,GAAG,MAAM,KAAKA,IAAG;AAAA,EAAA;AAGpB,QAAA,mBAAmB,CAACA,SAAgB;AAClC,UAAA,WAAW,cAAcA,IAAG;AAE3B,WAAA4B,YAAW,sBAAsB,QAAQ;AAAA,EAAA;AAG5C,QAAA,mBAAmB,CAAC5B,MAAa,UAA+B;AACpE,UAAM,gBAAgB;AAAA,MACpB,GAAG;AAAA,MACH,KAAAA;AAAA,MACA,aAAawB,gBAAe;AAAA,IAAA;AAGxB,UAAA,WAAW,cAAcxB,IAAG;AAC3B,WAAA4B,YAAW,sBAAsB,UAAU,aAAa;AAAA,EAAA;AAG3D,QAAA,sBAAsB,CAAC5B,SAAgB;AACrC,UAAA,WAAW,cAAcA,IAAG;AAE3B,WAAA4B,YAAW,UAAU,QAAQ;AAAA,EAAA;AAGtC,QAAM,qBAAqB,YAAY;AACrC,UAAM,SAAS;AAET,UAAA,iBAAiB,MAAMA,YAAW;AAAA,MACtC,wCAAwC,MAAM;AAAA,IAAA;AAG1C,UAAA,sBAAsB,OAAO5B,SAAgB;AACjD,YAAM,OAAO,eAAe,KAAK,CAAC6B,UAAcA,MAAK,QAAQ7B,IAAG;AAEzD,aAAA,iBAAiBA,MAAK,MAAM,kBAAkB,MAAM,OAAOA,IAAG,CAAC,CAAC;AAAA,IAAA;AAGnE,UAAA,2BAA2B,OAAOA,SAAgB;AACtD,aAAO,iBAAiBA,MAAK,MAAM,2BAA2B,OAAOA,IAAG,CAAC,CAAC;AAAA,IAAA;AAGtE,UAAA,cAAc,OAAO,KAAK,MAAM;AACtC,UAAM,SAAS,eAAe,IAAI,CAAC,EAAE,KAAAA,KAAA,MAAeA,IAAG;AAEjD,UAAA,uBAAuB8B,eAAa,aAAa,MAAM;AACvD,UAAA,oBAAoBC,aAAW,aAAa,MAAM;AAClD,UAAA,uBAAuBA,aAAW,QAAQ,WAAW;AAGrD,UAAA,QAAQ,IAAI,qBAAqB,IAAI,CAAC/B,SAAQ,oBAAoBA,IAAG,CAAC,CAAC;AAGvE,UAAA,QAAQ,IAAI,kBAAkB,IAAI,CAACA,SAAQ,yBAAyBA,IAAG,CAAC,CAAC;AAGzE,UAAA,QAAQ,IAAI,qBAAqB,IAAI,CAACA,SAAQ,oBAAoBA,IAAG,CAAC,CAAC;AAAA,EAAA;AAGxE,SAAA;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ;ACjFA,MAAM,mBAAmB;AAEzB,MAAMgC,yBAAuB,2BAA2B;AAAA,EACtD;AAAA,EACA,aAAa;AAAA,EACb,QAAQ;AAAA,EACR,YAAY;AACV,UAAM,EAAE,sBAAA,IAA0BvC,aAAW,aAAa;AAEnD,WAAA,UAAU,uBAAuB,OAAO,UAAU;AAAA,EAC3D;AACF,CAAC;AAED,MAAA,aAAe,CAAC,EAAE,QAAAC,eAAuC;AAAA,EACvD,oBAAoB;AAClB,UAAM,EAAE,sBAAA,IAA0BD,aAAW,aAAa;AAE1D,WAAO,OAAO,OAAOC,QAAO,UAAU,EAAE,IAAI,qBAAqB;AAAA,EACnE;AAAA,EAEA,cAAcM,MAAoB;AAChC,UAAM,EAAE,sBAAA,IAA0BP,aAAW,aAAa;AAEpD,UAAA,YAAYC,QAAO,WAAWM,IAAG;AAEvC,WAAOoB,QAAM,SAAS,IAAI,YAAY,sBAAsB,SAAS;AAAA,EACvE;AAAA,EAEA,MAAM,kBAAkB,WAAmC;AACzD,UAAM,gBAA+B,MAAMY,uBAAqB,iBAAiB,UAAU,GAAG;AAEvF,WAAA;AAAA,MACL,KAAK,UAAU;AAAA,MACf,UAAU,UAAU;AAAA,MACpB,GAAG;AAAA,IAAA;AAAA,EAEP;AAAA,EAEA,MAAM,oBACJ,WACA,kBACA;AACA,UAAMA,uBAAqB,iBAAiB,UAAU,KAAK,gBAAgB;AAEpE,WAAA,KAAK,kBAAkB,SAAS;AAAA,EACzC;AAAA,EAEA,MAAM,6BAA6B,OAA+B;AAChE,UAAM,gBAGF,CAAA;AAEE,UAAA,6BAA6B,OAAOhC,SAAuB;AACzD,YAAA,YAAY,KAAK,cAAcA,IAAG;AAEpC,UAAA,IAAIA,MAAK,aAAa,GAAG;AAC3B;AAAA,MACF;AAEA,YAAM,yBAAyB,MAAM,KAAK,kBAAkB,SAAS;AACrE,YAAM,2BAA2B,MAAM,KAAK,6BAA6B,SAAS;AAElF,aAAO,OAAO,eAAe;AAAA,QAC3B,CAACA,IAAG,GAAG;AAAA,QACP,GAAG;AAAA,MAAA,CACJ;AAAA,IAAA;AAGH,eAAW,OAAO,OAAO,KAAK,MAAM,UAAU,GAAG;AACzC,YAAA,YAAY,MAAM,WAAW,GAAG;AAElC,UAAA,UAAU,SAAS,aAAa;AAC5B,cAAA,2BAA2B,UAAU,SAAS;AAAA,MACtD;AAEI,UAAA,UAAU,SAAS,eAAe;AACzB,mBAAA,gBAAgB,UAAU,YAAY;AAC/C,gBAAM,2BAA2B,YAAY;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAEO,WAAA;AAAA,EACT;AAAA,EAEA,qBAAqB;AACnB,WAAOgC,uBAAqB;EAC9B;AACF;ACxFA,MAAM,uBAAuB,2BAA2B;AAAA,EACtD;AAAA,EACA,QAAQ;AAAA,EACR,YAAY;AACV,UAAM,EAAE,sBAAA,IAA0BvC,aAAW,aAAa;AAEnD,WAAA,UAAU,uBAAuB,OAAO,YAAY;AAAA,EAC7D;AACF,CAAC;AAED,MAAM,UAAU,CAAC,EAAE,QAAAC,eAAuC;AAAA,EACxD,sBAAsB;AACpB,UAAM,EAAE,sBAAA,IAA0BD,aAAW,aAAa;AAE1D,WAAO,OAAO,OAAOC,QAAO,YAAY,EAAE,IAAI,qBAAqB;AAAA,EACrE;AAAA,EAEA,gBAAgBM,MAAsB;AACpC,UAAM,EAAE,sBAAA,IAA0BP,aAAW,aAAa;AAEpD,UAAA,cAAcC,QAAO,aAAaM,IAAG;AAE3C,WAAOoB,QAAM,WAAW,IAAI,cAAc,sBAAsB,WAAW;AAAA,EAC7E;AAAA,EAEA,4BAA4B;AACnB,WAAA,KAAK,sBAAsB;AAAA;AAAA;AAAA,MAGhC,CAAC,EAAE,kBAA4C,gBAAgB;AAAA,IAAA;AAAA,EAEnE;AAAA,EAEA,uBAAuB,MAAoD;AACzE,QAAI,CAAC,MAAM;AACT,aAAO,KAAK;IACd;AAGA,WAAO,KAAK,sBAAsB,OAAOX,eAAkB,OAAO,IAAI,CAAC;AAAA,EACzE;AAAA,EAEA,MAAM,kBAAkB,aAAuC;AAC7D,UAAM,gBAAgB,MAAM,qBAAqB,iBAAiB,YAAY,GAAG;AAE1E,WAAA;AAAA,MACL,KAAK,YAAY;AAAA,MACjB,GAAG;AAAA,IAAA;AAAA,EAEP;AAAA,EAEA,MAAM,oBACJ,aACA,kBACA;AACA,UAAM,qBAAqB,iBAAiB,YAAY,KAAK,gBAAgB;AAEtE,WAAA,KAAK,kBAAkB,WAAW;AAAA,EAC3C;AAAA,EAEA,6BAA6B,aAAuC;AAElE,WAAOhB,aAAW,YAAY,EAAE,6BAA6B,WAAW;AAAA,EAC1E;AAAA,EAEA,qBAAqB;AACnB,WAAO,qBAAqB;EAC9B;AACF;AC1EA,MAAM,YAAY;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,MAAA,aAAe,OAAO;AAAA,EACpB,sBAAsB,aAAqC;AAClD,WAAA;AAAA,MACL,GAAG;AAAA,MACH,OAAO,YAAY;AAAA,MACnB,aAAa,UAAU,WAAW;AAAA,MAClC,YAAY;AAAA,QACV,IAAI;AAAA,UACF,MAAM;AAAA,QACR;AAAA,QACA,GAAG,iBAAiB,WAAW;AAAA,MACjC;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,OAAO,KAAK,SAAS;AACvB;AAEA,MAAM,mBAAmB,CAAC,gBAAwC;AAChE,QAAM,EAAE,sBAAsB,eAAe,iBAAA,IAAqBgB;AAGlE,SAAO,qBAAqB,WAAW,EACpC,OAAO,cAAc,WAAW,CAAC,EACjC,OAAO,iBAAiB,WAAW,CAAC,EACpC,OAAO,CAAC,KAAU,QAAgB;AAC3B,UAAA,YAAY,YAAY,WAAW,GAAG;AAGxC,QAAA,UAAU,SAAS,cAAc,UAAU,SAAS,YAAY,EAAE,SAAS,OAAO,GAAG;AAChF,aAAA;AAAA,IACT;AAEA,QAAI,GAAG,IAAI,gBAAgB,KAAK,SAAS;AAClC,WAAA;AAAA,EACT,GAAG,CAAE,CAAA;AACT;AAGA,MAAM,kBAAkB,CAAC,KAAU,cAA6C;AAC1E,MAAA,UAAU,SAAS,YAAY;AACjC,WAAO,WAAW,SAAS;AAAA,EAC7B;AAEO,SAAA;AACT;AAGA,MAAM,aAAa,CAAC,cAAyC;AACpD,SAAA;AAAA,IACL,GAAG;AAAA,IACH,MAAM;AAAA,IACN,aAAa,YAAY,YAAY,UAAU,SAAS;AAAA,IACxD,cAAc,UAAU;AAAA,EAAA;AAE5B;AAEA,MAAM,YAAY,CAAC,UACjB,MAAM,MAAM,yCAAyC,KAAK,MAAM;ACzElE,MAAM,EAAEwB,kBAAAA,mBAAqB,IAAA;AAI7B,MAAM,gBAA2B;AAAA,EAC/B,SAAS;AAAA,EACT,aAAa;AACf;AAEA,MAAM,YAAuB;AAAA,EAC3B,SAAS;AAAA,EACT,aAAa;AACf;AAEA,MAAM,cAAyB;AAAA,EAC7B,SAAS;AAAA,EACT,aAAa;AACf;AAEA,MAAM,aAAwC;AAAA;AAAA,EAE5C,aAAa;AAAA,EACb,WAAW;AAAA,EACX,MAAM;AAAA,EACN,UAAU;AAAA,EACV,QAAQ;AAAA;AAAA,EAER,UAAU;AAAA,EACV,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM;AAAA,EACN,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,OAAO;AAAA,EACP,SAAS;AAAA,EACT,QAAQ;AAAA;AAAA,EAER,UAAU;AAAA,EACV,OAAO;AAAA,EACP,aAAa;AAAA,EACb,OAAO;AAAA,EACP,UAAU;AAAA,EACV,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,WAAW;AAAA,EACX,KAAK;AACP;AAEA,MAAM,0BAA0B,CAAC,EAAE,QAAAvC,cAAsC;AACvE,QAAM,oBAAoB;AAAA,IACxB,mBAAmB;AACV,aAAA;AAAA,IACT;AAAA,IAEA,aAAa,MAAc;AAClB,aAAA,CAAC,CAAC,WAAW,IAAI;AAAA,IAC1B;AAAA,IAEA,aAAa,MAAe;AAC1B,UAAI,CAAC,MAAM;AACH,cAAA,IAAIuC,mBAAiB,sBAAsB;AAAA,MACnD;AAEM,YAAA,YAAY,WAAW,IAAI;AACjC,UAAI,CAAC,WAAW;AACd,cAAM,IAAIA,mBAAiB,sCAAsC,IAAI,EAAE;AAAA,MACzE;AAEO,aAAA;AAAA,IACT;AAAA,IAEA,aAAa,MAAc,MAAiB;AAC1C,UAAI,CAAC,MAAM;AACH,cAAA,IAAIA,mBAAiB,sBAAsB;AAAA,MACnD;AAEA,UAAI,CAAC,MAAM;AACH,cAAA,IAAIA,mBAAiB,sBAAsB;AAAA,MACnD;AAEA,iBAAW,IAAI,IAAI;AAAA,IACrB;AAAA,IAEA,2BAA2B;AAEzB,YAAM,eAAevC,QAAO,IAAI,eAAe,EAAE,OAAO;AAIjD,aAAA,QAAQ,YAAY,EAAE,QAAQ,CAAC,CAACM,MAAK,WAAW,MAAqB;AAC1E,YAAI,YAAY,WAAW;AACP,4BAAA,aAAaA,MAAK,YAAY,SAAS;AAAA,QAC3D;AAAA,MAAA,CACD;AAAA,IACH;AAAA,EAAA;AAGK,SAAA;AACT;ACjGA,MAAM,EAAE,oBAAwB,IAAAuB;AAEhC,MAAA,UAAe,CAAC,EAAE,QAAA7B,QAAA,MAAsC;AAChD,QAAA,2BAA2B,OAC/B,aACA,kBACG;AACH,UAAM,kBAAkB,KAAK,UAAU,cAAc,QAAQ,IAAI;AAC3D,UAAA,mBAAmB,oBAAoB,WAAW;AACxD,UAAM,4BAA4B;AAAA,MAChC;AAAA,MACA,cAAc,QAAQ;AAAA,IACtB,EAAA;AAEF,UAAM,OAAO;AAAA,MACX,iBAAiB,EAAE,0BAA0B,CAAC,CAAC,0BAA0B;AAAA,IAAA;AAGvE,QAAA,KAAK,gBAAgB,0BAA0B;AAC1C,aAAA,OAAO,KAAK,iBAAiB;AAAA,QAClC;AAAA,QACA;AAAA,MAAA,CACD;AAAA,IACH;AAEI,QAAA;AACF,YAAMA,QAAO,UAAU,KAAK,wBAAwB,IAAI;AAAA,aACjD,GAAG;AAAA,IAEZ;AAAA,EAAA;AAGK,SAAA;AAAA,IACL;AAAA,EAAA;AAEJ;ACrCA,MAAM,UAAU;AAAA,EACd,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,WAAW;AAAA,EACX,SAAS;AACX;AASA,MAAM,0BACJ,CAACA,YACD,CAAC,EAAE,aAAa,YAAiD;AAC/D,QAAM,qBAAqBA,QAAO,QAAQ,mBAAmB,EAAE,yBAAyB;AAAA,IACtF,SAAS;AAAA,IACT;AAAA,EAAA,CACD;AAED,QAAM,EAAE,eAAmB,IAAAA,QAAO,QAAQ,mBAAmB;AAEvD,QAAA,YAAY,CAAC,WAAoB;AACrC,WAAO,SAAS,mBAAmB,UAAU,QAAQ,KAAK,IAAI;AAAA,EAAA;AAKhE,QAAM,MAAM,CAAC,QAAgB,QAAiB,UAAkB;AACxD,UAAA,UAAU,UAAU,MAAM;AAChC,UAAM,UAAU,eAAe,iBAAiB,QAAQ,KAAK;AAE7D;AAAA;AAAA,MAEE,YAAY,IAAI,QAAQ,SAAS,KAAK;AAAA,MAEtC,QAAQ,KAAK,CAAC,UAAU,YAAY,IAAI,OAAO,SAAS,KAAK,CAAC;AAAA;AAAA,EAAA;AAMlE,QAAM,SAAS,CAAC,QAAgB,QAAiB,UAAkB;AAC3D,UAAA,UAAU,UAAU,MAAM;AAChC,UAAM,UAAU,eAAe,iBAAiB,QAAQ,KAAK;AAE7D;AAAA;AAAA,MAEE,YAAY,OAAO,QAAQ,SAAS,KAAK;AAAA,MAEzC,QAAQ,MAAM,CAAC,UAAU,YAAY,OAAO,OAAO,SAAS,KAAK,CAAC;AAAA;AAAA,EAAA;AAIhE,QAAA,iBAAiB,CAAC,MAAc,EAAE,SAAS,QAAQ,KAA8B,IAAA,OAAO;AACrF,WAAA,mBAAmB,eAAe,MAAM,EAAE,SAAS,UAAU,IAAI,GAAG,OAAA,CAAQ;AAAA,EAAA;AAG/E,QAAA,gBAAgB,CAAC,OAAc,EAAE,SAAS,QAAQ,KAA8B,IAAA,OAAO;AAC3F,WAAO,mBAAmB,cAAc,OAAO,EAAE,SAAS,OAAO,QAAQ;AAAA,EAAA;AAG3E,QAAM,gBAAgB,CAAC,QAAgB,MAAW,WAAoB;AAC7D,WAAA,mBAAmB,cAAc,MAAM;AAAA,MAC5C,SAAS,SAAS,UAAU,MAAM,IAAI;AAAA,MACtC;AAAA,IAAA,CACD;AAAA,EAAA;AAGG,QAAA,gBAAgB,CAAC,OAAc,EAAE,SAAS,QAAQ,KAA8B,IAAA,OAAO;AAC3F,WAAO,mBAAmB,cAAc,OAAO,EAAE,SAAS,OAAO,QAAQ;AAAA,EAAA;AAG3E,QAAM,gBAAgB,CAAC,QAAgB,MAAW,WAAoB;AAC7D,WAAA,mBAAmB,cAAc,MAAM;AAAA,MAC5C,SAAS,SAAS,UAAU,MAAM,IAAI;AAAA,MACtC;AAAA,IAAA,CACD;AAAA,EAAA;AAGH,QAAM,sBAAsB,CAAC,SAAc,cAAc,QAAQ,QAAQ,IAAI;AACvE,QAAA,sBAAsB,CAAC,WAAmB,CAAC,SAC/C,cAAc,QAAQ,QAAQ,MAAM,MAAM;AAE5C,QAAM,uBAAuB,CAAC,OAAc,SAA8B,CAAA,MAAO;AACxE,WAAA,mBAAmB,sBAAsB,OAAO,MAAM;AAAA,EAAA;AAG/D,QAAM,iBAAiB,CAAC,OAAc,SAA8B,CAAA,MAAO;AACzE,WAAO,MAAM;AAAA,MACX,CAAC,MAAa,cAAc,GAAG,MAAM;AAAA,MACrC,CAAC,MAAa,qBAAqB,GAAG,MAAM;AAAA,MAC5C,KAAK;AAAA,EAAA;AAIT,SAAO,KAAK,OAAO,EAAE,QAAQ,CAAC,WAAW;AAExB,mBAAA,MAAM,IAAI,CAAC,UAAiB,eAAe,OAAO,QAAQ,MAAM,CAAC;AAAA,EAAA,CACjF;AAGD,SAAO,KAAK,OAAO,EAAE,QAAQ,CAAC,WAAW;AAEnC,QAAA,MAAM,IAAI,IAAI,SAAc,IAAI,QAAQ,MAAM,GAAG,GAAG,IAAI;AAErD,WAAA,MAAM,IAAI,IAAI,SAAc,OAAO,QAAQ,MAAM,GAAG,GAAG,IAAI;AAAA,EAAA,CACnE;AAEM,SAAA;AAAA;AAAA,IAEL;AAAA;AAAA,IACA;AAAA;AAAA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,EAAA;AAEJ;AAEF,MAAA,oBAAe,CAAC,EAAE,QAAAA,QAAA,OAAuC;AAAA,EACvD,QAAQ,wBAAwBA,OAAM;AACxC;AClIA,MAAA,aAAe,CAAC,EAAE,QAAAA,QAAA,OAAuC;AAAA,EACvD,wBAAwB;AAAA,IACtB;AAAA,IACA;AAAA,EAAA,GAIC;AACD,UAAM,SAASe,eAAkB,aAAa,WAAW,IACrD,wDACA;AAEG,WAAA,YAAY,IAAI,MAAM;AAAA,EAC/B;AAAA,EAEA,MAAM,sBAAsB;AAC1B,UAAM,wBAAwBhB,aAAW,eAAe,EAAE,0BAA0B;AACpF,UAAM,mBAAmB,sBAAsB,IAAI,KAAK,KAAK,CAAC;AAE9D,UAAM,UAAU;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,aAAa;AAAA,QACb,KAAK;AAAA,QACL,YAAY;AAAA,QACZ,UAAU;AAAA,QACV,SAAS;AAAA,UACP,mBAAmB,CAAC,QAAQ;AAAA,QAC9B;AAAA,MACF;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,aAAa;AAAA,QACb,KAAK;AAAA,QACL,YAAY;AAAA,QACZ,UAAU;AAAA,QACV,SAAS;AAAA,UACP,mBAAmB,CAAC,QAAQ;AAAA,QAC9B;AAAA,MACF;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,aAAa;AAAA,QACb,KAAK;AAAA,QACL,YAAY;AAAA,QACZ,UAAU;AAAA,QACV,SAAS;AAAA,UACP,mBAAmB,CAAC,QAAQ;AAAA,QAC9B;AAAA,MACF;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,aAAa;AAAA,QACb,KAAK;AAAA,QACL,YAAY;AAAA,QACZ,UAAU;AAAA,MACZ;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,aAAa;AAAA,QACb,KAAK;AAAA,QACL,YAAY;AAAA,QACZ,UAAU;AAAA,MACZ;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,aAAa;AAAA,QACb,KAAK;AAAA,QACL,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,aAAa;AAAA,QACb,KAAK;AAAA,QACL,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,MACA;AAAA,QACE,SAAS;AAAA,QACT,aAAa;AAAA,QACb,KAAK;AAAA,QACL,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,IAAA;AAGF,UAAMC,QAAO,QAAQ,mBAAmB,EAAE,eAAe,aAAa,OAAO;AAAA,EAC/E;AACF;AC1FA,MAAM,EAAA,oBAAEqB,sBAAoB,mBAAmB,kCAAA,IAC7C,YAAY;AACd,MAAM,EAAE,YAAY,IAAI,YAAY;AACpC,MAAM,EAAA,wBAAEL,yBAA2B,IAAA,YAAY,aAAa;AAE5D,MAAM,oBAAoB,CAAC,cACzB,WAAW,SAAS,KAAK,UAAU,SAAS,SAAS,SAAS;AAChE,MAAM,UAAU,OAAO,QAAQ,OAAO;AACtC,MAAM,aAAa,OAAO,QAAQ,UAAU;AAC5C,MAAM,cAAc,OAAO,QAAQ,WAAW;AAC9C,MAAM,gBAAgB,OAAO,QAAQ,aAAa;AAqBlD,SAAS,uBACP,WACA,OACA,eACA,EAAE,WAAW,UAAU,mBACvB;AACM,QAAA,iBAAiB,YAAY,SAAS;AAE5C,MAAI,iBAAiB;AACZ,WAAA;AAAA,EACT;AAGA,MAAI,CAACK,qBAAmB,OAAO,aAAa,GAAG;AACtC,WAAA;AAAA,EACT;AAEA,MAAK,kBAAkB,aAAe,CAAC,kBAAkB,UAAW;AAC3D,WAAA,EAAE,OAAO;EAClB;AAEO,SAAA;AACT;AAQA,SAAS,iBACP,WACA,SACA,OACA;AAEA,QAAM,uBAAuB,UAAU,cAAc,CAAI,GAAA;AAAA,IACvD,CAAC,KAAU,kBAAiC;AAAA,MAC1C,GAAG;AAAA,MACH,CAAC,YAAY,GAAG;AAAA,QACd,UAAU,gBAAgB,cAAc,SAAS,QAAQ,CAAC;AAAA,MAC5D;AAAA,IAAA;AAAA,IAEF,CAAC;AAAA,EAAA;AAGI,SAAA,EAAE,IAAI;AACf;AAaA,SAAS,eACP,eACA,OACA,SACA,OACqC;AAC/B,QAAA,YAAY,MAAM,WAAW,aAAa;AAEhD,UAAQ,UAAU,MAAM;AAAA,IACtB,KAAK;AAEI,aAAA;AAAA,QACL,CAAC,aAAa,GAAG,uBAAuB,WAAW,OAAO,eAAe,OAAO;AAAA,MAAA;AAAA,IAEpF,KAAK;AACI,aAAA;AAAA,QACL,CAAC,aAAa,GAAG;AAAA,UACf,UAAU,gBAAgB,UAAU,WAAW,SAAS,QAAQ,CAAC;AAAA,QACnE;AAAA,MAAA;AAAA,IAEJ,KAAK;AACI,aAAA;AAAA,QACL,CAAC,aAAa,GAAG;AAAA,UACf,UAAU;AAAA,YACR,QAAQ;AAAA,UACV;AAAA,QACF;AAAA,MAAA;AAAA,IAEJ,KAAK;AACI,aAAA;AAAA,QACL,CAAC,aAAa,GAAG,iBAAiB,WAAW,SAAS,KAAK;AAAA,MAAA;AAAA,IAE/D;AACE,aAAO;EACX;AACF;AAQA,MAAM,kBAAkB,CACtBf,MACA;AAAA,EACE,kBAAkB,CAAC;AAAA,EACnB,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,WAAW;AACb,IAAqB,CACrB,GAAA,QAAQ,MACL;AACH,MAAI,QAAQ,UAAU;AACpB,WAAO;EACT;AAEM,QAAA,QAAQ,OAAO,SAASA,IAAG;AAEjC,SAAO,OAAO,KAAK,MAAM,UAAU,EAAE;AAAA,IACnC,CAAC,aAAa,kBACZ;AAAA,MACE;AAAA,MACA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA;AAAA,UAEE,iBAAiB,kBAAkB,aAAa;AAAA,UAChD;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,IACF,CAAC;AAAA,EAAA;AAEL;AAQA,MAAM,+BAA+B,CACnCA,MACA;AAAA,EACE,kBAAkB,CAAC;AAAA,EACnB,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,WAAW;AACb,IAAqB,CACrB,GAAA,QAAQ,MACL;AACH,MAAI,QAAQ,UAAU;AACpB,WAAO;EACT;AAEM,QAAA,QAAQ,OAAO,SAASA,IAAG;AAE1B,SAAA,OAAO,QAAQ,MAAM,UAAU,EAAE,OAAO,CAAC,aAAa,CAAC,eAAe,SAAS,MAAM;AACtF,QAAA,CAAC,kCAAkC,SAAS,GAAG;AAE1C,aAAA;AAAA,IACT;AAEI,QAAA,kBAAkB,SAAS,GAAG;AAChC,aAAO,MAAM,aAAa;AAAA,QACxB,CAAC,aAAa,GAAG;AAAA,MAAA,CAClB;AAAA,IACH;AAEO,WAAA;AAAA,MACL;AAAA,MACA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA;AAAA,UAEE,iBAAiB,kBAAkB,aAAa;AAAA,UAChD;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,QACA;AAAA,MACF;AAAA,IAAA;AAAA,EAEJ,GAAG,CAAE,CAAA;AACP;AAWA,MAAM,4BAA4B,CAACA,SAAoB;AAC/C,QAAA,QAAQ,OAAO,SAASA,IAAG;AACjC,MAAI,eAAe;AAEb,QAAA,WAAW,OAAO,KAAK,MAAM,UAAU,EAAE,OAAO,CAAC,aAAkB,kBAAkB;AACnF,UAAA,YAA2C,MAAM,WAAW,aAAa;AAE/E,YAAQ,UAAU,MAAM;AAAA,MACtB,KAAK,YAAY;AAEf,cAAM,kBAAkB,UAAU,SAAS,YAAY,EAAE,WAAW,OAAO;AAC3E,YAAI,iBAAiB;AACnB;AAAA,QACF;AAEI,YAAAe,qBAAmB,OAAO,aAAa,GAAG;AAC5C,sBAAY,aAAa,IAAI;AAAA,YAC3B,OAAO;AAAA,YACP,SAAS,EAAE,CAACL,wBAAsB,GAAG,EAAE,OAAO,OAAO;AAAA,UAAA;AAExC,yBAAA;AAAA,QACjB;AACA;AAAA,MACF;AAAA,MACA,KAAK,aAAa;AAChB,cAAM,EAAE,UAAAwB,WAAU,cAAc,kBAAsB,IAAA;AAAA,UACpD,UAAU;AAAA,QAAA;AAEZ,YAAI,mBAAmB;AACrB,sBAAY,aAAa,IAAI;AAAA,YAC3B,UAAAA;AAAAA,UAAA;AAEa,yBAAA;AAAA,QACjB;AACA;AAAA,MACF;AAAA,MACA,KAAK,eAAe;AAClB,cAAM,qBAAqB,UAAU,YAAY,OAAO,CAAC,KAAK,iBAAiB;AAC7E,gBAAM,EAAE,UAAU,mBAAmB,cAAc,0BACjD,0BAA0B,YAAY;AAExC,cAAI,uBAAuB;AACV,2BAAA;AAER,mBAAA,EAAE,GAAG,KAAK,CAAC,YAAY,GAAG,EAAE,UAAU,kBAAA;UAC/C;AAEO,iBAAA;AAAA,QACT,GAAG,CAAE,CAAA;AAED,YAAA,CAAC,QAAQ,kBAAkB,GAAG;AAChC,sBAAY,aAAa,IAAI,EAAE,IAAI,mBAAmB;AAAA,QACxD;AACA;AAAA,MACF;AAAA,IAEF;AAEO,WAAA;AAAA,EACT,GAAG,CAAE,CAAA;AAEE,SAAA,EAAE,UAAU;AACrB;AAKA,MAAM,mBAAmB,OAAOlC,MAAiB,UAAqC;AACpF,MAAI,gBAA0B,CAAA;AAE9B,QAAM,YAAY,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASzB,CAAC,EAAE,WAAW,WAAgB;AAE5B,UAAI,CAAC,aAAa,cAAc,SAAS,KAAK,kBAAkB,SAAS,GAAG;AAC1E;AAAA,MACF;AAGI,UAAA,WAAW,SAAS,KAAK,QAAQ,SAAS,KAAK,YAAY,SAAS,GAAG;AACzE,cAAM,eAAe,KAAK,UAAU,QAAQ,OAAO,YAAY;AAE/D,wBAAgB,IAAI,cAAc,CAAC,GAAG,aAAa;AAAA,MACrD;AAAA,IACF;AAAA,IACA,EAAE,QAAQ,OAAO,SAASA,IAAG,GAAG,UAAU,OAAO,SAAS,KAAK,MAAM,EAAE;AAAA,IACvE;AAAA,EAAA;AAGK,SAAA;AACT;AAEA,MAAM,oBAAoB,CAACA,SAA4B;AAC9C,SAAAP,aAAW,kBAAkB,EAAEO,IAAG,EAAE,aAAa,QAAQ,EAAE,iBAAiB;AACrF;ACpUA,MAAM,kBAAkB,CAACA,SAAoB;AAC3C,MAAI,qBAAqB,YAA2C;AAC3D,WAAA;AAAA,EAAA;AAET,QAAM,sBAAsB;AAAA,IAC1B,WAAW;AAAA,IACX,UAAU;AAAA,IACV,UAAU;AAAA,EAAA;AAGZ,QAAM,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,IAKd,kBAAkB,OAAe;AACV,2BAAA,YAAY,iBAAiBA,MAAK,KAAK;AACrD,aAAA;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,eAAe,EAAE,QAAQ,MAAM,IAAI,EAAE,QAAQ,MAAM,OAAO,QAAQ;AAC5D,UAAA,CAACoB,QAAM,MAAM,GAAG;AAClB,4BAAoB,YAAY;AAAA,MAClC;AACI,UAAA,CAACA,QAAM,KAAK,GAAG;AACjB,4BAAoB,WAAW;AAAA,MACjC;AACO,aAAA;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,aAAa,QAAQ,UAAU;AAC7B,0BAAoB,WAAW;AACxB,aAAA;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,MAAM,QAAQ;AACN,YAAA,kBAAkB,MAAM;AAE1B,UAAA,oBAAoB,aAAa,IAAI;AAChC,eAAA;AAAA,MACT;AAEA,aAAO,gBAAgBpB,MAAK,EAAE,GAAG,qBAAqB,gBAAiB,CAAA;AAAA,IACzE;AAAA,EAAA;AAGK,SAAA;AACT;AAEA,MAAA,oBAAe,MAAM;ACxErB,MAAA,MAAe,CAAC,EAAE,QAAAN,QAAA,OAAuC;AAAA,EACvD,MAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA,GAMC;AACK,UAAA,cAAcA,QAAO,aAAa,cAAc;AAChD,UAAA,EAAE,WAAe,IAAA;AAEjB,UAAA;AAAA,MACJ;AAAA,MACA,SAAS;AAAA,MACT;AAAA,IAAA,IACE,WAAW,KAAK;AAGpB,UAAM,cAAc,EAAE,IAAI,MAAM,WAAW;AAE3C,QAAI,CAAC,EAAE,QAAQ,WAAW,GAAG;AAC3B,aAAO,KAAK,cAAc;AAAA,QACxB;AAAA,QACA;AAAA,QACA,OAAO,QAAQ,aAAa,OAAO;AAAA,QACnC;AAAA,MAAA,CACD;AAAA,IACH;AAEA,WAAO,KAAK,cAAc;AAAA,MACxB;AAAA,MACA;AAAA,MACA,OAAO;AAAA,QACL,EAAE,WAAW,YAAY,IAAI,aAAa,IAAI,gBAAgB,YAAY;AAAA,QAC1E;AAAA,MACF;AAAA,MACA;AAAA,IAAA,CACD;AAAA,EACH;AAAA,EAEA,MAAM,cAAc;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA,GAMC;AACD,UAAM,iBAAiB,MAAMA,QAAO,UAAU,cAAc,EAAE,SAAS;AAAA,MACrE,SAAS;AAAA,QACP,CAAC,KAAK,GAAG,EAAE,aAAa,MAAM;AAAA,MAChC;AAAA,MACA;AAAA;AAAA;AAAA,MAGA,QAAQ;AAAA,IAAA,CACT;AAED,QAAI,CAAC,kBAAkB,eAAe,WAAW,GAAG;AAE3C,aAAA;AAAA,IACT;AAEI,QAAA;AACJ,QAAI,CAAC,MAAM,QAAQ,cAAc,GAAG;AACb,2BAAA,CAAC,eAAe,KAAK,CAAC;AAAA,IAAA,OACtC;AACL,2BAAqB,eAAe,IAAI,CAAC,QAAa,IAAI,KAAK,CAAC;AAAA,IAClE;AAGA,QAAI,CAAC,mBAAmB,SAAS,KAAK,GAAG;AAChC,aAAA;AAAA,IACT;AAEA,QAAI,IAAI;AACR,QAAI,SAAS,GAAG,KAAK,IAAI,CAAC;AACnB,WAAA,mBAAmB,SAAS,MAAM,GAAG;AAGrC,WAAA;AACI,eAAA,GAAG,KAAK,IAAI,CAAC;AAAA,IACxB;AAEO,WAAA;AAAA,EACT;AAAA,EAEA,MAAM,qBAAqB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA,GAMC;AACD,UAAM,gBAAgB,MAAMA,QAAO,UAAU,cAAc,EAAE,MAAM;AAAA,MACjE,SAAS;AAAA,QACP,CAAC,KAAK,GAAG;AAAA,MACX;AAAA,MACA;AAAA;AAAA;AAAA,MAGA,QAAQ;AAAA,IAAA,CACT;AAEG,QAAA,iBAAiB,gBAAgB,GAAG;AAE/B,aAAA;AAAA,IACT;AAEO,WAAA;AAAA,EACT;AACF;AC/GA,MAAM,0BAA0B;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AACA,MAAM,2BAA2B;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,MAAM,yBAAyB;AAAA,EAC7B,WAAW;AAAA,EACX,OAAO;AAAA,EACP,UAAU;AACZ;AAmBA,MAAM,iCAAiC,CACrC,SACA,iBACY;AACZ,MAAI,CAAC,WAAW,CAAC,QAAQ,WAAW;AAC3B,WAAA;AAAA,EACT;AAEM,QAAA,mBAAmB,SAAS,YAAY,IAAI,KAAK,QAAQ,SAAS,EAAE,QAAY,IAAA;AAEhF,QAAA,iBAAiB,cAAc,YAAY,IAAI,KAAK,aAAa,SAAS,EAAE,QAAY,IAAA;AAE9F,SAAO,mBAAmB;AAC5B;AAEA,MAAA,mBAAe,CAAC,EAAE,QAAAA,QAAA,OAAuC;AAAA;AAAA;AAAA;AAAA,EAIvD,MAAM,oBACJM,MACA,SACA,aACA,oBAA8B,CAAA,GAC9B;AAEM,UAAA,mBAAmB,QAAQ,UAAU,WAAW;AAG/C,WAAA,iBAAiB,QAAQ,MAAM;AAKhC,UAAA,QAAQN,QAAO,SAASM,IAAG;AACjC,UAAM,aAAa,CAAC,GAAG,0BAA0B,GAAG,iBAAiB;AAE/D,UAAA,oBAAoB,OAAO,kBAC/B;AAAA,MACE,CAAC,EAAE,IAAA,GAAO,EAAE,aAAa;AACnB,YAAA,WAAW,SAAS,GAAG,GAAG;AAE5B;AAAA,QACF;AAGA,eAAO,GAAG;AAAA,MACZ;AAAA,MACA,EAAE,QAAQ,OAAO,UAAUN,QAAO,SAAS,KAAKA,OAAM,EAAE;AAAA;AAAA,MAExD;AAAA,IAAA;AAGE,UAAA,gBAAgB,MAAM,MAAM;AAAA,MAChC,OAAO,OAAO,gBAAgB;AAAA,MAC9B,OAAO,mBAAsC;AACrC,cAAA,uBAA0C,MAAM,MAAM;AAAA,UAC1D;AAAA,UACA;AAAA,QAAA;AAGF,YAAI,CAACQ,eAAa,mBAAmB,KAAK,GAAG;AAC3C,iBAAO,qBAAqB,CAAC;AAAA,QAC/B;AAEA,cAAM,eAAe,qBAAqB,KAAK,CAAC,MAAM,EAAE,gBAAgB,IAAI;AACtE,cAAA,gBAAgB,qBAAqB,OAAO,CAAC,MAAM,EAAE,OAAO,cAAc,EAAE;AAElF,YAAI,CAAC,cAAc;AACjB;AAAA,QACF;AAEO,eAAA;AAAA,UACL,GAAG;AAAA,UACH,QAAQ,KAAK,UAAU,cAAc,aAAoB;AAAA,QAAA;AAAA,MAE7D;AAAA,IAAA;AAIA,WAAA,cAEG,OAAO,OAAO;AAAA,EAErB;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,SAA0B,aAAgC;AAE3E,UAAM,SACJ,QAAQ,gBAAgB,OACpB,uBAAuB,QACvB,uBAAuB;AAG7B,UAAM,kBAAkB,YAAY,KAAK,CAAC,MAAM;AACxC,YAAA,cAAc,EAAE,WAAW,QAAQ;AACzC,YAAM,cAAc,WAAW,cAAc,EAAE,gBAAgB,OAAO,EAAE,gBAAgB;AACxF,aAAO,eAAe;AAAA,IAAA,CACvB;AAED,QAAI,CAAC;AAAwB,aAAA;AAGtB,WAAA,KAAK,yBAAyB,eAAe;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,uBAAuBF,MAAsB,WAA8B;AAC/E,QAAI,CAAC,UAAU;AAAQ,aAAO;AAG9B,UAAM,SAAS,UAAU,CAAC,EAAE,gBAAgB,OAAO,cAAc;AAC3D,UAAA,SAAS,UAAU,CAAC,GAAG;AACvB,UAAA,cAAc,WAAW,cAAc,UAAU;AAEvD,WAAON,QAAO,UAAUM,IAAG,EAAE,SAAS;AAAA,MACpC,SAAS;AAAA,QACP,YAAY,EAAE,KAAK,UAAU,IAAI,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,OAAO,EAAE;AAAA,MACxE;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA,QAAQ,CAAC,cAAc,UAAU,aAAa,aAAa,aAAa;AAAA,IAAA,CACzE;AAAA,EACH;AAAA,EAEA,UAAU,SAA0B,uBAA6D;AAC3F,QAAA;AACA,QAAA;AAEJ,QAAI,QAAQ,aAAa;AACJ,yBAAA;AAAA,IAAA,OACd;AACU,qBAAA;AAAA,IACjB;AAEM,UAAA,eAAe,uBAAuB,GAAG,CAAC;AAChD,QAAI,cAAc,aAAa;AACV,yBAAA;AAAA,eACV,cAAc;AACR,qBAAA;AAAA,IACjB;AAEA,QAAI,CAAC;AAAc,aAAO,uBAAuB;AACjD,QAAI,CAAC;AAAkB,aAAO,uBAAuB;AAM/C,UAAA,kBAAkB,+BAA+B,cAAc,gBAAgB;AAC9E,WAAA,kBAAkB,uBAAuB,WAAW,uBAAuB;AAAA,EACpF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YACJA,MACA,SACA,EAAE,mBAAmB,MAAM,kBAAkB,KAA6B,IAAA,IAC1E;AAGM,UAAA,WAAW,6BAA6BA,IAAG;AACjD,UAAM,WAAW,MAAMN,QAAO,GAAG,MAAMM,IAAG,EAAE,SAAS;AAAA,MACnD,OAAO,EAAE,YAAY,QAAQ,WAAW;AAAA,MACxC,UAAU;AAAA;AAAA,QAER,GAAG;AAAA;AAAA,QAEH,WAAW;AAAA,UACT,QAAQ,CAAC,MAAM,aAAa,YAAY,OAAO;AAAA,QACjD;AAAA,QACA,WAAW;AAAA,UACT,QAAQ,CAAC,MAAM,aAAa,YAAY,OAAO;AAAA,QACjD;AAAA,MACF;AAAA,IAAA,CACD;AAED,UAAM,yBAAyB,mBAC3B,MAAM,KAAK,oBAAoBA,MAAK,SAAS,UAAU,OAAO,KAAK,QAAQ,CAAC,IAC5E,CAAA;AAEJ,UAAM,wBAAwB,kBAC1B,KAAK,mBAAmB,SAAS,QAAQ,IACzC;AAEG,WAAA;AAAA,MACL,kBAAkB;AAAA,MAClB,iBAAiB,wBAAwB,CAAC,qBAAqB,IAAI,CAAC;AAAA,IAAA;AAAA,EAExE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,2BACJA,MACA,UACA,OAA2B,CAAA,GAC3B;AACA,QAAI,CAAC,UAAU;AACN,aAAA;AAAA,QACL,MAAM;AAAA,QACN,MAAM;AAAA,UACJ,kBAAkB,CAAC;AAAA,UACnB,iBAAiB,CAAC;AAAA,QACpB;AAAA,MAAA;AAAA,IAEJ;AAEA,UAAM,qBAAqBE,eAAa,mBAAmBR,QAAO,SAASM,IAAG,CAAC;AAG/E,QAAI,CAAC,oBAAoB;AACvB,WAAK,kBAAkB;AAAA,IACzB;AAEA,UAAM,OAAO,MAAM,KAAK,YAAYA,MAAK,UAAU,IAAI;AAEhD,WAAA;AAAA,MACL,MAAM;AAAA,QACJ,GAAG;AAAA;AAAA,QAEH,QAAQ,qBACJ,KAAK,UAAU,UAAU,KAAK,eAAsB,IACpD;AAAA,MACN;AAAA,MACA;AAAA,IAAA;AAAA,EAEJ;AACF;ACxSA,MAAM,EAAE,mBAAmB,IAAI,YAAY;AAS3C,MAAM,iBAAiB,CAAC,QAAaA,SAAqB;AAClD,QAAA,QAAQ,OAAO,SAASA,IAAG;AAE1B,SAAA,OAAO,KAAK,MAAM,UAAU,EAAE,OAAO,CAAC,KAAK,kBAAkB;AAC5D,UAAA,YAAiB,MAAM,WAAW,aAAa;AAC/C,UAAA,QAAQ,OAAO,aAAa;AAClC,QAAI,CAAC,OAAO;AACH,aAAA;AAAA,IACT;AAEA,YAAQ,UAAU,MAAM;AAAA,MACtB,KAAK,YAAY;AACX,YAAA,mBAAmB,OAAO,aAAa,GAAG;AAC5C,iBAAO,MAAM,MAAM;AAAA,QACrB;AACO,eAAA;AAAA,MACT;AAAA,MACA,KAAK,aAAa;AAChB,cAAM,WAAW,UAAU,KAAK,EAAE,OAAO,CAAC,KAAK,mBAAmB;AAChE,iBAAO,MAAM,eAAe,gBAAgB,UAAU,SAAS;AAAA,WAC9D,CAAC;AACJ,eAAO,MAAM;AAAA,MACf;AAAA,MACA,KAAK,eAAe;AAClB,cAAM,QAAQ,MAAM,OAAO,CAAC,KAAU,mBAAwB;AAC5D,iBAAO,MAAM,eAAe,gBAAgB,eAAe,WAAW;AAAA,WACrE,CAAC;AACJ,eAAO,MAAM;AAAA,MACf;AAAA,MACA;AACS,eAAA;AAAA,IACX;AAAA,KACC,CAAC;AACN;ACjCA,MAAM,EAAE,iBAAqB,IAAA;AAC7B,MAAM,EAAE,uBAAuB,IAAIE,eAAa;AAEhD,MAAM,uBAAuB,KAAK,sBAAsB;AACxD,MAAM,cAAc,KAAK,IAAI;AAE7B,MAAM,kBAAkB,CAAC,EAAE,QAAAR,cAAsC;AACxD,SAAA;AAAA,IACL,MAAM,QACJ,IACAM,MACA,OAAwD,CAAA,GACxD;AACO,aAAAN,QAAO,UAAUM,IAAG,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,GAAA,CAAI;AAAA,IAClE;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,YACJ,IACAA,MACA,MAKA;AAEA,YAAM,QAAa,CAAA;AAGnB,UAAI,IAAI;AACN,cAAM,aAAa;AAAA,MACrB;AAGA,UAAI,MAAM,QAAQ,KAAK,MAAM,GAAG;AAC9B,cAAM,SAAS,EAAE,KAAK,KAAK,OAAO;AAAA,MACzB,WAAA,KAAK,UAAU,KAAK,WAAW,KAAK;AAE7C,cAAM,SAAS,KAAK;AAAA,MACtB;AAGI,UAAA,OAAO,KAAK,gBAAgB,WAAW;AACzC,cAAM,cAAc,EAAE,UAAU,KAAK,YAAY;AAAA,MACnD;AAEO,aAAAN,QAAO,GAAG,MAAMM,IAAG,EAAE,SAAS,EAAE,UAAU,KAAK,UAAU,MAAO,CAAA;AAAA,IACzE;AAAA,IAEA,MAAM,SAAS,MAAoCA,MAAyB;AAC1E,YAAM,SAAS,EAAE,GAAG,MAAM,UAAU,gBAAgBA,IAAG;AACvD,aAAON,QAAO,UAAUM,IAAG,EAAE,SAAS,MAAM;AAAA,IAC9C;AAAA,IAEA,MAAM,SAAS,MAAoCA,MAAyB;AAC1E,YAAM,SAAS,WAAW,sBAAsB,QAAQ,CAAA,GAAI;AAAA,QAC1D,UAAU;AAAA,MAAA,CACX;AAED,YAAM,CAAC,WAAW,QAAQ,CAAC,IAAI,MAAM,QAAQ,IAAI;AAAA,QAC/CN,QAAO,UAAUM,IAAG,EAAE,SAAS,MAAM;AAAA,QACrCN,QAAO,UAAUM,IAAG,EAAE,MAAM,MAAM;AAAA,MAAA,CACnC;AAEM,aAAA;AAAA,QACL,SAAS;AAAA,QACT,YAAY,WAAW,6BAA6B,QAAQ,KAAK;AAAA,MAAA;AAAA,IAErE;AAAA,IAEA,MAAM,OAAOA,MAAyB,OAAmC,IAAW;AAClF,YAAM,WAAW,KAAK,YAAa,MAAM,kBAAkBA,IAAG;AAC9D,YAAM,SAAS,EAAE,GAAG,MAAM,QAAQ,SAAkB;AAEpD,aAAON,QAAO,UAAUM,IAAG,EAAE,OAAO,MAAM;AAAA,IAC5C;AAAA,IAEA,MAAM,OACJ,IACAA,MACA,OAAuD,CAAA,GACvD;AACM,YAAA,cAAc,KAAK,sBAAsB,WAAW,EAAE,KAAK,QAAQ,CAAA,CAAE;AAC3E,YAAM,WAAW,KAAK,YAAa,MAAM,kBAAkBA,IAAG;AACxD,YAAA,SAAS,EAAE,GAAG,MAAM,MAAM,aAAa,UAAU,QAAQ;AAExD,aAAAN,QAAO,UAAUM,IAAG,EAAE,OAAO,EAAE,GAAG,QAAQ,YAAY,GAAA,CAAI;AAAA,IACnE;AAAA,IAEA,MAAM,MACJ,IACA,MACAA,MACA;AACM,YAAA,WAAW,MAAM,kBAAkBA,IAAG;AAC5C,YAAM,SAAS;AAAA,QACb,MAAM,YAAY,IAAI;AAAA,QACtB;AAAA,MAAA;AAGF,aAAON,QACJ,UAAUM,IAAG,EACb,MAAM,EAAE,GAAG,QAAQ,YAAY,GAAI,CAAA,EACnC,KAAK,CAAC,WAAW,QAAQ,QAAQ,GAAG,CAAC,CAAC;AAAA,IAC3C;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,OAAOA,MAAyB,IAAa;AAEjD,UAAI,IAAI;AACN,cAAMmC,SAAQ,MAAMzC,QAAO,GAAG,MAAMM,IAAG,EAAE,MAAM,EAAE,OAAO,EAAE,YAAY,GAAA,EAAM,CAAA;AAC5E,eAAOmC,SAAQ;AAAA,MACjB;AAGA,YAAM,QAAQ,MAAMzC,QAAO,GAAG,MAAMM,IAAG,EAAE;AACzC,aAAO,QAAQ;AAAA,IACjB;AAAA,IAEA,MAAM,OACJ,IACAA,MACA,OAAuD,CAAA,GACvD;AACM,YAAA,WAAW,MAAM,kBAAkBA,IAAG;AAE5C,YAAMN,QAAO,UAAUM,IAAG,EAAE,OAAO;AAAA,QACjC,GAAG;AAAA,QACH,YAAY;AAAA,QACZ;AAAA,MAAA,CACD;AACD,aAAO;IACT;AAAA;AAAA,IAGA,MAAM,WACJ,aACAA,MACA,OAA2D,CAAA,GAC3D;AACA,YAAM,iBAAiB,MAAMN,QAAO,GAAG,YAAY,YAAY;AAC7D,eAAO,QAAQ,IAAI,YAAY,IAAI,OAAO,OAAO,KAAK,OAAO,IAAIM,MAAK,IAAI,CAAC,CAAC;AAAA,MAAA,CAC7E;AAEM,aAAA,EAAE,OAAO,eAAe;IACjC;AAAA,IAEA,MAAM,QACJ,IACAA,MACA,OAAwD,CAAA,GACxD;AACM,YAAA,WAAW,MAAM,kBAAkBA,IAAG;AAC5C,YAAM,SAAS,EAAE,GAAG,MAAM,SAAS;AAEnC,aAAON,QACJ,UAAUM,IAAG,EACb,QAAQ,EAAE,GAAG,QAAQ,YAAY,GAAA,CAAI,EACrC,KAAK,CAAC,WAAW,QAAQ,OAAO;AAAA,IACrC;AAAA,IAEA,MAAM,YAAYA,MAAsB,aAAuB,QAA4B;AAClF,aAAAN,QAAO,GAAG,YAAY,YAAY;AACjC,cAAA,UAAU,MAAM,QAAQ;AAAA,UAC5B,YAAY,IAAI,CAAC,eAAe,KAAK,QAAQ,YAAYM,MAAK,EAAE,OAAO,CAAC,CAAC;AAAA,QAAA;AAG3E,cAAM,yBAAyB,QAAQ,KAAA,EAAO,OAAO,OAAO,EAAE;AACvD,eAAA;AAAA,MAAA,CACR;AAAA,IACH;AAAA,IAEA,MAAM,cACJ,aACAA,MACA,OAA0D,CAAA,GAC1D;AACA,YAAM,qBAAqB,MAAMN,QAAO,GAAG,YAAY,YAAY;AACjE,eAAO,QAAQ;AAAA,UACb,YAAY;AAAA,YAAI,CAAC,OACfA,QACG,UAAUM,IAAG,EACb,UAAU,EAAE,GAAG,MAAM,YAAY,GAAI,CAAA,EACrC,KAAK,CAAC,WAAW,QAAQ,OAAO;AAAA,UACrC;AAAA,QAAA;AAAA,MACF,CACD;AAED,YAAM,2BAA2B,mBAAmB,KAAA,EAAO,OAAO,OAAO,EAAE;AAGpE,aAAA,EAAE,OAAO;IAClB;AAAA,IAEA,MAAM,UACJ,IACAA,MACA,OAA0D,CAAA,GAC1D;AACM,YAAA,WAAW,MAAM,kBAAkBA,IAAG;AAC5C,YAAM,SAAS,EAAE,GAAG,MAAM,SAAS;AAEnC,aAAON,QACJ,UAAUM,IAAG,EACb,UAAU,EAAE,GAAG,QAAQ,YAAY,GAAI,CAAA,EACvC,KAAK,CAAC,WAAW,QAAQ,QAAQ,GAAG,CAAC,CAAC;AAAA,IAC3C;AAAA,IAEA,MAAM,aACJ,IACAA,MACA,OAA6D,CAAA,GAC7D;AACM,YAAA,WAAW,MAAM,kBAAkBA,IAAG;AAC5C,YAAM,SAAS,EAAE,GAAG,MAAM,SAAS;AAEnC,aAAON,QACJ,UAAUM,IAAG,EACb,aAAa,EAAE,GAAG,QAAQ,YAAY,GAAI,CAAA,EAC1C,KAAK,CAAC,WAAW,QAAQ,QAAQ,GAAG,CAAC,CAAC;AAAA,IAC3C;AAAA,IAEA,MAAM,oBAAoB,IAAYA,MAAsB,QAAgB;AAC1E,YAAM,EAAE,UAAU,aAAa,IAAI,0BAA0BA,IAAG;AAEhE,UAAI,CAAC,cAAc;AACV,eAAA;AAAA,MACT;AACA,YAAM,WAAW,MAAMN,QAAO,UAAUM,IAAG,EAAE,QAAQ,EAAE,YAAY,IAAI,UAAU,OAAQ,CAAA;AACzF,UAAI,CAAC,UAAU;AACb,cAAM,IAAI;AAAA,UACR,qDAAqD,EAAE,eAAe,MAAM;AAAA,QAAA;AAAA,MAEhF;AAEO,aAAA,eAAe,UAAUA,IAAG;AAAA,IACrC;AAAA,IAEA,MAAM,+BACJ,aACAA,MACA,QACA;AACA,YAAM,EAAE,UAAU,aAAa,IAAI,0BAA0BA,IAAG;AAEhE,UAAI,CAAC,cAAc;AACV,eAAA;AAAA,MACT;AAEA,UAAI,eAAe,CAAA;AACnB,UAAI,QAAQ;AACV,uBAAe,MAAM,QAAQ,MAAM,IAAI,EAAE,QAAQ,EAAE,KAAK,OAAO,MAAM,EAAE,OAAO;AAAA,MAChF;AAEA,YAAM,WAAW,MAAMN,QAAO,GAAG,MAAMM,IAAG,EAAE,SAAS;AAAA,QACnD;AAAA,QACA,OAAO;AAAA,UACL,YAAY,EAAE,KAAK,YAAY;AAAA,UAC/B,GAAG;AAAA,QACL;AAAA,MAAA,CACD;AAED,YAAM,4BAAoC,SAAU;AAAA,QAClD,CAAC,OAAe,WAAqB,eAAe,QAAQA,IAAG,IAAI;AAAA,QACnE;AAAA,MAAA;AAGK,aAAA;AAAA,IACT;AAAA,EAAA;AAEJ;AClRA,MAAe,WAAA;AAAA,EACb;AAAA,EACA,iBAAiBE;AAAAA,EACjB,eAAe;AAAA,EACf,qBAAqB;AAAA,EACrB,oBAAoB;AAAA,EACpB,eAAekC;AAAAA,EACf;AAAA,EACA,sBAAsB;AAAA,EACtB;AAAA,EACA,oBAAoBC;AAAAA,EACpB;AAAA,EACA,GAAI,QAAQ,WAAW,QAAQ,WAAW,CAAC;AAC7C;AClBA,MAAA,QAAe,MAAM;AACZ,SAAA;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ;"}