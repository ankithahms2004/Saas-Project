"use strict";
const strapiUtils = require("@strapi/utils");
const fp = require("lodash/fp");
require("@strapi/types");
const yup = require("yup");
const nodeSchedule = require("node-schedule");
const isNil = require("lodash/isNil");
const _ = require("lodash");
const qs = require("qs");
const slugify = require("@sindresorhus/slugify");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const strapiUtils__default = /* @__PURE__ */ _interopDefault(strapiUtils);
const yup__namespace = /* @__PURE__ */ _interopNamespace(yup);
const isNil__default = /* @__PURE__ */ _interopDefault(isNil);
const ___default = /* @__PURE__ */ _interopDefault(_);
const qs__default = /* @__PURE__ */ _interopDefault(qs);
const slugify__default = /* @__PURE__ */ _interopDefault(slugify);
const getService$1 = (name) => {
  return strapi.plugin("content-manager").service(name);
};
function getService(strapi2, name) {
  return strapi2.service(`plugin::content-manager.${name}`);
}
const historyRestoreVersionSchema = yup__namespace.object().shape({
  contentType: yup__namespace.string().trim().required()
}).required();
const validateRestoreVersion = strapiUtils.validateYupSchema(historyRestoreVersionSchema);
const getValidPagination = ({ page, pageSize }) => {
  let pageNumber = 1;
  let pageSizeNumber = 20;
  if (page) {
    const parsedPage = parseInt(page, 10);
    pageNumber = parseInt(page, 10);
    if (!Number.isNaN(parsedPage) && parsedPage >= 1) {
      pageNumber = parsedPage;
    }
  }
  if (pageSize) {
    const parsedPageSize = parseInt(pageSize, 10);
    if (!Number.isNaN(parsedPageSize) && parsedPageSize >= 1 && parsedPageSize <= 100) {
      pageSizeNumber = parsedPageSize;
    }
  }
  return { page: pageNumber, pageSize: pageSizeNumber };
};
const createHistoryVersionController = ({ strapi: strapi2 }) => {
  return {
    async findMany(ctx) {
      const contentTypeUid = ctx.query.contentType;
      const isSingleType = strapi2.getModel(contentTypeUid)?.kind === "singleType";
      if (isSingleType && !contentTypeUid) {
        throw new strapiUtils.errors.ForbiddenError("contentType is required");
      }
      if (!isSingleType && (!contentTypeUid || !ctx.query.documentId)) {
        throw new strapiUtils.errors.ForbiddenError("contentType and documentId are required");
      }
      const permissionChecker2 = getService$1("permission-checker").create({
        userAbility: ctx.state.userAbility,
        model: ctx.query.contentType
      });
      if (permissionChecker2.cannot.read()) {
        return ctx.forbidden();
      }
      const query = await permissionChecker2.sanitizeQuery(ctx.query);
      const { results, pagination } = await getService(strapi2, "history").findVersionsPage({
        query: {
          ...query,
          ...getValidPagination({ page: query.page, pageSize: query.pageSize })
        },
        state: { userAbility: ctx.state.userAbility }
      });
      const sanitizedResults = await strapiUtils.async.map(
        results,
        async (version) => {
          return {
            ...version,
            data: await permissionChecker2.sanitizeOutput(version.data),
            createdBy: version.createdBy ? fp.pick(["id", "firstname", "lastname", "username", "email"], version.createdBy) : void 0
          };
        }
      );
      return {
        data: sanitizedResults,
        meta: { pagination }
      };
    },
    async restoreVersion(ctx) {
      const request = ctx.request;
      await validateRestoreVersion(request.body, "contentType is required");
      const permissionChecker2 = getService$1("permission-checker").create({
        userAbility: ctx.state.userAbility,
        model: request.body.contentType
      });
      if (permissionChecker2.cannot.update()) {
        throw new strapiUtils.errors.ForbiddenError();
      }
      const restoredDocument = await getService(strapi2, "history").restoreVersion(
        request.params.versionId
      );
      return {
        data: { documentId: restoredDocument.documentId }
      };
    }
  };
};
const controllers$1 = {
  "history-version": createHistoryVersionController
  /**
   * Casting is needed because the types aren't aware that Strapi supports
   * passing a controller factory as the value, instead of a controller object directly
   */
};
const HISTORY_VERSION_UID = "plugin::content-manager.history-version";
const FIELDS_TO_IGNORE = [
  "createdAt",
  "updatedAt",
  "publishedAt",
  "createdBy",
  "updatedBy",
  "strapi_stage",
  "strapi_assignee"
];
const DEFAULT_RETENTION_DAYS = 90;
const createServiceUtils = ({ strapi: strapi2 }) => {
  const getSchemaAttributesDiff = (versionSchemaAttributes, contentTypeSchemaAttributes) => {
    const sanitizedContentTypeSchemaAttributes = fp.omit(
      FIELDS_TO_IGNORE,
      contentTypeSchemaAttributes
    );
    const reduceDifferenceToAttributesObject = (diffKeys, source) => {
      return diffKeys.reduce(
        (previousAttributesObject, diffKey) => {
          previousAttributesObject[diffKey] = source[diffKey];
          return previousAttributesObject;
        },
        {}
      );
    };
    const versionSchemaKeys = Object.keys(versionSchemaAttributes);
    const contentTypeSchemaAttributesKeys = Object.keys(sanitizedContentTypeSchemaAttributes);
    const uniqueToContentType = fp.difference(contentTypeSchemaAttributesKeys, versionSchemaKeys);
    const added = reduceDifferenceToAttributesObject(
      uniqueToContentType,
      sanitizedContentTypeSchemaAttributes
    );
    const uniqueToVersion = fp.difference(versionSchemaKeys, contentTypeSchemaAttributesKeys);
    const removed = reduceDifferenceToAttributesObject(uniqueToVersion, versionSchemaAttributes);
    return { added, removed };
  };
  const getRelationRestoreValue = async (versionRelationData, attribute) => {
    if (Array.isArray(versionRelationData)) {
      if (versionRelationData.length === 0)
        return versionRelationData;
      const existingAndMissingRelations = await Promise.all(
        versionRelationData.map((relation) => {
          return strapi2.documents(attribute.target).findOne({
            documentId: relation.documentId,
            locale: relation.locale || void 0
          });
        })
      );
      return existingAndMissingRelations.filter(
        (relation) => relation !== null
      );
    }
    return strapi2.documents(attribute.target).findOne({
      documentId: versionRelationData.documentId,
      locale: versionRelationData.locale || void 0
    });
  };
  const getMediaRestoreValue = async (versionRelationData, attribute) => {
    if (attribute.multiple) {
      const existingAndMissingMedias = await Promise.all(
        // @ts-expect-error Fix the type definitions so this isn't any
        versionRelationData.map((media) => {
          return strapi2.db.query("plugin::upload.file").findOne({ where: { id: media.id } });
        })
      );
      return existingAndMissingMedias.filter((media) => media != null);
    }
    return strapi2.db.query("plugin::upload.file").findOne({ where: { id: versionRelationData.id } });
  };
  const localesService = strapi2.plugin("i18n")?.service("locales");
  const i18nContentTypeService = strapi2.plugin("i18n")?.service("content-types");
  const getDefaultLocale = async () => localesService ? localesService.getDefaultLocale() : null;
  const isLocalizedContentType = (model) => i18nContentTypeService ? i18nContentTypeService.isLocalizedContentType(model) : false;
  const getLocaleDictionary = async () => {
    if (!localesService)
      return {};
    const locales = await localesService.find() || [];
    return locales.reduce(
      (acc, locale) => {
        acc[locale.code] = { name: locale.name, code: locale.code };
        return acc;
      },
      {}
    );
  };
  const getRetentionDays = () => {
    const featureConfig = strapi2.ee.features.get("cms-content-history");
    const licenseRetentionDays = typeof featureConfig === "object" && featureConfig?.options.retentionDays;
    const userRetentionDays = strapi2.config.get("admin.history.retentionDays");
    if (userRetentionDays && userRetentionDays < licenseRetentionDays) {
      return userRetentionDays;
    }
    return Math.min(licenseRetentionDays, DEFAULT_RETENTION_DAYS);
  };
  const getVersionStatus = async (contentTypeUid, document) => {
    const documentMetadataService = strapi2.plugin("content-manager").service("document-metadata");
    const meta = await documentMetadataService.getMetadata(contentTypeUid, document);
    return documentMetadataService.getStatus(document, meta.availableStatus);
  };
  const getDeepPopulate2 = (uid2, useDatabaseSyntax = false) => {
    const model = strapi2.getModel(uid2);
    const attributes = Object.entries(model.attributes);
    const fieldSelector = useDatabaseSyntax ? "select" : "fields";
    return attributes.reduce((acc, [attributeName, attribute]) => {
      switch (attribute.type) {
        case "relation": {
          const isMorphRelation = attribute.relation.toLowerCase().startsWith("morph");
          if (isMorphRelation) {
            break;
          }
          const isVisible2 = strapiUtils.contentTypes.isVisibleAttribute(model, attributeName);
          if (isVisible2) {
            acc[attributeName] = { [fieldSelector]: ["documentId", "locale", "publishedAt"] };
          }
          break;
        }
        case "media": {
          acc[attributeName] = { [fieldSelector]: ["id"] };
          break;
        }
        case "component": {
          const populate = getDeepPopulate2(attribute.component);
          acc[attributeName] = { populate };
          break;
        }
        case "dynamiczone": {
          const populatedComponents = (attribute.components || []).reduce(
            (acc2, componentUID) => {
              acc2[componentUID] = { populate: getDeepPopulate2(componentUID) };
              return acc2;
            },
            {}
          );
          acc[attributeName] = { on: populatedComponents };
          break;
        }
      }
      return acc;
    }, {});
  };
  const buildMediaResponse = async (values) => {
    return values.slice(0, 25).reduce(
      async (currentRelationDataPromise, entry) => {
        const currentRelationData = await currentRelationDataPromise;
        if (!entry) {
          return currentRelationData;
        }
        const relatedEntry = await strapi2.db.query("plugin::upload.file").findOne({ where: { id: entry.id } });
        if (relatedEntry) {
          currentRelationData.results.push(relatedEntry);
        } else {
          currentRelationData.meta.missingCount += 1;
        }
        return currentRelationData;
      },
      Promise.resolve({
        results: [],
        meta: { missingCount: 0 }
      })
    );
  };
  const buildRelationReponse = async (values, attributeSchema) => {
    return values.slice(0, 25).reduce(
      async (currentRelationDataPromise, entry) => {
        const currentRelationData = await currentRelationDataPromise;
        if (!entry) {
          return currentRelationData;
        }
        const relatedEntry = await strapi2.documents(attributeSchema.target).findOne({ documentId: entry.documentId, locale: entry.locale || void 0 });
        if (relatedEntry) {
          currentRelationData.results.push({
            ...relatedEntry,
            status: await getVersionStatus(attributeSchema.target, relatedEntry)
          });
        } else {
          currentRelationData.meta.missingCount += 1;
        }
        return currentRelationData;
      },
      Promise.resolve({
        results: [],
        meta: { missingCount: 0 }
      })
    );
  };
  return {
    getSchemaAttributesDiff,
    getRelationRestoreValue,
    getMediaRestoreValue,
    getDefaultLocale,
    isLocalizedContentType,
    getLocaleDictionary,
    getRetentionDays,
    getVersionStatus,
    getDeepPopulate: getDeepPopulate2,
    buildMediaResponse,
    buildRelationReponse
  };
};
const createHistoryService = ({ strapi: strapi2 }) => {
  const query = strapi2.db.query(HISTORY_VERSION_UID);
  const serviceUtils = createServiceUtils({ strapi: strapi2 });
  return {
    async createVersion(historyVersionData) {
      await query.create({
        data: {
          ...historyVersionData,
          createdAt: /* @__PURE__ */ new Date(),
          createdBy: strapi2.requestContext.get()?.state?.user.id
        }
      });
    },
    async findVersionsPage(params) {
      const model = strapi2.getModel(params.query.contentType);
      const isLocalizedContentType = serviceUtils.isLocalizedContentType(model);
      const defaultLocale = await serviceUtils.getDefaultLocale();
      let locale = null;
      if (isLocalizedContentType) {
        locale = params.query.locale || defaultLocale;
      }
      const [{ results, pagination }, localeDictionary] = await Promise.all([
        query.findPage({
          ...params.query,
          where: {
            $and: [
              { contentType: params.query.contentType },
              ...params.query.documentId ? [{ relatedDocumentId: params.query.documentId }] : [],
              ...locale ? [{ locale }] : []
            ]
          },
          populate: ["createdBy"],
          orderBy: [{ createdAt: "desc" }]
        }),
        serviceUtils.getLocaleDictionary()
      ]);
      const populateEntryRelations = async (entry) => {
        const entryWithRelations = await Object.entries(entry.schema).reduce(
          async (currentDataWithRelations, [attributeKey, attributeSchema]) => {
            const attributeValue = entry.data[attributeKey];
            const attributeValues = Array.isArray(attributeValue) ? attributeValue : [attributeValue];
            if (attributeSchema.type === "media") {
              const permissionChecker2 = getService$1("permission-checker").create({
                userAbility: params.state.userAbility,
                model: "plugin::upload.file"
              });
              const response = await serviceUtils.buildMediaResponse(attributeValues);
              const sanitizedResults = await Promise.all(
                response.results.map((media) => permissionChecker2.sanitizeOutput(media))
              );
              return {
                ...await currentDataWithRelations,
                [attributeKey]: {
                  results: sanitizedResults,
                  meta: response.meta
                }
              };
            }
            if (attributeSchema.type === "relation" && attributeSchema.relation !== "morphToOne" && attributeSchema.relation !== "morphToMany") {
              if (attributeSchema.target === "admin::user") {
                const adminUsers = await Promise.all(
                  attributeValues.map((userToPopulate) => {
                    if (userToPopulate == null) {
                      return null;
                    }
                    return strapi2.query("admin::user").findOne({ where: { id: userToPopulate.id } });
                  })
                );
                return {
                  ...await currentDataWithRelations,
                  /**
                   * Ideally we would return the same "{results: [], meta: {}}" shape, however,
                   * when sanitizing the data as a whole in the controller before sending to the client,
                   * the data for admin relation user is completely sanitized if we return an object here as opposed to an array.
                   */
                  [attributeKey]: adminUsers
                };
              }
              const permissionChecker2 = getService$1("permission-checker").create({
                userAbility: params.state.userAbility,
                model: attributeSchema.target
              });
              const response = await serviceUtils.buildRelationReponse(
                attributeValues,
                attributeSchema
              );
              const sanitizedResults = await Promise.all(
                response.results.map((media) => permissionChecker2.sanitizeOutput(media))
              );
              return {
                ...await currentDataWithRelations,
                [attributeKey]: {
                  results: sanitizedResults,
                  meta: response.meta
                }
              };
            }
            return currentDataWithRelations;
          },
          Promise.resolve(entry.data)
        );
        return entryWithRelations;
      };
      const formattedResults = await Promise.all(
        results.map(async (result) => {
          return {
            ...result,
            data: await populateEntryRelations(result),
            meta: {
              unknownAttributes: serviceUtils.getSchemaAttributesDiff(
                result.schema,
                strapi2.getModel(params.query.contentType).attributes
              )
            },
            locale: result.locale ? localeDictionary[result.locale] : null
          };
        })
      );
      return {
        results: formattedResults,
        pagination
      };
    },
    async restoreVersion(versionId) {
      const version = await query.findOne({ where: { id: versionId } });
      const contentTypeSchemaAttributes = strapi2.getModel(version.contentType).attributes;
      const schemaDiff = serviceUtils.getSchemaAttributesDiff(
        version.schema,
        contentTypeSchemaAttributes
      );
      const dataWithoutAddedAttributes = Object.keys(schemaDiff.added).reduce(
        (currentData, addedKey) => {
          currentData[addedKey] = null;
          return currentData;
        },
        // Clone to avoid mutating the original version data
        structuredClone(version.data)
      );
      const sanitizedSchemaAttributes = fp.omit(
        FIELDS_TO_IGNORE,
        contentTypeSchemaAttributes
      );
      const reducer = strapiUtils.async.reduce(Object.entries(sanitizedSchemaAttributes));
      const dataWithoutMissingRelations = await reducer(
        async (previousRelationAttributes, [name, attribute]) => {
          const versionRelationData = version.data[name];
          if (!versionRelationData) {
            return previousRelationAttributes;
          }
          if (attribute.type === "relation" && // TODO: handle polymorphic relations
          attribute.relation !== "morphToOne" && attribute.relation !== "morphToMany") {
            const data2 = await serviceUtils.getRelationRestoreValue(versionRelationData, attribute);
            previousRelationAttributes[name] = data2;
          }
          if (attribute.type === "media") {
            const data2 = await serviceUtils.getMediaRestoreValue(versionRelationData, attribute);
            previousRelationAttributes[name] = data2;
          }
          return previousRelationAttributes;
        },
        // Clone to avoid mutating the original version data
        structuredClone(dataWithoutAddedAttributes)
      );
      const data = fp.omit(["id", ...Object.keys(schemaDiff.removed)], dataWithoutMissingRelations);
      const restoredDocument = await strapi2.documents(version.contentType).update({
        documentId: version.relatedDocumentId,
        locale: version.locale,
        data
      });
      if (!restoredDocument) {
        throw new strapiUtils.errors.ApplicationError("Failed to restore version");
      }
      return restoredDocument;
    }
  };
};
const shouldCreateHistoryVersion = (context) => {
  if (!strapi.requestContext.get()?.request.url.startsWith("/content-manager")) {
    return false;
  }
  if (context.action !== "create" && context.action !== "update" && context.action !== "clone" && context.action !== "publish" && context.action !== "unpublish" && context.action !== "discardDraft") {
    return false;
  }
  if (context.action === "update" && strapi.requestContext.get()?.request.url.endsWith("/actions/publish")) {
    return false;
  }
  if (!context.contentType.uid.startsWith("api::")) {
    return false;
  }
  return true;
};
const getSchemas = (uid2) => {
  const attributesSchema = strapi.getModel(uid2).attributes;
  const componentsSchemas = Object.keys(attributesSchema).reduce(
    (currentComponentSchemas, key) => {
      const fieldSchema = attributesSchema[key];
      if (fieldSchema.type === "component") {
        const componentSchema = strapi.getModel(fieldSchema.component).attributes;
        return {
          ...currentComponentSchemas,
          [fieldSchema.component]: componentSchema
        };
      }
      return currentComponentSchemas;
    },
    {}
  );
  return {
    schema: fp.omit(FIELDS_TO_IGNORE, attributesSchema),
    componentsSchemas
  };
};
const createLifecyclesService = ({ strapi: strapi2 }) => {
  const state = {
    deleteExpiredJob: null,
    isInitialized: false
  };
  const serviceUtils = createServiceUtils({ strapi: strapi2 });
  return {
    async bootstrap() {
      if (state.isInitialized) {
        return;
      }
      strapi2.documents.use(async (context, next) => {
        const result = await next();
        if (!shouldCreateHistoryVersion(context)) {
          return result;
        }
        const documentId = context.action === "create" || context.action === "clone" ? result.documentId : context.params.documentId;
        const defaultLocale = await serviceUtils.getDefaultLocale();
        const locales = fp.castArray(context.params?.locale || defaultLocale);
        if (!locales.length) {
          return result;
        }
        const uid2 = context.contentType.uid;
        const schemas = getSchemas(uid2);
        const model = strapi2.getModel(uid2);
        const isLocalizedContentType = serviceUtils.isLocalizedContentType(model);
        const localeEntries = await strapi2.db.query(uid2).findMany({
          where: {
            documentId,
            ...isLocalizedContentType ? { locale: { $in: locales } } : {},
            ...strapiUtils.contentTypes.hasDraftAndPublish(strapi2.contentTypes[uid2]) ? { publishedAt: null } : {}
          },
          populate: serviceUtils.getDeepPopulate(
            uid2,
            true
            /* use database syntax */
          )
        });
        await strapi2.db.transaction(async ({ onCommit }) => {
          onCommit(async () => {
            for (const entry of localeEntries) {
              const status = await serviceUtils.getVersionStatus(uid2, entry);
              await getService(strapi2, "history").createVersion({
                contentType: uid2,
                data: fp.omit(FIELDS_TO_IGNORE, entry),
                relatedDocumentId: documentId,
                locale: entry.locale,
                status,
                ...schemas
              });
            }
          });
        });
        return result;
      });
      state.deleteExpiredJob = nodeSchedule.scheduleJob("0 0 * * *", () => {
        const retentionDaysInMilliseconds = serviceUtils.getRetentionDays() * 24 * 60 * 60 * 1e3;
        const expirationDate = new Date(Date.now() - retentionDaysInMilliseconds);
        strapi2.db.query(HISTORY_VERSION_UID).deleteMany({
          where: {
            created_at: {
              $lt: expirationDate.toISOString()
            }
          }
        });
      });
      state.isInitialized = true;
    },
    async destroy() {
      if (state.deleteExpiredJob) {
        state.deleteExpiredJob.cancel();
      }
    }
  };
};
const services$1 = {
  history: createHistoryService,
  lifecycles: createLifecyclesService
};
const info = { pluginName: "content-manager", type: "admin" };
const historyVersionRouter = {
  type: "admin",
  routes: [
    {
      method: "GET",
      info,
      path: "/history-versions",
      handler: "history-version.findMany",
      config: {
        policies: ["admin::isAuthenticatedAdmin"]
      }
    },
    {
      method: "PUT",
      info,
      path: "/history-versions/:versionId/restore",
      handler: "history-version.restoreVersion",
      config: {
        policies: ["admin::isAuthenticatedAdmin"]
      }
    }
  ]
};
const routes$1 = {
  "history-version": historyVersionRouter
};
const historyVersion = {
  uid: HISTORY_VERSION_UID,
  tableName: "strapi_history_versions",
  singularName: "history-version",
  attributes: {
    id: {
      type: "increments"
    },
    contentType: {
      type: "string",
      column: { notNullable: true }
    },
    relatedDocumentId: {
      type: "string",
      // TODO: notNullable should be true once history can record publish actions
      column: { notNullable: false }
    },
    locale: {
      type: "string"
    },
    status: {
      type: "enumeration",
      enum: ["draft", "published", "modified"]
    },
    data: {
      type: "json"
    },
    schema: {
      type: "json"
    },
    createdAt: {
      type: "datetime",
      default: () => /* @__PURE__ */ new Date()
    },
    // FIXME: joinTable should be optional
    // @ts-expect-error database model is not yet updated to support useJoinTable
    createdBy: {
      type: "relation",
      relation: "oneToOne",
      target: "admin::user",
      useJoinTable: false
    }
  }
};
const getFeature = () => {
  if (strapi.ee.features.isEnabled("cms-content-history")) {
    return {
      register({ strapi: strapi2 }) {
        strapi2.get("models").add(historyVersion);
      },
      bootstrap({ strapi: strapi2 }) {
        getService(strapi2, "lifecycles").bootstrap();
      },
      destroy({ strapi: strapi2 }) {
        getService(strapi2, "lifecycles").destroy();
      },
      controllers: controllers$1,
      services: services$1,
      routes: routes$1
    };
  }
  return {
    register({ strapi: strapi2 }) {
      strapi2.get("models").add(historyVersion);
    }
  };
};
const history = getFeature();
const register = async ({ strapi: strapi2 }) => {
  await history.register?.({ strapi: strapi2 });
};
const ALLOWED_WEBHOOK_EVENTS = {
  ENTRY_PUBLISH: "entry.publish",
  ENTRY_UNPUBLISH: "entry.unpublish"
};
const bootstrap = async () => {
  Object.entries(ALLOWED_WEBHOOK_EVENTS).forEach(([key, value]) => {
    strapi.get("webhookStore").addAllowedEvent(key, value);
  });
  getService$1("field-sizes").setCustomFieldInputSizes();
  await getService$1("components").syncConfigurations();
  await getService$1("content-types").syncConfigurations();
  await getService$1("permission").registerPermissions();
  await history.bootstrap?.({ strapi });
};
const destroy = async ({ strapi: strapi2 }) => {
  await history.destroy?.({ strapi: strapi2 });
};
const routing = async (ctx, next) => {
  const { model } = ctx.params;
  const ct = strapi.contentTypes[model];
  if (!ct) {
    return ctx.send({ error: "contentType.notFound" }, 404);
  }
  let controllers2;
  if (!ct.plugin || ct.plugin === "admin") {
    controllers2 = strapi.admin.controllers;
  } else {
    controllers2 = strapi.plugin(ct.plugin).controllers;
  }
  const { route } = ctx.state;
  if (typeof route.handler !== "string") {
    return next();
  }
  const [, action] = route.handler.split(".");
  let actionConfig;
  if (!ct.plugin || ct.plugin === "admin") {
    actionConfig = strapi.config.get(`admin.layout.${ct.modelName}.actions.${action}`);
  } else {
    actionConfig = strapi.plugin(ct.plugin).config(`layout.${ct.modelName}.actions.${action}`);
  }
  if (!isNil__default.default(actionConfig)) {
    const [controller, action2] = actionConfig.split(".");
    if (controller && action2) {
      return controllers2[controller.toLowerCase()][action2](ctx, next);
    }
  }
  await next();
};
const admin = {
  type: "admin",
  routes: [
    {
      method: "GET",
      path: "/init",
      handler: "init.getInitData",
      config: {
        policies: []
      }
    },
    {
      method: "GET",
      path: "/content-types",
      handler: "content-types.findContentTypes",
      config: {
        policies: []
      }
    },
    {
      method: "GET",
      path: "/content-types-settings",
      handler: "content-types.findContentTypesSettings",
      config: {
        policies: []
      }
    },
    {
      method: "GET",
      path: "/content-types/:uid/configuration",
      handler: "content-types.findContentTypeConfiguration",
      config: {
        policies: []
      }
    },
    {
      method: "PUT",
      path: "/content-types/:uid/configuration",
      handler: "content-types.updateContentTypeConfiguration",
      config: {
        policies: ["admin::isAuthenticatedAdmin"]
      }
    },
    {
      method: "GET",
      path: "/components",
      handler: "components.findComponents",
      config: {
        policies: []
      }
    },
    {
      method: "GET",
      path: "/components/:uid/configuration",
      handler: "components.findComponentConfiguration",
      config: {
        policies: []
      }
    },
    {
      method: "PUT",
      path: "/components/:uid/configuration",
      handler: "components.updateComponentConfiguration",
      config: {
        policies: []
      }
    },
    {
      method: "POST",
      path: "/uid/generate",
      handler: "uid.generateUID",
      config: {
        policies: []
      }
    },
    {
      method: "POST",
      path: "/uid/check-availability",
      handler: "uid.checkUIDAvailability",
      config: {
        policies: []
      }
    },
    {
      method: "GET",
      path: "/relations/:model/:targetField",
      handler: "relations.findAvailable",
      config: {
        policies: ["admin::isAuthenticatedAdmin"]
      }
    },
    {
      method: "GET",
      path: "/relations/:model/:id/:targetField",
      handler: "relations.findExisting",
      config: {
        policies: ["admin::isAuthenticatedAdmin"]
      }
    },
    {
      method: "GET",
      path: "/single-types/:model",
      handler: "single-types.find",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.read"] }
          }
        ]
      }
    },
    {
      method: "PUT",
      path: "/single-types/:model",
      handler: "single-types.createOrUpdate",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: {
              actions: [
                "plugin::content-manager.explorer.create",
                "plugin::content-manager.explorer.update"
              ],
              hasAtLeastOne: true
            }
          }
        ]
      }
    },
    {
      method: "DELETE",
      path: "/single-types/:model",
      handler: "single-types.delete",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.delete"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/single-types/:model/actions/publish",
      handler: "single-types.publish",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.publish"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/single-types/:model/actions/unpublish",
      handler: "single-types.unpublish",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.publish"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/single-types/:model/actions/discard",
      handler: "single-types.discard",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.update"] }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/single-types/:model/actions/countDraftRelations",
      handler: "single-types.countDraftRelations",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.read"] }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/collection-types/:model",
      handler: "collection-types.find",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.read"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model",
      handler: "collection-types.create",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.create"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/clone/:sourceId",
      handler: "collection-types.clone",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.create"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/auto-clone/:sourceId",
      handler: "collection-types.autoClone",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.create"] }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/collection-types/:model/:id",
      handler: "collection-types.findOne",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.read"] }
          }
        ]
      }
    },
    {
      method: "PUT",
      path: "/collection-types/:model/:id",
      handler: "collection-types.update",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.update"] }
          }
        ]
      }
    },
    {
      method: "DELETE",
      path: "/collection-types/:model/:id",
      handler: "collection-types.delete",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.delete"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/actions/publish",
      handler: "collection-types.publish",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.publish"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/:id/actions/publish",
      handler: "collection-types.publish",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.publish"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/:id/actions/unpublish",
      handler: "collection-types.unpublish",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.publish"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/:id/actions/discard",
      handler: "collection-types.discard",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.update"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/actions/bulkDelete",
      handler: "collection-types.bulkDelete",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.delete"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/actions/bulkPublish",
      handler: "collection-types.bulkPublish",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.publish"] }
          }
        ]
      }
    },
    {
      method: "POST",
      path: "/collection-types/:model/actions/bulkUnpublish",
      handler: "collection-types.bulkUnpublish",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.publish"] }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/collection-types/:model/:id/actions/countDraftRelations",
      handler: "collection-types.countDraftRelations",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.read"] }
          }
        ]
      }
    },
    {
      method: "GET",
      path: "/collection-types/:model/actions/countManyEntriesDraftRelations",
      handler: "collection-types.countManyEntriesDraftRelations",
      config: {
        middlewares: [routing],
        policies: [
          "admin::isAuthenticatedAdmin",
          {
            name: "plugin::content-manager.hasPermissions",
            config: { actions: ["plugin::content-manager.explorer.read"] }
          }
        ]
      }
    }
  ]
};
const routes = {
  admin,
  ...history.routes ? history.routes : {}
};
const hasPermissionsSchema = strapiUtils.yup.object({
  actions: strapiUtils.yup.array().of(strapiUtils.yup.string()),
  hasAtLeastOne: strapiUtils.yup.boolean()
});
const validateHasPermissionsInput = strapiUtils.validateYupSchemaSync(hasPermissionsSchema);
const { createPolicy } = strapiUtils.policy;
const hasPermissions = createPolicy({
  name: "plugin::content-manager.hasPermissions",
  validator: validateHasPermissionsInput,
  /**
   * NOTE: Action aliases are currently not checked at this level (policy).
   *       This is currently the intended behavior to avoid changing the behavior of API related permissions.
   *       If you want to add support for it, please create a dedicated RFC with a list of potential side effect this could have.
   */
  handler(ctx, config = {}) {
    const { actions = [], hasAtLeastOne = false } = config;
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const isAuthorized = hasAtLeastOne ? actions.some((action) => userAbility.can(action, model)) : actions.every((action) => userAbility.can(action, model));
    return isAuthorized;
  }
});
const policies = {
  hasPermissions
};
const { getNonVisibleAttributes, getWritableAttributes } = strapiUtils.contentTypes;
const { PUBLISHED_AT_ATTRIBUTE: PUBLISHED_AT_ATTRIBUTE$3, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = strapiUtils.contentTypes.constants;
const NON_SORTABLES = ["component", "json", "media", "richtext", "dynamiczone", "blocks"];
const SORTABLE_RELATIONS = ["oneToOne", "manyToOne"];
const NON_LISTABLES = ["json", "password", "richtext", "dynamiczone", "blocks"];
const LISTABLE_RELATIONS = ["oneToOne", "oneToMany", "manyToOne", "manyToMany"];
const isHidden = (schema, name) => {
  if (!___default.default.has(schema.attributes, name)) {
    return false;
  }
  const isHidden2 = ___default.default.get(schema, ["config", "attributes", name, "hidden"], false);
  if (isHidden2 === true) {
    return true;
  }
  return false;
};
const isListable = (schema, name) => {
  if (!___default.default.has(schema.attributes, name)) {
    return false;
  }
  if (isHidden(schema, name)) {
    return false;
  }
  const attribute = schema.attributes[name];
  if (NON_LISTABLES.includes(attribute.type)) {
    return false;
  }
  if (isRelation$1(attribute) && !LISTABLE_RELATIONS.includes(attribute.relationType)) {
    return false;
  }
  return true;
};
const isSortable = (schema, name) => {
  if (!___default.default.has(schema.attributes, name)) {
    return false;
  }
  if (schema.modelType === "component" && name === "id")
    return false;
  const attribute = schema.attributes[name];
  if (NON_SORTABLES.includes(attribute.type)) {
    return false;
  }
  if (isRelation$1(attribute) && !SORTABLE_RELATIONS.includes(attribute.relationType)) {
    return false;
  }
  return true;
};
const isSearchable = (schema, name) => {
  return isSortable(schema, name);
};
const isVisible$1 = (schema, name) => {
  if (!___default.default.has(schema.attributes, name)) {
    return false;
  }
  if (isHidden(schema, name)) {
    return false;
  }
  if (isTimestamp(schema, name) || name === "id") {
    return false;
  }
  if (isPublicationField(name)) {
    return false;
  }
  if (isCreatorField(schema, name)) {
    return false;
  }
  return true;
};
const isPublicationField = (name) => PUBLISHED_AT_ATTRIBUTE$3 === name;
const isTimestamp = (schema, name) => {
  if (!___default.default.has(schema.attributes, name)) {
    return false;
  }
  const timestamps = strapiUtils.contentTypes.getTimestamps(schema);
  if (!timestamps || !Array.isArray(timestamps)) {
    return false;
  }
  if (timestamps.includes(name)) {
    return true;
  }
};
const isCreatorField = (schema, name) => {
  if (!___default.default.has(schema.attributes, name)) {
    return false;
  }
  const creatorFields = strapiUtils.contentTypes.getCreatorFields(schema);
  if (!creatorFields || !Array.isArray(creatorFields)) {
    return false;
  }
  if (creatorFields.includes(name)) {
    return true;
  }
};
const isRelation$1 = (attribute) => attribute.type === "relation";
const hasRelationAttribute = (schema, name) => {
  if (!___default.default.has(schema.attributes, name)) {
    return false;
  }
  if (isHidden(schema, name)) {
    return false;
  }
  if (!isVisible$1(schema, name)) {
    return false;
  }
  return isRelation$1(schema.attributes[name]);
};
const hasEditableAttribute = (schema, name) => {
  if (!___default.default.has(schema.attributes, name)) {
    return false;
  }
  if (isHidden(schema, name)) {
    return false;
  }
  if (!isVisible$1(schema, name)) {
    return false;
  }
  return true;
};
const findFirstStringAttribute = (schema) => {
  return Object.keys(schema.attributes || {}).find((key) => {
    const { type } = schema.attributes[key];
    return type === "string" && key !== "id";
  });
};
const getDefaultMainField = (schema) => findFirstStringAttribute(schema) || "id";
const getSortableAttributes = (schema) => {
  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));
  const model = strapi.getModel(schema.uid);
  const nonVisibleWritableAttributes = fp.intersection(
    getNonVisibleAttributes(model),
    getWritableAttributes(model)
  );
  return [
    "id",
    ...validAttributes,
    ...nonVisibleWritableAttributes,
    CREATED_BY_ATTRIBUTE,
    UPDATED_BY_ATTRIBUTE
  ];
};
const DEFAULT_SETTINGS = {
  bulkable: true,
  filterable: true,
  searchable: true,
  pageSize: 10
};
const settingsFields = [
  "searchable",
  "filterable",
  "bulkable",
  "pageSize",
  "mainField",
  "defaultSortBy",
  "defaultSortOrder"
];
const getModelSettings = fp.pipe([fp.propOr({}, "config.settings"), fp.pick(settingsFields)]);
async function isValidDefaultSort(schema, value) {
  const parsedValue = qs__default.default.parse(value);
  const omitNonSortableAttributes = ({ schema: schema2, key }, { remove }) => {
    const sortableAttributes = getSortableAttributes(schema2);
    if (!sortableAttributes.includes(key)) {
      remove(key);
    }
  };
  const sanitizedValue = await strapiUtils.traverse.traverseQuerySort(
    omitNonSortableAttributes,
    { schema, getModel: strapi.getModel.bind(strapi) },
    parsedValue
  );
  return fp.isEqual(parsedValue, sanitizedValue);
}
const createDefaultSettings = async (schema) => {
  const defaultField = getDefaultMainField(schema);
  return {
    ...DEFAULT_SETTINGS,
    mainField: defaultField,
    defaultSortBy: defaultField,
    defaultSortOrder: "ASC",
    ...getModelSettings(schema)
  };
};
const syncSettings = async (configuration, schema) => {
  if (fp.isEmpty(configuration.settings))
    return createDefaultSettings(schema);
  const defaultField = getDefaultMainField(schema);
  const { mainField = defaultField, defaultSortBy = defaultField } = configuration.settings || {};
  return {
    ...configuration.settings,
    mainField: isSortable(schema, mainField) ? mainField : defaultField,
    defaultSortBy: await isValidDefaultSort(schema, defaultSortBy) ? defaultSortBy : defaultField
  };
};
const createModelConfigurationSchema = (schema, opts = {}) => strapiUtils.yup.object().shape({
  settings: createSettingsSchema(schema).default(null).nullable(),
  metadatas: createMetadasSchema(schema).default(null).nullable(),
  layouts: createLayoutsSchema(schema, opts).default(null).nullable(),
  options: strapiUtils.yup.object().optional()
}).noUnknown();
const createSettingsSchema = (schema) => {
  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));
  return strapiUtils.yup.object().shape({
    bulkable: strapiUtils.yup.boolean().required(),
    filterable: strapiUtils.yup.boolean().required(),
    pageSize: strapiUtils.yup.number().integer().min(10).max(100).required(),
    searchable: strapiUtils.yup.boolean().required(),
    // should be reset when the type changes
    mainField: strapiUtils.yup.string().oneOf(validAttributes.concat("id")).default("id"),
    // should be reset when the type changes
    defaultSortBy: strapiUtils.yup.string().test(
      "is-valid-sort-attribute",
      "${path} is not a valid sort attribute",
      async (value) => isValidDefaultSort(schema, value)
    ).default("id"),
    defaultSortOrder: strapiUtils.yup.string().oneOf(["ASC", "DESC"]).default("ASC")
  }).noUnknown();
};
const createMetadasSchema = (schema) => {
  return strapiUtils.yup.object().shape(
    Object.keys(schema.attributes).reduce((acc, key) => {
      acc[key] = strapiUtils.yup.object().shape({
        edit: strapiUtils.yup.object().shape({
          label: strapiUtils.yup.string(),
          description: strapiUtils.yup.string(),
          placeholder: strapiUtils.yup.string(),
          editable: strapiUtils.yup.boolean(),
          visible: strapiUtils.yup.boolean(),
          mainField: strapiUtils.yup.lazy((value) => {
            if (!value) {
              return strapiUtils.yup.string();
            }
            const targetSchema = getService$1("content-types").findContentType(
              schema.attributes[key].targetModel
            );
            if (!targetSchema) {
              return strapiUtils.yup.string();
            }
            const validAttributes = Object.keys(targetSchema.attributes).filter(
              (key2) => isListable(targetSchema, key2)
            );
            return strapiUtils.yup.string().oneOf(validAttributes.concat("id")).default("id");
          })
        }).noUnknown().required(),
        list: strapiUtils.yup.object().shape({
          label: strapiUtils.yup.string(),
          searchable: strapiUtils.yup.boolean(),
          sortable: strapiUtils.yup.boolean()
        }).noUnknown().required()
      }).noUnknown();
      return acc;
    }, {})
  );
};
const createArrayTest = ({ allowUndefined = false } = {}) => ({
  name: "isArray",
  message: "${path} is required and must be an array",
  test: (val) => allowUndefined === true && val === void 0 ? true : Array.isArray(val)
});
const createLayoutsSchema = (schema, opts = {}) => {
  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));
  const editAttributes = Object.keys(schema.attributes).filter(
    (key) => hasEditableAttribute(schema, key)
  );
  return strapiUtils.yup.object().shape({
    edit: strapiUtils.yup.array().of(
      strapiUtils.yup.array().of(
        strapiUtils.yup.object().shape({
          name: strapiUtils.yup.string().oneOf(editAttributes).required(),
          size: strapiUtils.yup.number().integer().positive().required()
        }).noUnknown()
      )
    ).test(createArrayTest(opts)),
    list: strapiUtils.yup.array().of(strapiUtils.yup.string().oneOf(validAttributes)).test(createArrayTest(opts))
  });
};
const { PaginationError, ValidationError } = strapiUtils.errors;
const TYPES = ["singleType", "collectionType"];
const kindSchema = strapiUtils.yup.string().oneOf(TYPES).nullable();
const bulkActionInputSchema = strapiUtils.yup.object({
  documentIds: strapiUtils.yup.array().of(strapiUtils.yup.strapiID()).min(1).required()
}).required();
const generateUIDInputSchema = strapiUtils.yup.object({
  contentTypeUID: strapiUtils.yup.string().required(),
  field: strapiUtils.yup.string().required(),
  data: strapiUtils.yup.object().required()
});
const checkUIDAvailabilityInputSchema = strapiUtils.yup.object({
  contentTypeUID: strapiUtils.yup.string().required(),
  field: strapiUtils.yup.string().required(),
  value: strapiUtils.yup.string().matches(/^[A-Za-z0-9-_.~]*$/).required()
});
const validateUIDField = (contentTypeUID, field) => {
  const model = strapi.contentTypes[contentTypeUID];
  if (!model) {
    throw new ValidationError("ContentType not found");
  }
  if (!___default.default.has(model, ["attributes", field]) || ___default.default.get(model, ["attributes", field, "type"]) !== "uid") {
    throw new ValidationError(`${field} must be a valid \`uid\` attribute`);
  }
};
const validateKind = strapiUtils.validateYupSchema(kindSchema);
const validateBulkActionInput = strapiUtils.validateYupSchema(bulkActionInputSchema);
const validateGenerateUIDInput = strapiUtils.validateYupSchema(generateUIDInputSchema);
const validateCheckUIDAvailabilityInput = strapiUtils.validateYupSchema(checkUIDAvailabilityInputSchema);
const { isVisibleAttribute: isVisibleAttribute$2 } = strapiUtils__default.default.contentTypes;
function checkRelation(model, attributeName, path) {
  if (!isVisibleAttribute$2(model, attributeName)) {
    return [];
  }
  const { relation, inversedBy, mappedBy } = model.attributes[attributeName];
  if (["oneToOne", "oneToMany"].includes(relation) && [mappedBy, inversedBy].some((key) => key != null)) {
    return [[[...path, attributeName], "relation"]];
  }
  return [];
}
const getProhibitedCloningFields = (uid2, pathPrefix = []) => {
  const model = strapi.getModel(uid2);
  const prohibitedFields = Object.keys(model.attributes).reduce(
    (acc, attributeName) => {
      const attribute = model.attributes[attributeName];
      const attributePath = [...pathPrefix, attributeName];
      switch (attribute.type) {
        case "relation":
          return [...acc, ...checkRelation(model, attributeName, pathPrefix)];
        case "component":
          return [...acc, ...getProhibitedCloningFields(attribute.component, attributePath)];
        case "dynamiczone":
          return [
            ...acc,
            ...(attribute.components || []).flatMap(
              (componentUID) => getProhibitedCloningFields(componentUID, [
                ...attributePath,
                strapi.getModel(componentUID).info.displayName
              ])
            )
          ];
        case "uid":
          return [...acc, [attributePath, "unique"]];
        default:
          if (attribute?.unique) {
            return [...acc, [attributePath, "unique"]];
          }
          return acc;
      }
    },
    []
  );
  return prohibitedFields;
};
const excludeNotCreatableFields = (uid2, permissionChecker2) => (body, path = []) => {
  const model = strapi.getModel(uid2);
  const canCreate = (path2) => permissionChecker2.can.create(null, path2);
  return Object.keys(model.attributes).reduce((body2, attributeName) => {
    const attribute = model.attributes[attributeName];
    const attributePath = [...path, attributeName].join(".");
    if (!isVisibleAttribute$2(model, attributeName)) {
      return body2;
    }
    switch (attribute.type) {
      case "relation": {
        if (canCreate(attributePath))
          return body2;
        return fp.set(attributePath, { set: [] }, body2);
      }
      case "component": {
        return excludeNotCreatableFields(attribute.component, permissionChecker2)(body2, [
          ...path,
          attributeName
        ]);
      }
      default: {
        if (canCreate(attributePath))
          return body2;
        return fp.set(attributePath, null, body2);
      }
    }
  }, body);
};
const singleLocaleSchema = strapiUtils.yup.string().nullable();
const multipleLocaleSchema = strapiUtils.yup.lazy(
  (value) => Array.isArray(value) ? strapiUtils.yup.array().of(singleLocaleSchema.required()) : singleLocaleSchema
);
const statusSchema = strapiUtils.yup.mixed().oneOf(["draft", "published"], "Invalid status");
const getDocumentLocaleAndStatus = async (request, model, opts = { allowMultipleLocales: false }) => {
  const { allowMultipleLocales } = opts;
  const { locale, status: providedStatus, ...rest } = request || {};
  const defaultStatus = strapiUtils.contentTypes.hasDraftAndPublish(strapi.getModel(model)) ? void 0 : "published";
  const status = providedStatus !== void 0 ? providedStatus : defaultStatus;
  const schema = strapiUtils.yup.object().shape({
    locale: allowMultipleLocales ? multipleLocaleSchema : singleLocaleSchema,
    status: statusSchema
  });
  try {
    await strapiUtils.validateYupSchema(schema, { strict: true, abortEarly: false })(request);
    return { locale, status, ...rest };
  } catch (error) {
    throw new strapiUtils.errors.ValidationError(`Validation error: ${error.message}`);
  }
};
const formatDocumentWithMetadata = async (permissionChecker2, uid2, document, opts = {}) => {
  const documentMetadata2 = getService$1("document-metadata");
  const serviceOutput = await documentMetadata2.formatDocumentWithMetadata(uid2, document, opts);
  let {
    meta: { availableLocales, availableStatus }
  } = serviceOutput;
  const metadataSanitizer = permissionChecker2.sanitizeOutput;
  availableLocales = await strapiUtils.async.map(
    availableLocales,
    async (localeDocument) => metadataSanitizer(localeDocument)
  );
  availableStatus = await strapiUtils.async.map(
    availableStatus,
    async (statusDocument) => metadataSanitizer(statusDocument)
  );
  return {
    ...serviceOutput,
    meta: {
      availableLocales,
      availableStatus
    }
  };
};
const createDocument = async (ctx, opts) => {
  const { userAbility, user } = ctx.state;
  const { model } = ctx.params;
  const { body } = ctx.request;
  const documentManager2 = getService$1("document-manager");
  const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
  if (permissionChecker2.cannot.create()) {
    throw new strapiUtils.errors.ForbiddenError();
  }
  const pickPermittedFields = permissionChecker2.sanitizeCreateInput;
  const setCreator = strapiUtils.setCreatorFields({ user });
  const sanitizeFn = strapiUtils.async.pipe(pickPermittedFields, setCreator);
  const sanitizedBody = await sanitizeFn(body);
  const { locale, status } = await getDocumentLocaleAndStatus(body, model);
  return documentManager2.create(model, {
    data: sanitizedBody,
    locale,
    status,
    populate: opts?.populate
  });
};
const updateDocument = async (ctx, opts) => {
  const { userAbility, user } = ctx.state;
  const { id, model } = ctx.params;
  const { body } = ctx.request;
  const documentManager2 = getService$1("document-manager");
  const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
  if (permissionChecker2.cannot.update()) {
    throw new strapiUtils.errors.ForbiddenError();
  }
  const permissionQuery = await permissionChecker2.sanitizedQuery.update(ctx.query);
  const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).build();
  const { locale } = await getDocumentLocaleAndStatus(body, model);
  const [documentVersion, documentExists] = await Promise.all([
    documentManager2.findOne(id, model, { populate, locale, status: "draft" }),
    documentManager2.exists(model, id)
  ]);
  if (!documentExists) {
    throw new strapiUtils.errors.NotFoundError();
  }
  if (documentVersion) {
    if (permissionChecker2.cannot.update(documentVersion)) {
      throw new strapiUtils.errors.ForbiddenError();
    }
  } else if (permissionChecker2.cannot.create()) {
    throw new strapiUtils.errors.ForbiddenError();
  }
  const pickPermittedFields = documentVersion ? permissionChecker2.sanitizeUpdateInput(documentVersion) : permissionChecker2.sanitizeCreateInput;
  const setCreator = strapiUtils.setCreatorFields({ user, isEdition: true });
  const sanitizeFn = strapiUtils.async.pipe(pickPermittedFields, setCreator);
  const sanitizedBody = await sanitizeFn(body);
  return documentManager2.update(documentVersion?.documentId || id, model, {
    data: sanitizedBody,
    populate: opts?.populate,
    locale
  });
};
const collectionTypes = {
  async find(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { query } = ctx.request;
    const documentMetadata2 = getService$1("document-metadata");
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.read()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.read(query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).populateDeep(1).countRelations({ toOne: false, toMany: true }).build();
    const { locale, status } = await getDocumentLocaleAndStatus(query, model);
    const { results: documents, pagination } = await documentManager2.findPage(
      { ...permissionQuery, populate, locale, status },
      model
    );
    const documentsAvailableStatus = await documentMetadata2.getManyAvailableStatus(
      model,
      documents
    );
    const setStatus = (document) => {
      const availableStatuses = documentsAvailableStatus.filter(
        (d) => d.documentId === document.documentId
      );
      document.status = documentMetadata2.getStatus(document, availableStatuses);
      return document;
    };
    const results = await strapiUtils.async.map(
      documents,
      strapiUtils.async.pipe(permissionChecker2.sanitizeOutput, setStatus)
    );
    ctx.body = {
      results,
      pagination
    };
  },
  async findOne(ctx) {
    const { userAbility } = ctx.state;
    const { model, id } = ctx.params;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.read()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.read(ctx.query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).populateDeep(Infinity).countRelations().build();
    const { locale, status } = await getDocumentLocaleAndStatus(ctx.query, model);
    const version = await documentManager2.findOne(id, model, {
      populate,
      locale,
      status
    });
    if (!version) {
      const exists = await documentManager2.exists(model, id);
      if (!exists) {
        return ctx.notFound();
      }
      const { meta } = await formatDocumentWithMetadata(
        permissionChecker2,
        model,
        // @ts-expect-error TODO: fix
        { documentId: id, locale, publishedAt: null },
        { availableLocales: true, availableStatus: false }
      );
      ctx.body = { data: {}, meta };
      return;
    }
    if (permissionChecker2.cannot.read(version)) {
      return ctx.forbidden();
    }
    const sanitizedDocument = await permissionChecker2.sanitizeOutput(version);
    ctx.body = await formatDocumentWithMetadata(permissionChecker2, model, sanitizedDocument);
  },
  async create(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    const [totalEntries, document] = await Promise.all([
      strapi.db.query(model).count(),
      createDocument(ctx)
    ]);
    const sanitizedDocument = await permissionChecker2.sanitizeOutput(document);
    ctx.status = 201;
    ctx.body = await formatDocumentWithMetadata(permissionChecker2, model, sanitizedDocument, {
      // Empty metadata as it's not relevant for a new document
      availableLocales: false,
      availableStatus: false
    });
    if (totalEntries === 0) {
      strapi.telemetry.send("didCreateFirstContentTypeEntry", {
        eventProperties: { model }
      });
    }
  },
  async update(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    const updatedVersion = await updateDocument(ctx);
    const sanitizedVersion = await permissionChecker2.sanitizeOutput(updatedVersion);
    ctx.body = await formatDocumentWithMetadata(permissionChecker2, model, sanitizedVersion);
  },
  async clone(ctx) {
    const { userAbility, user } = ctx.state;
    const { model, sourceId: id } = ctx.params;
    const { body } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.create()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.create(ctx.query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).build();
    const { locale } = await getDocumentLocaleAndStatus(body, model);
    const document = await documentManager2.findOne(id, model, {
      populate,
      locale,
      status: "draft"
    });
    if (!document) {
      return ctx.notFound();
    }
    const pickPermittedFields = permissionChecker2.sanitizeCreateInput;
    const setCreator = strapiUtils.setCreatorFields({ user });
    const excludeNotCreatable = excludeNotCreatableFields(model, permissionChecker2);
    const sanitizeFn = strapiUtils.async.pipe(pickPermittedFields, setCreator, excludeNotCreatable);
    const sanitizedBody = await sanitizeFn(body);
    const clonedDocument = await documentManager2.clone(document.documentId, sanitizedBody, model);
    const sanitizedDocument = await permissionChecker2.sanitizeOutput(clonedDocument);
    ctx.body = await formatDocumentWithMetadata(permissionChecker2, model, sanitizedDocument, {
      // Empty metadata as it's not relevant for a new document
      availableLocales: false,
      availableStatus: false
    });
  },
  async autoClone(ctx) {
    const { model } = ctx.params;
    const prohibitedFields = getProhibitedCloningFields(model);
    if (prohibitedFields.length > 0) {
      return ctx.badRequest(
        "Entity could not be cloned as it has unique and/or relational fields. Please edit those fields manually and save to complete the cloning.",
        {
          prohibitedFields
        }
      );
    }
    await this.clone(ctx);
  },
  async delete(ctx) {
    const { userAbility } = ctx.state;
    const { id, model } = ctx.params;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.delete()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.delete(ctx.query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).build();
    const { locale } = await getDocumentLocaleAndStatus(ctx.query, model);
    const documentLocales = await documentManager2.findLocales(id, model, { populate, locale });
    if (documentLocales.length === 0) {
      return ctx.notFound();
    }
    for (const document of documentLocales) {
      if (permissionChecker2.cannot.delete(document)) {
        return ctx.forbidden();
      }
    }
    const result = await documentManager2.delete(id, model, { locale });
    ctx.body = await permissionChecker2.sanitizeOutput(result);
  },
  /**
   * Publish a document version.
   * Supports creating/saving a document and publishing it in one request.
   */
  async publish(ctx) {
    const { userAbility } = ctx.state;
    const { id, model } = ctx.params;
    const { body } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.publish()) {
      return ctx.forbidden();
    }
    const publishedDocument = await strapi.db.transaction(async () => {
      const permissionQuery = await permissionChecker2.sanitizedQuery.publish(ctx.query);
      const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).populateDeep(Infinity).countRelations().build();
      let document;
      const { locale } = await getDocumentLocaleAndStatus(body, model);
      const isCreate = fp.isNil(id);
      if (isCreate) {
        if (permissionChecker2.cannot.create()) {
          throw new strapiUtils.errors.ForbiddenError();
        }
        document = await createDocument(ctx, { populate });
      }
      const isUpdate = !isCreate;
      if (isUpdate) {
        document = await documentManager2.findOne(id, model, { populate, locale });
        if (!document) {
          throw new strapiUtils.errors.NotFoundError("Document not found");
        }
        if (permissionChecker2.can.update(document)) {
          await updateDocument(ctx);
        }
      }
      if (permissionChecker2.cannot.publish(document)) {
        throw new strapiUtils.errors.ForbiddenError();
      }
      const publishResult = await documentManager2.publish(document.documentId, model, {
        locale
        // TODO: Allow setting creator fields on publish
        // data: setCreatorFields({ user, isEdition: true })({}),
      });
      if (!publishResult || publishResult.length === 0) {
        throw new strapiUtils.errors.NotFoundError("Document not found or already published.");
      }
      return publishResult[0];
    });
    const sanitizedDocument = await permissionChecker2.sanitizeOutput(publishedDocument);
    ctx.body = await formatDocumentWithMetadata(permissionChecker2, model, sanitizedDocument);
  },
  async bulkPublish(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { body } = ctx.request;
    const { documentIds } = body;
    await validateBulkActionInput(body);
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.publish()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.publish(ctx.query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).populateDeep(Infinity).countRelations().build();
    const { locale } = await getDocumentLocaleAndStatus(body, model, {
      allowMultipleLocales: true
    });
    const entityPromises = documentIds.map(
      (documentId) => documentManager2.findLocales(documentId, model, { populate, locale, isPublished: false })
    );
    const entities = (await Promise.all(entityPromises)).flat();
    for (const entity of entities) {
      if (!entity) {
        return ctx.notFound();
      }
      if (permissionChecker2.cannot.publish(entity)) {
        return ctx.forbidden();
      }
    }
    const count = await documentManager2.publishMany(model, documentIds, locale);
    ctx.body = { count };
  },
  async bulkUnpublish(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { body } = ctx.request;
    const { documentIds } = body;
    await validateBulkActionInput(body);
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.unpublish()) {
      return ctx.forbidden();
    }
    const { locale } = await getDocumentLocaleAndStatus(body, model, {
      allowMultipleLocales: true
    });
    const entityPromises = documentIds.map(
      (documentId) => documentManager2.findLocales(documentId, model, { locale, isPublished: true })
    );
    const entities = (await Promise.all(entityPromises)).flat();
    for (const entity of entities) {
      if (!entity) {
        return ctx.notFound();
      }
      if (permissionChecker2.cannot.publish(entity)) {
        return ctx.forbidden();
      }
    }
    const entitiesIds = entities.map((document) => document.documentId);
    const { count } = await documentManager2.unpublishMany(entitiesIds, model, { locale });
    ctx.body = { count };
  },
  async unpublish(ctx) {
    const { userAbility } = ctx.state;
    const { id, model } = ctx.params;
    const {
      body: { discardDraft, ...body }
    } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.unpublish()) {
      return ctx.forbidden();
    }
    if (discardDraft && permissionChecker2.cannot.discard()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.unpublish(ctx.query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).build();
    const { locale } = await getDocumentLocaleAndStatus(body, model);
    const document = await documentManager2.findOne(id, model, {
      populate,
      locale,
      status: "published"
    });
    if (!document) {
      throw new strapiUtils.errors.NotFoundError();
    }
    if (permissionChecker2.cannot.unpublish(document)) {
      throw new strapiUtils.errors.ForbiddenError();
    }
    if (discardDraft && permissionChecker2.cannot.discard(document)) {
      throw new strapiUtils.errors.ForbiddenError();
    }
    await strapi.db.transaction(async () => {
      if (discardDraft) {
        await documentManager2.discardDraft(document.documentId, model, { locale });
      }
      ctx.body = await strapiUtils.async.pipe(
        (document2) => documentManager2.unpublish(document2.documentId, model, { locale }),
        permissionChecker2.sanitizeOutput,
        (document2) => formatDocumentWithMetadata(permissionChecker2, model, document2)
      )(document);
    });
  },
  async discard(ctx) {
    const { userAbility } = ctx.state;
    const { id, model } = ctx.params;
    const { body } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.discard()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.discard(ctx.query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).build();
    const { locale } = await getDocumentLocaleAndStatus(body, model);
    const document = await documentManager2.findOne(id, model, {
      populate,
      locale,
      status: "published"
    });
    if (!document) {
      return ctx.notFound();
    }
    if (permissionChecker2.cannot.discard(document)) {
      return ctx.forbidden();
    }
    ctx.body = await strapiUtils.async.pipe(
      (document2) => documentManager2.discardDraft(document2.documentId, model, { locale }),
      permissionChecker2.sanitizeOutput,
      (document2) => formatDocumentWithMetadata(permissionChecker2, model, document2)
    )(document);
  },
  async bulkDelete(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { query, body } = ctx.request;
    const { documentIds } = body;
    await validateBulkActionInput(body);
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.delete()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.delete(query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).build();
    const { locale } = await getDocumentLocaleAndStatus(body, model);
    const documentLocales = await documentManager2.findLocales(documentIds, model, {
      populate,
      locale
    });
    if (documentLocales.length === 0) {
      return ctx.notFound();
    }
    for (const document of documentLocales) {
      if (permissionChecker2.cannot.delete(document)) {
        return ctx.forbidden();
      }
    }
    const localeDocumentsIds = documentLocales.map((document) => document.documentId);
    const { count } = await documentManager2.deleteMany(localeDocumentsIds, model, { locale });
    ctx.body = { count };
  },
  async countDraftRelations(ctx) {
    const { userAbility } = ctx.state;
    const { model, id } = ctx.params;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.read()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.read(ctx.query);
    const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).build();
    const { locale, status } = await getDocumentLocaleAndStatus(ctx.query, model);
    const entity = await documentManager2.findOne(id, model, { populate, locale, status });
    if (!entity) {
      return ctx.notFound();
    }
    if (permissionChecker2.cannot.read(entity)) {
      return ctx.forbidden();
    }
    const number = await documentManager2.countDraftRelations(id, model, locale);
    return {
      data: number
    };
  },
  async countManyEntriesDraftRelations(ctx) {
    const { userAbility } = ctx.state;
    const ids = ctx.request.query.documentIds;
    const locale = ctx.request.query.locale;
    const { model } = ctx.params;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.read()) {
      return ctx.forbidden();
    }
    const documents = await documentManager2.findMany(
      {
        filters: {
          documentId: ids
        },
        locale
      },
      model
    );
    if (!documents) {
      return ctx.notFound();
    }
    const number = await documentManager2.countManyEntriesDraftRelations(ids, model, locale);
    return {
      data: number
    };
  }
};
const components$1 = {
  findComponents(ctx) {
    const components2 = getService$1("components").findAllComponents();
    const { toDto } = getService$1("data-mapper");
    ctx.body = { data: components2.map(toDto) };
  },
  async findComponentConfiguration(ctx) {
    const { uid: uid2 } = ctx.params;
    const componentService = getService$1("components");
    const component = componentService.findComponent(uid2);
    if (!component) {
      return ctx.notFound("component.notFound");
    }
    const configuration = await componentService.findConfiguration(component);
    const componentsConfigurations = await componentService.findComponentsConfigurations(component);
    ctx.body = {
      data: {
        component: configuration,
        components: componentsConfigurations
      }
    };
  },
  async updateComponentConfiguration(ctx) {
    const { uid: uid2 } = ctx.params;
    const { body } = ctx.request;
    const componentService = getService$1("components");
    const component = componentService.findComponent(uid2);
    if (!component) {
      return ctx.notFound("component.notFound");
    }
    let input;
    try {
      input = await createModelConfigurationSchema(component).validate(body, {
        abortEarly: false,
        stripUnknown: true,
        strict: true
      });
    } catch (error) {
      return ctx.badRequest(null, {
        name: "validationError",
        errors: error.errors
      });
    }
    const newConfiguration = await componentService.updateConfiguration(component, input);
    ctx.body = { data: newConfiguration };
  }
};
const hasEditMainField = fp.has("edit.mainField");
const getEditMainField = fp.prop("edit.mainField");
const assocListMainField = fp.assoc("list.mainField");
const assocMainField = (metadata) => hasEditMainField(metadata) ? assocListMainField(getEditMainField(metadata), metadata) : metadata;
const contentTypes = {
  async findContentTypes(ctx) {
    const { kind } = ctx.query;
    try {
      await validateKind(kind);
    } catch (error) {
      return ctx.send({ error }, 400);
    }
    const contentTypes2 = getService$1("content-types").findContentTypesByKind(kind);
    const { toDto } = getService$1("data-mapper");
    ctx.body = { data: contentTypes2.map(toDto) };
  },
  async findContentTypesSettings(ctx) {
    const { findAllContentTypes, findConfiguration } = getService$1("content-types");
    const contentTypes2 = await findAllContentTypes();
    const configurations = await Promise.all(
      contentTypes2.map(async (contentType) => {
        const { uid: uid2, settings } = await findConfiguration(contentType);
        return { uid: uid2, settings };
      })
    );
    ctx.body = {
      data: configurations
    };
  },
  async findContentTypeConfiguration(ctx) {
    const { uid: uid2 } = ctx.params;
    const contentTypeService = getService$1("content-types");
    const contentType = await contentTypeService.findContentType(uid2);
    if (!contentType) {
      return ctx.notFound("contentType.notFound");
    }
    const configuration = await contentTypeService.findConfiguration(contentType);
    const confWithUpdatedMetadata = {
      ...configuration,
      metadatas: fp.mapValues(assocMainField, configuration.metadatas)
    };
    const components2 = await contentTypeService.findComponentsConfigurations(contentType);
    ctx.body = {
      data: {
        contentType: confWithUpdatedMetadata,
        components: components2
      }
    };
  },
  async updateContentTypeConfiguration(ctx) {
    const { userAbility } = ctx.state;
    const { uid: uid2 } = ctx.params;
    const { body } = ctx.request;
    const contentTypeService = getService$1("content-types");
    const metricsService = getService$1("metrics");
    const contentType = await contentTypeService.findContentType(uid2);
    if (!contentType) {
      return ctx.notFound("contentType.notFound");
    }
    if (!getService$1("permission").canConfigureContentType({ userAbility, contentType })) {
      return ctx.forbidden();
    }
    let input;
    try {
      input = await createModelConfigurationSchema(contentType).validate(body, {
        abortEarly: false,
        stripUnknown: true,
        strict: true
      });
    } catch (error) {
      return ctx.badRequest(null, {
        name: "validationError",
        errors: error.errors
      });
    }
    const newConfiguration = await contentTypeService.updateConfiguration(contentType, input);
    await metricsService.sendDidConfigureListView(contentType, newConfiguration);
    const confWithUpdatedMetadata = {
      ...newConfiguration,
      metadatas: fp.mapValues(assocMainField, newConfiguration.metadatas)
    };
    const components2 = await contentTypeService.findComponentsConfigurations(contentType);
    ctx.body = {
      data: {
        contentType: confWithUpdatedMetadata,
        components: components2
      }
    };
  }
};
const init = {
  getInitData(ctx) {
    const { toDto } = getService$1("data-mapper");
    const { findAllComponents } = getService$1("components");
    const { getAllFieldSizes } = getService$1("field-sizes");
    const { findAllContentTypes } = getService$1("content-types");
    ctx.body = {
      data: {
        fieldSizes: getAllFieldSizes(),
        components: findAllComponents().map(toDto),
        contentTypes: findAllContentTypes().map(toDto)
      }
    };
  }
};
const validateFindAvailableSchema = strapiUtils.yup.object().shape({
  component: strapiUtils.yup.string(),
  id: strapiUtils.yup.strapiID(),
  _q: strapiUtils.yup.string(),
  idsToOmit: strapiUtils.yup.array().of(strapiUtils.yup.strapiID()),
  idsToInclude: strapiUtils.yup.array().of(strapiUtils.yup.strapiID()),
  page: strapiUtils.yup.number().integer().min(1),
  pageSize: strapiUtils.yup.number().integer().min(1).max(100),
  locale: strapiUtils.yup.string().nullable(),
  status: strapiUtils.yup.string().oneOf(["published", "draft"]).nullable()
}).required();
const validateFindExistingSchema = strapiUtils.yup.object().shape({
  page: strapiUtils.yup.number().integer().min(1),
  pageSize: strapiUtils.yup.number().integer().min(1).max(100),
  locale: strapiUtils.yup.string().nullable(),
  status: strapiUtils.yup.string().oneOf(["published", "draft"]).nullable()
}).required();
const validateFindAvailable = strapiUtils.validateYupSchema(validateFindAvailableSchema, { strict: false });
const validateFindExisting = strapiUtils.validateYupSchema(validateFindExistingSchema, { strict: false });
const { PUBLISHED_AT_ATTRIBUTE: PUBLISHED_AT_ATTRIBUTE$2, UPDATED_AT_ATTRIBUTE } = strapiUtils.contentTypes.constants;
const addFiltersClause = (params, filtersClause) => {
  params.filters = params.filters || {};
  params.filters.$and = params.filters.$and || [];
  params.filters.$and.push(filtersClause);
};
const sanitizeMainField = (model, mainField, userAbility) => {
  const permissionChecker2 = getService$1("permission-checker").create({
    userAbility,
    model: model.uid
  });
  const isMainFieldListable = isListable(model, mainField);
  const canReadMainField = permissionChecker2.can.read(null, mainField);
  if (!isMainFieldListable || !canReadMainField) {
    return "id";
  }
  if (model.uid === "plugin::users-permissions.role") {
    return "name";
  }
  return mainField;
};
const addStatusToRelations = async (uid2, relations2) => {
  if (!strapiUtils.contentTypes.hasDraftAndPublish(strapi.contentTypes[uid2])) {
    return relations2;
  }
  const documentMetadata2 = getService$1("document-metadata");
  const documentsAvailableStatus = await documentMetadata2.getManyAvailableStatus(uid2, relations2);
  return relations2.map((relation) => {
    const availableStatuses = documentsAvailableStatus.filter(
      (availableDocument) => availableDocument.documentId === relation.documentId
    );
    return {
      ...relation,
      status: documentMetadata2.getStatus(relation, availableStatuses)
    };
  });
};
const getPublishedAtClause = (status, uid2) => {
  const model = strapi.getModel(uid2);
  if (!model || !strapiUtils.contentTypes.hasDraftAndPublish(model)) {
    return {};
  }
  return status === "published" ? { $notNull: true } : { $null: true };
};
const validateLocale = (sourceUid, targetUid, locale) => {
  const sourceModel = strapi.getModel(sourceUid);
  const targetModel = strapi.getModel(targetUid);
  const isLocalized = strapi.plugin("i18n").service("content-types").isLocalizedContentType;
  const isSourceLocalized = isLocalized(sourceModel);
  const isTargetLocalized = isLocalized(targetModel);
  let validatedLocale = locale;
  if (!targetModel || !isTargetLocalized)
    validatedLocale = void 0;
  return {
    locale: validatedLocale,
    isSourceLocalized,
    isTargetLocalized
  };
};
const validateStatus = (sourceUid, status) => {
  const sourceModel = strapi.getModel(sourceUid);
  const isDP = strapiUtils.contentTypes.hasDraftAndPublish;
  const isSourceDP = isDP(sourceModel);
  if (!isSourceDP)
    return { status: void 0 };
  switch (status) {
    case "published":
      return { status: "published" };
    default:
      return { status: "draft" };
  }
};
const relations = {
  async extractAndValidateRequestInfo(ctx, id) {
    const { userAbility } = ctx.state;
    const { model, targetField } = ctx.params;
    const sourceSchema = strapi.getModel(model);
    if (!sourceSchema) {
      throw new strapiUtils.errors.ValidationError(`The model ${model} doesn't exist`);
    }
    const attribute = sourceSchema.attributes[targetField];
    if (!attribute || attribute.type !== "relation") {
      throw new strapiUtils.errors.ValidationError(
        `The relational field ${targetField} doesn't exist on ${model}`
      );
    }
    const sourceUid = model;
    const targetUid = attribute.target;
    const { locale, isSourceLocalized, isTargetLocalized } = validateLocale(
      sourceUid,
      targetUid,
      ctx.request?.query?.locale
    );
    const { status } = validateStatus(sourceUid, ctx.request?.query?.status);
    const permissionChecker2 = getService$1("permission-checker").create({
      userAbility,
      model
    });
    const isComponent2 = sourceSchema.modelType === "component";
    if (!isComponent2) {
      if (permissionChecker2.cannot.read(null, targetField)) {
        return ctx.forbidden();
      }
    }
    let entryId = null;
    if (id) {
      const where = {};
      if (!isComponent2) {
        where.documentId = id;
        if (status) {
          where.publishedAt = getPublishedAtClause(status, sourceUid);
        }
        if (locale && isSourceLocalized) {
          where.locale = locale;
        }
      } else {
        where.id = id;
      }
      const permissionQuery = await permissionChecker2.sanitizedQuery.read(ctx.query);
      const populate = await getService$1("populate-builder")(model).populateFromQuery(permissionQuery).build();
      const currentEntity = await strapi.db.query(model).findOne({
        where,
        populate
      });
      if (!currentEntity) {
        throw new strapiUtils.errors.NotFoundError();
      }
      if (!isComponent2) {
        if (permissionChecker2.cannot.read(currentEntity, targetField)) {
          throw new strapiUtils.errors.ForbiddenError();
        }
      }
      entryId = currentEntity.id;
    }
    const modelConfig = isComponent2 ? await getService$1("components").findConfiguration(sourceSchema) : await getService$1("content-types").findConfiguration(sourceSchema);
    const targetSchema = strapi.getModel(targetUid);
    const mainField = fp.flow(
      fp.prop(`metadatas.${targetField}.edit.mainField`),
      (mainField2) => mainField2 || "id",
      (mainField2) => sanitizeMainField(targetSchema, mainField2, userAbility)
    )(modelConfig);
    const fieldsToSelect = fp.uniq([
      mainField,
      PUBLISHED_AT_ATTRIBUTE$2,
      UPDATED_AT_ATTRIBUTE,
      "documentId"
    ]);
    if (isTargetLocalized) {
      fieldsToSelect.push("locale");
    }
    return {
      entryId,
      locale,
      status,
      attribute,
      fieldsToSelect,
      mainField,
      source: { schema: sourceSchema },
      target: { schema: targetSchema, isLocalized: isTargetLocalized },
      sourceSchema,
      targetSchema,
      targetField
    };
  },
  /**
   * Used to find new relations to add in a relational field.
   *
   * Component and document relations are dealt a bit differently (they don't have a document_id).
   */
  async findAvailable(ctx) {
    const { id } = ctx.request.query;
    await validateFindAvailable(ctx.request.query);
    const {
      locale,
      status,
      targetField,
      fieldsToSelect,
      mainField,
      source: {
        schema: { uid: sourceUid, modelType: sourceModelType }
      },
      target: {
        schema: { uid: targetUid },
        isLocalized: isTargetLocalized
      }
    } = await this.extractAndValidateRequestInfo(ctx, id);
    const { idsToOmit, idsToInclude, _q, ...query } = ctx.request.query;
    const permissionChecker2 = getService$1("permission-checker").create({
      userAbility: ctx.state.userAbility,
      model: targetUid
    });
    const permissionQuery = await permissionChecker2.sanitizedQuery.read(query);
    const queryParams = {
      sort: mainField,
      // cannot select other fields as the user may not have the permissions
      fields: fieldsToSelect,
      ...permissionQuery
    };
    addFiltersClause(queryParams, {
      publishedAt: getPublishedAtClause(status, targetUid)
    });
    const filterByLocale = isTargetLocalized && locale;
    if (filterByLocale) {
      addFiltersClause(queryParams, { locale });
    }
    if (id) {
      const subQuery = strapi.db.queryBuilder(sourceUid);
      const alias = subQuery.getAlias();
      const where = {
        [`${alias}.id`]: { $notNull: true },
        [`${alias}.document_id`]: { $notNull: true }
      };
      if (sourceModelType === "contentType") {
        where.document_id = id;
      } else {
        where.id = id;
      }
      if (status) {
        where[`${alias}.published_at`] = getPublishedAtClause(status, targetUid);
      }
      if (filterByLocale) {
        where[`${alias}.locale`] = locale;
      }
      if ((idsToInclude?.length ?? 0) !== 0) {
        where[`${alias}.id`].$notIn = idsToInclude;
      }
      const knexSubQuery = subQuery.where(where).join({ alias, targetField }).select(`${alias}.id`).getKnexQuery();
      addFiltersClause(queryParams, {
        id: { $notIn: knexSubQuery }
      });
    }
    if (_q) {
      const _filter = strapiUtils.isOperatorOfType("where", query._filter) ? query._filter : "$containsi";
      addFiltersClause(queryParams, { [mainField]: { [_filter]: _q } });
    }
    if (idsToOmit?.length > 0) {
      addFiltersClause(queryParams, {
        id: { $notIn: fp.uniq(idsToOmit) }
      });
    }
    const res = await strapi.db.query(targetUid).findPage(strapi.get("query-params").transform(targetUid, queryParams));
    ctx.body = {
      ...res,
      results: await addStatusToRelations(targetUid, res.results)
    };
  },
  async findExisting(ctx) {
    const { userAbility } = ctx.state;
    const { id } = ctx.params;
    await validateFindExisting(ctx.request.query);
    const {
      entryId,
      attribute,
      targetField,
      fieldsToSelect,
      source: {
        schema: { uid: sourceUid }
      },
      target: {
        schema: { uid: targetUid }
      }
    } = await this.extractAndValidateRequestInfo(ctx, id);
    const permissionQuery = await getService$1("permission-checker").create({ userAbility, model: targetUid }).sanitizedQuery.read({ fields: fieldsToSelect });
    const dbQuery = strapi.db.query(sourceUid);
    const loadRelations = strapiUtils.relations.isAnyToMany(attribute) ? (...args) => dbQuery.loadPages(...args) : (...args) => dbQuery.load(...args).then((res2) => ({ results: res2 ? [res2] : [] }));
    const res = await loadRelations({ id: entryId }, targetField, {
      select: ["id", "documentId", "locale", "publishedAt"],
      ordering: "desc",
      page: ctx.request.query.page,
      pageSize: ctx.request.query.pageSize
    });
    const loadedIds = res.results.map((item) => item.id);
    addFiltersClause(permissionQuery, { id: { $in: loadedIds } });
    const sanitizedRes = await loadRelations({ id: entryId }, targetField, {
      ...strapi.get("query-params").transform(targetUid, permissionQuery),
      ordering: "desc"
    });
    const relationsUnion = fp.uniqBy("id", fp.concat(sanitizedRes.results, res.results));
    ctx.body = {
      pagination: res.pagination || {
        page: 1,
        pageCount: 1,
        pageSize: 10,
        total: relationsUnion.length
      },
      results: await addStatusToRelations(targetUid, relationsUnion)
    };
  }
};
const buildPopulateFromQuery = async (query, model) => {
  return getService$1("populate-builder")(model).populateFromQuery(query).populateDeep(Infinity).countRelations().build();
};
const findDocument = async (query, uid2, opts = {}) => {
  const documentManager2 = getService$1("document-manager");
  const populate = await buildPopulateFromQuery(query, uid2);
  return documentManager2.findMany({ ...opts, populate }, uid2).then((documents) => documents[0]);
};
const createOrUpdateDocument = async (ctx, opts) => {
  const { user, userAbility } = ctx.state;
  const { model } = ctx.params;
  const { body, query } = ctx.request;
  const documentManager2 = getService$1("document-manager");
  const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
  if (permissionChecker2.cannot.create() && permissionChecker2.cannot.update()) {
    throw new strapiUtils.errors.ForbiddenError();
  }
  const sanitizedQuery = await permissionChecker2.sanitizedQuery.update(query);
  const { locale } = await getDocumentLocaleAndStatus(body, model);
  const [documentVersion, otherDocumentVersion] = await Promise.all([
    findDocument(sanitizedQuery, model, { locale, status: "draft" }),
    // Find the first document to check if it exists
    strapi.db.query(model).findOne({ select: ["documentId"] })
  ]);
  const documentId = otherDocumentVersion?.documentId;
  const pickPermittedFields = documentVersion ? permissionChecker2.sanitizeUpdateInput(documentVersion) : permissionChecker2.sanitizeCreateInput;
  const setCreator = documentVersion ? strapiUtils.setCreatorFields({ user, isEdition: true }) : strapiUtils.setCreatorFields({ user });
  const sanitizeFn = strapiUtils.async.pipe(pickPermittedFields, setCreator);
  if (documentVersion) {
    if (permissionChecker2.cannot.update(documentVersion)) {
      throw new strapiUtils.errors.ForbiddenError();
    }
  } else if (permissionChecker2.cannot.create()) {
    throw new strapiUtils.errors.ForbiddenError();
  }
  const sanitizedBody = await sanitizeFn(body);
  if (!documentId) {
    return documentManager2.create(model, {
      data: sanitizedBody,
      ...sanitizedQuery,
      locale
    });
  }
  return documentManager2.update(documentId, model, {
    data: sanitizedBody,
    populate: opts?.populate,
    locale
  });
};
const singleTypes = {
  async find(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { query = {} } = ctx.request;
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.read()) {
      return ctx.forbidden();
    }
    const permissionQuery = await permissionChecker2.sanitizedQuery.read(query);
    const { locale, status } = await getDocumentLocaleAndStatus(query, model);
    const version = await findDocument(permissionQuery, model, { locale, status });
    if (!version) {
      if (permissionChecker2.cannot.create()) {
        return ctx.forbidden();
      }
      const document = await strapi.db.query(model).findOne({});
      if (!document) {
        return ctx.notFound();
      }
      const { meta } = await formatDocumentWithMetadata(
        permissionChecker2,
        model,
        // @ts-expect-error - fix types
        { id: document.documentId, locale, publishedAt: null },
        { availableLocales: true, availableStatus: false }
      );
      ctx.body = { data: {}, meta };
      return;
    }
    if (permissionChecker2.cannot.read(version)) {
      return ctx.forbidden();
    }
    const sanitizedDocument = await permissionChecker2.sanitizeOutput(version);
    ctx.body = await formatDocumentWithMetadata(permissionChecker2, model, sanitizedDocument);
  },
  async createOrUpdate(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    const document = await createOrUpdateDocument(ctx);
    const sanitizedDocument = await permissionChecker2.sanitizeOutput(document);
    ctx.body = await formatDocumentWithMetadata(permissionChecker2, model, sanitizedDocument);
  },
  async delete(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { query = {} } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.delete()) {
      return ctx.forbidden();
    }
    const sanitizedQuery = await permissionChecker2.sanitizedQuery.delete(query);
    const populate = await buildPopulateFromQuery(sanitizedQuery, model);
    const { locale } = await getDocumentLocaleAndStatus(query, model);
    const documentLocales = await documentManager2.findLocales(void 0, model, {
      populate,
      locale
    });
    if (documentLocales.length === 0) {
      return ctx.notFound();
    }
    for (const document of documentLocales) {
      if (permissionChecker2.cannot.delete(document)) {
        return ctx.forbidden();
      }
    }
    const deletedEntity = await documentManager2.delete(documentLocales.at(0).documentId, model, {
      locale
    });
    ctx.body = await permissionChecker2.sanitizeOutput(deletedEntity);
  },
  async publish(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { query = {} } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.publish()) {
      return ctx.forbidden();
    }
    const publishedDocument = await strapi.db.transaction(async () => {
      const sanitizedQuery = await permissionChecker2.sanitizedQuery.publish(query);
      const populate = await buildPopulateFromQuery(sanitizedQuery, model);
      const document = await createOrUpdateDocument(ctx, { populate });
      if (!document) {
        throw new strapiUtils.errors.NotFoundError();
      }
      if (permissionChecker2.cannot.publish(document)) {
        throw new strapiUtils.errors.ForbiddenError();
      }
      const { locale } = await getDocumentLocaleAndStatus(document, model);
      const publishResult = await documentManager2.publish(document.documentId, model, { locale });
      return publishResult.at(0);
    });
    const sanitizedDocument = await permissionChecker2.sanitizeOutput(publishedDocument);
    ctx.body = await formatDocumentWithMetadata(permissionChecker2, model, sanitizedDocument);
  },
  async unpublish(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const {
      body: { discardDraft, ...body },
      query = {}
    } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.unpublish()) {
      return ctx.forbidden();
    }
    if (discardDraft && permissionChecker2.cannot.discard()) {
      return ctx.forbidden();
    }
    const sanitizedQuery = await permissionChecker2.sanitizedQuery.unpublish(query);
    const { locale } = await getDocumentLocaleAndStatus(body, model);
    const document = await findDocument(sanitizedQuery, model, { locale });
    if (!document) {
      return ctx.notFound();
    }
    if (permissionChecker2.cannot.unpublish(document)) {
      return ctx.forbidden();
    }
    if (discardDraft && permissionChecker2.cannot.discard(document)) {
      return ctx.forbidden();
    }
    await strapi.db.transaction(async () => {
      if (discardDraft) {
        await documentManager2.discardDraft(document.documentId, model, { locale });
      }
      ctx.body = await strapiUtils.async.pipe(
        (document2) => documentManager2.unpublish(document2.documentId, model, { locale }),
        permissionChecker2.sanitizeOutput,
        (document2) => formatDocumentWithMetadata(permissionChecker2, model, document2)
      )(document);
    });
  },
  async discard(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { body, query = {} } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    if (permissionChecker2.cannot.discard()) {
      return ctx.forbidden();
    }
    const sanitizedQuery = await permissionChecker2.sanitizedQuery.discard(query);
    const { locale } = await getDocumentLocaleAndStatus(body, model);
    const document = await findDocument(sanitizedQuery, model, { locale, status: "published" });
    if (!document) {
      return ctx.notFound();
    }
    if (permissionChecker2.cannot.discard(document)) {
      return ctx.forbidden();
    }
    ctx.body = await strapiUtils.async.pipe(
      (document2) => documentManager2.discardDraft(document2.documentId, model, { locale }),
      permissionChecker2.sanitizeOutput,
      (document2) => formatDocumentWithMetadata(permissionChecker2, model, document2)
    )(document);
  },
  async countDraftRelations(ctx) {
    const { userAbility } = ctx.state;
    const { model } = ctx.params;
    const { query } = ctx.request;
    const documentManager2 = getService$1("document-manager");
    const permissionChecker2 = getService$1("permission-checker").create({ userAbility, model });
    const { locale } = await getDocumentLocaleAndStatus(query, model);
    if (permissionChecker2.cannot.read()) {
      return ctx.forbidden();
    }
    const document = await findDocument({}, model);
    if (!document) {
      return ctx.notFound();
    }
    if (permissionChecker2.cannot.read(document)) {
      return ctx.forbidden();
    }
    const number = await documentManager2.countDraftRelations(document.documentId, model, locale);
    return {
      data: number
    };
  }
};
const uid$1 = {
  async generateUID(ctx) {
    const { contentTypeUID, field, data } = await validateGenerateUIDInput(ctx.request.body);
    const { query = {} } = ctx.request;
    const { locale } = await getDocumentLocaleAndStatus(query, contentTypeUID);
    await validateUIDField(contentTypeUID, field);
    const uidService = getService$1("uid");
    ctx.body = {
      data: await uidService.generateUIDField({ contentTypeUID, field, data, locale })
    };
  },
  async checkUIDAvailability(ctx) {
    const { contentTypeUID, field, value } = await validateCheckUIDAvailabilityInput(
      ctx.request.body
    );
    const { query = {} } = ctx.request;
    const { locale } = await getDocumentLocaleAndStatus(query, contentTypeUID);
    await validateUIDField(contentTypeUID, field);
    const uidService = getService$1("uid");
    const isAvailable = await uidService.checkUIDAvailability({
      contentTypeUID,
      field,
      value,
      locale
    });
    ctx.body = {
      isAvailable,
      suggestion: !isAvailable ? await uidService.findUniqueUID({ contentTypeUID, field, value, locale }) : null
    };
  }
};
const controllers = {
  "collection-types": collectionTypes,
  components: components$1,
  "content-types": contentTypes,
  init,
  relations,
  "single-types": singleTypes,
  uid: uid$1,
  ...history.controllers ? history.controllers : {}
};
const keys = {
  CONFIGURATION: "configuration"
};
const getStore = () => strapi.store({ type: "plugin", name: "content_manager" });
const EMPTY_CONFIG = {
  settings: {},
  metadatas: {},
  layouts: {}
};
const configurationKey = (key) => `${keys.CONFIGURATION}_${key}`;
const getModelConfiguration = async (key) => {
  const config = await getStore().get({ key: configurationKey(key) });
  return ___default.default.merge({}, EMPTY_CONFIG, config);
};
const setModelConfiguration = async (key, value) => {
  const storedConfig = await getStore().get({ key: configurationKey(key) }) || {};
  const currentConfig = { ...storedConfig };
  Object.keys(value).forEach((key2) => {
    if (value[key2] !== null && value[key2] !== void 0) {
      ___default.default.set(currentConfig, key2, value[key2]);
    }
  });
  if (!___default.default.isEqual(currentConfig, storedConfig)) {
    return getStore().set({
      key: configurationKey(key),
      value: currentConfig
    });
  }
};
const deleteKey = (key) => {
  return strapi.db.query("strapi::core-store").delete({ where: { key: `plugin_content_manager_configuration_${key}` } });
};
const findByKey = async (key) => {
  const results = await strapi.db.query("strapi::core-store").findMany({
    where: {
      key: {
        $startsWith: key
      }
    }
  });
  return results.map(({ value }) => JSON.parse(value));
};
const getAllConfigurations = () => findByKey("plugin_content_manager_configuration");
const storeUtils = {
  getAllConfigurations,
  findByKey,
  getModelConfiguration,
  setModelConfiguration,
  deleteKey,
  keys
};
function createDefaultMetadatas(schema) {
  return {
    ...Object.keys(schema.attributes).reduce((acc, name) => {
      acc[name] = createDefaultMetadata(schema, name);
      return acc;
    }, {}),
    id: {
      edit: {},
      list: {
        label: "id",
        searchable: true,
        sortable: true
      }
    }
  };
}
function createDefaultMetadata(schema, name) {
  const edit = {
    label: name,
    description: "",
    placeholder: "",
    visible: isVisible$1(schema, name),
    editable: true
  };
  const fieldAttributes = schema.attributes[name];
  if (isRelation$1(fieldAttributes)) {
    const { targetModel } = fieldAttributes;
    const targetSchema = getTargetSchema(targetModel);
    if (targetSchema) {
      edit.mainField = getDefaultMainField(targetSchema);
    }
  }
  ___default.default.assign(
    edit,
    ___default.default.pick(___default.default.get(schema, ["config", "metadatas", name, "edit"], {}), [
      "label",
      "description",
      "placeholder",
      "visible",
      "editable",
      "mainField"
    ])
  );
  const list = {
    // @ts-expect-error we need to specify these properties
    label: name,
    // @ts-expect-error we need to specify these properties
    searchable: isSearchable(schema, name),
    // @ts-expect-error we need to specify these properties
    sortable: isSortable(schema, name),
    ...___default.default.pick(___default.default.get(schema, ["config", "metadatas", name, "list"], {}), [
      "label",
      "searchable",
      "sortable"
    ])
  };
  return { edit, list };
}
async function syncMetadatas(configuration, schema) {
  if (___default.default.isEmpty(configuration.metadatas)) {
    return createDefaultMetadatas(schema);
  }
  const metasWithValidKeys = ___default.default.pick(configuration.metadatas, Object.keys(schema.attributes));
  const metasWithDefaults = ___default.default.merge({}, createDefaultMetadatas(schema), metasWithValidKeys);
  const updatedMetas = Object.keys(metasWithDefaults).reduce((acc, key) => {
    const { edit, list } = metasWithDefaults[key];
    const attr = schema.attributes[key];
    const updatedMeta = { edit, list };
    if (list.sortable && !isSortable(schema, key)) {
      ___default.default.set(updatedMeta, ["list", "sortable"], false);
      ___default.default.set(acc, [key], updatedMeta);
    }
    if (list.searchable && !isSearchable(schema, key)) {
      ___default.default.set(updatedMeta, ["list", "searchable"], false);
      ___default.default.set(acc, [key], updatedMeta);
    }
    if (!___default.default.has(edit, "mainField"))
      return acc;
    if (!isRelation$1(attr)) {
      ___default.default.set(updatedMeta, "edit", ___default.default.omit(edit, ["mainField"]));
      ___default.default.set(acc, [key], updatedMeta);
      return acc;
    }
    if (edit.mainField === "id")
      return acc;
    const targetSchema = getTargetSchema(attr.targetModel);
    if (!targetSchema)
      return acc;
    if (!isSortable(targetSchema, edit.mainField) && !isListable(targetSchema, edit.mainField)) {
      ___default.default.set(updatedMeta, ["edit", "mainField"], getDefaultMainField(targetSchema));
      ___default.default.set(acc, [key], updatedMeta);
      return acc;
    }
    return acc;
  }, {});
  return ___default.default.assign(metasWithDefaults, updatedMetas);
}
const getTargetSchema = (targetModel) => {
  return getService$1("content-types").findContentType(targetModel);
};
const DEFAULT_LIST_LENGTH = 4;
const MAX_ROW_SIZE = 12;
const isAllowedFieldSize = (type, size) => {
  const { getFieldSize } = getService$1("field-sizes");
  const fieldSize = getFieldSize(type);
  if (!fieldSize.isResizable && size !== fieldSize.default) {
    return false;
  }
  return size <= MAX_ROW_SIZE;
};
const getDefaultFieldSize = (attribute) => {
  const { hasFieldSize, getFieldSize } = getService$1("field-sizes");
  return getFieldSize(hasFieldSize(attribute.customField) ? attribute.customField : attribute.type).default;
};
async function createDefaultLayouts(schema) {
  return {
    // @ts-expect-error necessary to provide this default layout
    list: createDefaultListLayout(schema),
    // @ts-expect-error necessary to provide this default layout
    edit: createDefaultEditLayout(schema),
    ...___default.default.pick(___default.default.get(schema, ["config", "layouts"], {}), ["list", "edit"])
  };
}
function createDefaultListLayout(schema) {
  return Object.keys(schema.attributes).filter((name) => isListable(schema, name)).slice(0, DEFAULT_LIST_LENGTH);
}
const rowSize = (els) => els.reduce((sum, el) => sum + el.size, 0);
function createDefaultEditLayout(schema) {
  const keys2 = Object.keys(schema.attributes).filter((name) => hasEditableAttribute(schema, name));
  return appendToEditLayout([], keys2, schema);
}
function syncLayouts(configuration, schema) {
  if (___default.default.isEmpty(configuration.layouts))
    return createDefaultLayouts(schema);
  const { list = [], editRelations = [], edit = [] } = configuration.layouts || {};
  let cleanList = list.filter((attr) => isListable(schema, attr));
  const cleanEditRelations = editRelations.filter(
    (attr) => hasRelationAttribute(schema, attr)
  );
  const elementsToReAppend = [...cleanEditRelations];
  let cleanEdit = [];
  for (const row of edit) {
    const newRow = [];
    for (const el of row) {
      if (!hasEditableAttribute(schema, el.name))
        continue;
      const { hasFieldSize } = getService$1("field-sizes");
      const fieldType = hasFieldSize(schema.attributes[el.name].customField) ? schema.attributes[el.name].customField : schema.attributes[el.name].type;
      if (!isAllowedFieldSize(fieldType, el.size)) {
        elementsToReAppend.push(el.name);
        continue;
      }
      newRow.push(el);
    }
    if (newRow.length > 0) {
      cleanEdit.push(newRow);
    }
  }
  cleanEdit = appendToEditLayout(cleanEdit, elementsToReAppend, schema);
  const newAttributes = ___default.default.difference(
    Object.keys(schema.attributes),
    Object.keys(configuration.metadatas)
  );
  if (cleanList.length < DEFAULT_LIST_LENGTH) {
    cleanList = ___default.default.uniq(
      cleanList.concat(newAttributes.filter((key) => isListable(schema, key))).slice(0, DEFAULT_LIST_LENGTH)
    );
  }
  const newEditAttributes = newAttributes.filter((key) => hasEditableAttribute(schema, key));
  cleanEdit = appendToEditLayout(cleanEdit, newEditAttributes, schema);
  return {
    list: cleanList.length > 0 ? cleanList : createDefaultListLayout(schema),
    edit: cleanEdit.length > 0 ? cleanEdit : createDefaultEditLayout(schema)
  };
}
const appendToEditLayout = (layout = [], keysToAppend, schema) => {
  if (keysToAppend.length === 0)
    return layout;
  let currentRowIndex = Math.max(layout.length - 1, 0);
  if (!layout[currentRowIndex]) {
    layout[currentRowIndex] = [];
  }
  for (const key of keysToAppend) {
    const attribute = schema.attributes[key];
    const attributeSize = getDefaultFieldSize(attribute);
    const currenRowSize = rowSize(layout[currentRowIndex]);
    if (currenRowSize + attributeSize > MAX_ROW_SIZE) {
      currentRowIndex += 1;
      layout[currentRowIndex] = [];
    }
    layout[currentRowIndex].push({
      name: key,
      size: attributeSize
    });
  }
  return layout;
};
async function validateCustomConfig(schema) {
  try {
    await createModelConfigurationSchema(schema, {
      allowUndefined: true
    }).validate(schema.config);
  } catch (error) {
    throw new Error(
      `Invalid Model configuration for model ${schema.uid}. Verify your {{ modelName }}.config.js(on) file:
  - ${error.message}
`
    );
  }
}
async function createDefaultConfiguration(schema) {
  await validateCustomConfig(schema);
  return {
    settings: await createDefaultSettings(schema),
    metadatas: await createDefaultMetadatas(schema),
    layouts: await createDefaultLayouts(schema)
  };
}
async function syncConfiguration(conf, schema) {
  await validateCustomConfig(schema);
  return {
    settings: await syncSettings(conf, schema),
    layouts: await syncLayouts(conf, schema),
    metadatas: await syncMetadatas(conf, schema)
  };
}
const createConfigurationService = ({
  isComponent: isComponent2,
  prefix,
  storeUtils: storeUtils2,
  getModels
}) => {
  const uidToStoreKey = (uid2) => {
    return `${prefix}::${uid2}`;
  };
  const getConfiguration = (uid2) => {
    const storeKey = uidToStoreKey(uid2);
    return storeUtils2.getModelConfiguration(storeKey);
  };
  const setConfiguration = (uid2, input) => {
    const configuration = {
      ...input,
      uid: uid2,
      isComponent: isComponent2 ?? void 0
    };
    const storeKey = uidToStoreKey(uid2);
    return storeUtils2.setModelConfiguration(storeKey, configuration);
  };
  const deleteConfiguration = (uid2) => {
    const storeKey = uidToStoreKey(uid2);
    return storeUtils2.deleteKey(storeKey);
  };
  const syncConfigurations = async () => {
    const models = getModels();
    const configurations = await storeUtils2.findByKey(
      `plugin_content_manager_configuration_${prefix}`
    );
    const updateConfiguration = async (uid2) => {
      const conf = configurations.find((conf2) => conf2.uid === uid2);
      return setConfiguration(uid2, await syncConfiguration(conf, models[uid2]));
    };
    const generateNewConfiguration = async (uid2) => {
      return setConfiguration(uid2, await createDefaultConfiguration(models[uid2]));
    };
    const currentUIDS = Object.keys(models);
    const DBUIDs = configurations.map(({ uid: uid2 }) => uid2);
    const contentTypesToUpdate = _.intersection(currentUIDS, DBUIDs);
    const contentTypesToAdd = _.difference(currentUIDS, DBUIDs);
    const contentTypesToDelete = _.difference(DBUIDs, currentUIDS);
    await Promise.all(contentTypesToDelete.map((uid2) => deleteConfiguration(uid2)));
    await Promise.all(contentTypesToAdd.map((uid2) => generateNewConfiguration(uid2)));
    await Promise.all(contentTypesToUpdate.map((uid2) => updateConfiguration(uid2)));
  };
  return {
    getConfiguration,
    setConfiguration,
    deleteConfiguration,
    syncConfigurations
  };
};
const STORE_KEY_PREFIX = "components";
const configurationService$1 = createConfigurationService({
  storeUtils,
  isComponent: true,
  prefix: STORE_KEY_PREFIX,
  getModels() {
    const { toContentManagerModel } = getService$1("data-mapper");
    return fp.mapValues(toContentManagerModel, strapi.components);
  }
});
const components = ({ strapi: strapi2 }) => ({
  findAllComponents() {
    const { toContentManagerModel } = getService$1("data-mapper");
    return Object.values(strapi2.components).map(toContentManagerModel);
  },
  findComponent(uid2) {
    const { toContentManagerModel } = getService$1("data-mapper");
    const component = strapi2.components[uid2];
    return fp.isNil(component) ? component : toContentManagerModel(component);
  },
  async findConfiguration(component) {
    const configuration = await configurationService$1.getConfiguration(component.uid);
    return {
      uid: component.uid,
      category: component.category,
      ...configuration
    };
  },
  async updateConfiguration(component, newConfiguration) {
    await configurationService$1.setConfiguration(component.uid, newConfiguration);
    return this.findConfiguration(component);
  },
  async findComponentsConfigurations(model) {
    const componentsMap = {};
    const getComponentConfigurations = async (uid2) => {
      const component = this.findComponent(uid2);
      if (fp.has(uid2, componentsMap)) {
        return;
      }
      const componentConfiguration = await this.findConfiguration(component);
      const componentsConfigurations = await this.findComponentsConfigurations(component);
      Object.assign(componentsMap, {
        [uid2]: componentConfiguration,
        ...componentsConfigurations
      });
    };
    for (const key of Object.keys(model.attributes)) {
      const attribute = model.attributes[key];
      if (attribute.type === "component") {
        await getComponentConfigurations(attribute.component);
      }
      if (attribute.type === "dynamiczone") {
        for (const componentUid of attribute.components) {
          await getComponentConfigurations(componentUid);
        }
      }
    }
    return componentsMap;
  },
  syncConfigurations() {
    return configurationService$1.syncConfigurations();
  }
});
const configurationService = createConfigurationService({
  storeUtils,
  prefix: "content_types",
  getModels() {
    const { toContentManagerModel } = getService$1("data-mapper");
    return fp.mapValues(toContentManagerModel, strapi.contentTypes);
  }
});
const service = ({ strapi: strapi2 }) => ({
  findAllContentTypes() {
    const { toContentManagerModel } = getService$1("data-mapper");
    return Object.values(strapi2.contentTypes).map(toContentManagerModel);
  },
  findContentType(uid2) {
    const { toContentManagerModel } = getService$1("data-mapper");
    const contentType = strapi2.contentTypes[uid2];
    return fp.isNil(contentType) ? contentType : toContentManagerModel(contentType);
  },
  findDisplayedContentTypes() {
    return this.findAllContentTypes().filter(
      // TODO
      // @ts-expect-error should be resolved from data-mapper types
      ({ isDisplayed }) => isDisplayed === true
    );
  },
  findContentTypesByKind(kind) {
    if (!kind) {
      return this.findAllContentTypes();
    }
    return this.findAllContentTypes().filter(strapiUtils.contentTypes.isKind(kind));
  },
  async findConfiguration(contentType) {
    const configuration = await configurationService.getConfiguration(contentType.uid);
    return {
      uid: contentType.uid,
      ...configuration
    };
  },
  async updateConfiguration(contentType, newConfiguration) {
    await configurationService.setConfiguration(contentType.uid, newConfiguration);
    return this.findConfiguration(contentType);
  },
  findComponentsConfigurations(contentType) {
    return getService$1("components").findComponentsConfigurations(contentType);
  },
  syncConfigurations() {
    return configurationService.syncConfigurations();
  }
});
const dtoFields = [
  "uid",
  "isDisplayed",
  "apiID",
  "kind",
  "category",
  "info",
  "options",
  "pluginOptions",
  "attributes",
  "pluginOptions"
];
const dataMapper = () => ({
  toContentManagerModel(contentType) {
    return {
      ...contentType,
      apiID: contentType.modelName,
      isDisplayed: isVisible(contentType),
      attributes: {
        id: {
          type: "integer"
        },
        ...formatAttributes(contentType)
      }
    };
  },
  toDto: fp.pick(dtoFields)
});
const formatAttributes = (contentType) => {
  const { getVisibleAttributes, getTimestamps, getCreatorFields } = strapiUtils.contentTypes;
  return getVisibleAttributes(contentType).concat(getTimestamps(contentType)).concat(getCreatorFields(contentType)).reduce((acc, key) => {
    const attribute = contentType.attributes[key];
    if (attribute.type === "relation" && attribute.relation.toLowerCase().includes("morph")) {
      return acc;
    }
    acc[key] = formatAttribute(key, attribute);
    return acc;
  }, {});
};
const formatAttribute = (key, attribute) => {
  if (attribute.type === "relation") {
    return toRelation(attribute);
  }
  return attribute;
};
const toRelation = (attribute) => {
  return {
    ...attribute,
    type: "relation",
    targetModel: "target" in attribute ? attribute.target : void 0,
    relationType: attribute.relation
  };
};
const isVisible = (model) => fp.getOr(true, "pluginOptions.content-manager.visible", model) === true;
const { ApplicationError: ApplicationError$1 } = strapiUtils.errors;
const needsFullSize = {
  default: 12,
  isResizable: false
};
const smallSize = {
  default: 4,
  isResizable: true
};
const defaultSize = {
  default: 6,
  isResizable: true
};
const fieldSizes = {
  // Full row and not resizable
  dynamiczone: needsFullSize,
  component: needsFullSize,
  json: needsFullSize,
  richtext: needsFullSize,
  blocks: needsFullSize,
  // Small and resizable
  checkbox: smallSize,
  boolean: smallSize,
  date: smallSize,
  time: smallSize,
  biginteger: smallSize,
  decimal: smallSize,
  float: smallSize,
  integer: smallSize,
  number: smallSize,
  // Medium and resizable
  datetime: defaultSize,
  email: defaultSize,
  enumeration: defaultSize,
  media: defaultSize,
  password: defaultSize,
  relation: defaultSize,
  string: defaultSize,
  text: defaultSize,
  timestamp: defaultSize,
  uid: defaultSize
};
const createFieldSizesService = ({ strapi: strapi2 }) => {
  const fieldSizesService = {
    getAllFieldSizes() {
      return fieldSizes;
    },
    hasFieldSize(type) {
      return !!fieldSizes[type];
    },
    getFieldSize(type) {
      if (!type) {
        throw new ApplicationError$1("The type is required");
      }
      const fieldSize = fieldSizes[type];
      if (!fieldSize) {
        throw new ApplicationError$1(`Could not find field size for type ${type}`);
      }
      return fieldSize;
    },
    setFieldSize(type, size) {
      if (!type) {
        throw new ApplicationError$1("The type is required");
      }
      if (!size) {
        throw new ApplicationError$1("The size is required");
      }
      fieldSizes[type] = size;
    },
    setCustomFieldInputSizes() {
      const customFields = strapi2.get("custom-fields").getAll();
      Object.entries(customFields).forEach(([uid2, customField]) => {
        if (customField.inputSize) {
          fieldSizesService.setFieldSize(uid2, customField.inputSize);
        }
      });
    }
  };
  return fieldSizesService;
};
const { getRelationalFields } = strapiUtils.relations;
const metrics = ({ strapi: strapi2 }) => {
  const sendDidConfigureListView = async (contentType, configuration) => {
    const displayedFields = fp.prop("length", configuration.layouts.list);
    const relationalFields = getRelationalFields(contentType);
    const displayedRelationalFields = fp.intersection(
      relationalFields,
      configuration.layouts.list
    ).length;
    const data = {
      eventProperties: { containsRelationalFields: !!displayedRelationalFields }
    };
    if (data.eventProperties.containsRelationalFields) {
      Object.assign(data.eventProperties, {
        displayedFields,
        displayedRelationalFields
      });
    }
    try {
      await strapi2.telemetry.send("didConfigureListView", data);
    } catch (e) {
    }
  };
  return {
    sendDidConfigureListView
  };
};
const ACTIONS = {
  read: "plugin::content-manager.explorer.read",
  create: "plugin::content-manager.explorer.create",
  update: "plugin::content-manager.explorer.update",
  delete: "plugin::content-manager.explorer.delete",
  publish: "plugin::content-manager.explorer.publish",
  unpublish: "plugin::content-manager.explorer.publish",
  discard: "plugin::content-manager.explorer.update"
};
const createPermissionChecker = (strapi2) => ({ userAbility, model }) => {
  const permissionsManager = strapi2.service("admin::permission").createPermissionsManager({
    ability: userAbility,
    model
  });
  const { actionProvider } = strapi2.service("admin::permission");
  const toSubject = (entity) => {
    return entity ? permissionsManager.toSubject(entity, model) : model;
  };
  const can = (action, entity, field) => {
    const subject = toSubject(entity);
    const aliases = actionProvider.unstable_aliases(action, model);
    return (
      // Test the original action to see if it passes
      userAbility.can(action, subject, field) || // Else try every known alias if at least one of them succeed, then the user "can"
      aliases.some((alias) => userAbility.can(alias, subject, field))
    );
  };
  const cannot = (action, entity, field) => {
    const subject = toSubject(entity);
    const aliases = actionProvider.unstable_aliases(action, model);
    return (
      // Test both the original action
      userAbility.cannot(action, subject, field) && // and every known alias, if all of them fail (cannot), then the user truly "cannot"
      aliases.every((alias) => userAbility.cannot(alias, subject, field))
    );
  };
  const sanitizeOutput = (data, { action = ACTIONS.read } = {}) => {
    return permissionsManager.sanitizeOutput(data, { subject: toSubject(data), action });
  };
  const sanitizeQuery = (query, { action = ACTIONS.read } = {}) => {
    return permissionsManager.sanitizeQuery(query, { subject: model, action });
  };
  const sanitizeInput = (action, data, entity) => {
    return permissionsManager.sanitizeInput(data, {
      subject: entity ? toSubject(entity) : model,
      action
    });
  };
  const validateQuery = (query, { action = ACTIONS.read } = {}) => {
    return permissionsManager.validateQuery(query, { subject: model, action });
  };
  const validateInput = (action, data, entity) => {
    return permissionsManager.validateInput(data, {
      subject: entity ? toSubject(entity) : model,
      action
    });
  };
  const sanitizeCreateInput = (data) => sanitizeInput(ACTIONS.create, data);
  const sanitizeUpdateInput = (entity) => (data) => sanitizeInput(ACTIONS.update, data, entity);
  const buildPermissionQuery = (query, action = {}) => {
    return permissionsManager.addPermissionsQueryTo(query, action);
  };
  const sanitizedQuery = (query, action = {}) => {
    return strapiUtils.async.pipe(
      (q) => sanitizeQuery(q, action),
      (q) => buildPermissionQuery(q, action)
    )(query);
  };
  Object.keys(ACTIONS).forEach((action) => {
    sanitizedQuery[action] = (query) => sanitizedQuery(query, ACTIONS[action]);
  });
  Object.keys(ACTIONS).forEach((action) => {
    can[action] = (...args) => can(ACTIONS[action], ...args);
    cannot[action] = (...args) => cannot(ACTIONS[action], ...args);
  });
  return {
    // Permission utils
    can,
    // check if you have the permission
    cannot,
    // check if you don't have the permission
    // Sanitizers
    sanitizeOutput,
    sanitizeQuery,
    sanitizeCreateInput,
    sanitizeUpdateInput,
    // Validators
    validateQuery,
    validateInput,
    // Queries Builder
    sanitizedQuery
  };
};
const permissionChecker = ({ strapi: strapi2 }) => ({
  create: createPermissionChecker(strapi2)
});
const permission = ({ strapi: strapi2 }) => ({
  canConfigureContentType({
    userAbility,
    contentType
  }) {
    const action = strapiUtils.contentTypes.isSingleType(contentType) ? "plugin::content-manager.single-types.configure-view" : "plugin::content-manager.collection-types.configure-view";
    return userAbility.can(action);
  },
  async registerPermissions() {
    const displayedContentTypes = getService$1("content-types").findDisplayedContentTypes();
    const contentTypesUids = displayedContentTypes.map(fp.prop("uid"));
    const actions = [
      {
        section: "contentTypes",
        displayName: "Create",
        uid: "explorer.create",
        pluginName: "content-manager",
        subjects: contentTypesUids,
        options: {
          applyToProperties: ["fields"]
        }
      },
      {
        section: "contentTypes",
        displayName: "Read",
        uid: "explorer.read",
        pluginName: "content-manager",
        subjects: contentTypesUids,
        options: {
          applyToProperties: ["fields"]
        }
      },
      {
        section: "contentTypes",
        displayName: "Update",
        uid: "explorer.update",
        pluginName: "content-manager",
        subjects: contentTypesUids,
        options: {
          applyToProperties: ["fields"]
        }
      },
      {
        section: "contentTypes",
        displayName: "Delete",
        uid: "explorer.delete",
        pluginName: "content-manager",
        subjects: contentTypesUids
      },
      {
        section: "contentTypes",
        displayName: "Publish",
        uid: "explorer.publish",
        pluginName: "content-manager",
        subjects: contentTypesUids
      },
      {
        section: "plugins",
        displayName: "Configure view",
        uid: "single-types.configure-view",
        subCategory: "single types",
        pluginName: "content-manager"
      },
      {
        section: "plugins",
        displayName: "Configure view",
        uid: "collection-types.configure-view",
        subCategory: "collection types",
        pluginName: "content-manager"
      },
      {
        section: "plugins",
        displayName: "Configure Layout",
        uid: "components.configure-layout",
        subCategory: "components",
        pluginName: "content-manager"
      }
    ];
    await strapi2.service("admin::permission").actionProvider.registerMany(actions);
  }
});
const { isVisibleAttribute: isVisibleAttribute$1, isScalarAttribute, getDoesAttributeRequireValidation } = strapiUtils__default.default.contentTypes;
const { isAnyToMany } = strapiUtils__default.default.relations;
const { PUBLISHED_AT_ATTRIBUTE: PUBLISHED_AT_ATTRIBUTE$1 } = strapiUtils__default.default.contentTypes.constants;
const isMorphToRelation = (attribute) => isRelation(attribute) && attribute.relation.includes("morphTo");
const isMedia = fp.propEq("type", "media");
const isRelation = fp.propEq("type", "relation");
const isComponent = fp.propEq("type", "component");
const isDynamicZone = fp.propEq("type", "dynamiczone");
function getPopulateForRelation(attribute, model, attributeName, { countMany, countOne, initialPopulate }) {
  const isManyRelation = isAnyToMany(attribute);
  if (initialPopulate) {
    return initialPopulate;
  }
  if (!isVisibleAttribute$1(model, attributeName)) {
    return true;
  }
  if (isManyRelation && countMany || !isManyRelation && countOne) {
    return { count: true };
  }
  return true;
}
function getPopulateForDZ(attribute, options, level) {
  const populatedComponents = (attribute.components || []).reduce(
    (acc, componentUID) => ({
      ...acc,
      [componentUID]: {
        populate: getDeepPopulate(componentUID, options, level + 1)
      }
    }),
    {}
  );
  return { on: populatedComponents };
}
function getPopulateFor(attributeName, model, options, level) {
  const attribute = model.attributes[attributeName];
  switch (attribute.type) {
    case "relation":
      return {
        [attributeName]: getPopulateForRelation(attribute, model, attributeName, options)
      };
    case "component":
      return {
        [attributeName]: {
          populate: getDeepPopulate(attribute.component, options, level + 1)
        }
      };
    case "media":
      return {
        [attributeName]: {
          populate: {
            folder: true
          }
        }
      };
    case "dynamiczone":
      return {
        [attributeName]: getPopulateForDZ(attribute, options, level)
      };
    default:
      return {};
  }
}
const getDeepPopulate = (uid2, {
  initialPopulate = {},
  countMany = false,
  countOne = false,
  maxLevel = Infinity
} = {}, level = 1) => {
  if (level > maxLevel) {
    return {};
  }
  const model = strapi.getModel(uid2);
  return Object.keys(model.attributes).reduce(
    (populateAcc, attributeName) => fp.merge(
      populateAcc,
      getPopulateFor(
        attributeName,
        model,
        {
          // @ts-expect-error - improve types
          initialPopulate: initialPopulate?.[attributeName],
          countMany,
          countOne,
          maxLevel
        },
        level
      )
    ),
    {}
  );
};
const getValidatableFieldsPopulate = (uid2, {
  initialPopulate = {},
  countMany = false,
  countOne = false,
  maxLevel = Infinity
} = {}, level = 1) => {
  if (level > maxLevel) {
    return {};
  }
  const model = strapi.getModel(uid2);
  return Object.entries(model.attributes).reduce((populateAcc, [attributeName, attribute]) => {
    if (!getDoesAttributeRequireValidation(attribute)) {
      return populateAcc;
    }
    if (isScalarAttribute(attribute)) {
      return fp.merge(populateAcc, {
        [attributeName]: true
      });
    }
    return fp.merge(
      populateAcc,
      getPopulateFor(
        attributeName,
        model,
        {
          // @ts-expect-error - improve types
          initialPopulate: initialPopulate?.[attributeName],
          countMany,
          countOne,
          maxLevel
        },
        level
      )
    );
  }, {});
};
const getDeepPopulateDraftCount = (uid2) => {
  const model = strapi.getModel(uid2);
  let hasRelations = false;
  const populate = Object.keys(model.attributes).reduce((populateAcc, attributeName) => {
    const attribute = model.attributes[attributeName];
    switch (attribute.type) {
      case "relation": {
        const isMorphRelation = attribute.relation.toLowerCase().startsWith("morph");
        if (isMorphRelation) {
          break;
        }
        if (isVisibleAttribute$1(model, attributeName)) {
          populateAcc[attributeName] = {
            count: true,
            filters: { [PUBLISHED_AT_ATTRIBUTE$1]: { $null: true } }
          };
          hasRelations = true;
        }
        break;
      }
      case "component": {
        const { populate: populate2, hasRelations: childHasRelations } = getDeepPopulateDraftCount(
          attribute.component
        );
        if (childHasRelations) {
          populateAcc[attributeName] = {
            populate: populate2
          };
          hasRelations = true;
        }
        break;
      }
      case "dynamiczone": {
        const dzPopulateFragment = attribute.components?.reduce((acc, componentUID) => {
          const { populate: componentPopulate, hasRelations: componentHasRelations } = getDeepPopulateDraftCount(componentUID);
          if (componentHasRelations) {
            hasRelations = true;
            return { ...acc, [componentUID]: { populate: componentPopulate } };
          }
          return acc;
        }, {});
        if (!fp.isEmpty(dzPopulateFragment)) {
          populateAcc[attributeName] = { on: dzPopulateFragment };
        }
        break;
      }
    }
    return populateAcc;
  }, {});
  return { populate, hasRelations };
};
const getQueryPopulate = async (uid2, query) => {
  let populateQuery = {};
  await strapiUtils__default.default.traverse.traverseQueryFilters(
    /**
     *
     * @param {Object} param0
     * @param {string} param0.key - Attribute name
     * @param {Object} param0.attribute - Attribute definition
     * @param {string} param0.path - Content Type path to the attribute
     * @returns
     */
    ({ attribute, path }) => {
      if (!attribute || isDynamicZone(attribute) || isMorphToRelation(attribute)) {
        return;
      }
      if (isRelation(attribute) || isMedia(attribute) || isComponent(attribute)) {
        const populatePath = path.attribute.replace(/\./g, ".populate.");
        populateQuery = fp.set(populatePath, {}, populateQuery);
      }
    },
    { schema: strapi.getModel(uid2), getModel: strapi.getModel.bind(strapi) },
    query
  );
  return populateQuery;
};
const buildDeepPopulate = (uid2) => {
  return getService$1("populate-builder")(uid2).populateDeep(Infinity).countRelations().build();
};
const populateBuilder = (uid2) => {
  let getInitialPopulate = async () => {
    return void 0;
  };
  const deepPopulateOptions = {
    countMany: false,
    countOne: false,
    maxLevel: -1
  };
  const builder = {
    /**
     * Populates all attribute fields present in a query.
     * @param query - Strapi query object
     */
    populateFromQuery(query) {
      getInitialPopulate = async () => getQueryPopulate(uid2, query);
      return builder;
    },
    /**
     * Populate relations as count.
     * @param [options]
     * @param [options.toMany] - Populate XtoMany relations as count if true.
     * @param [options.toOne] - Populate XtoOne relations as count if true.
     */
    countRelations({ toMany, toOne } = { toMany: true, toOne: true }) {
      if (!fp.isNil(toMany)) {
        deepPopulateOptions.countMany = toMany;
      }
      if (!fp.isNil(toOne)) {
        deepPopulateOptions.countOne = toOne;
      }
      return builder;
    },
    /**
     * Populate relations deeply, up to a certain level.
     * @param [level=Infinity] - Max level of nested populate.
     */
    populateDeep(level = Infinity) {
      deepPopulateOptions.maxLevel = level;
      return builder;
    },
    /**
     * Construct the populate object based on the builder options.
     * @returns Populate object
     */
    async build() {
      const initialPopulate = await getInitialPopulate();
      if (deepPopulateOptions.maxLevel === -1) {
        return initialPopulate;
      }
      return getDeepPopulate(uid2, { ...deepPopulateOptions, initialPopulate });
    }
  };
  return builder;
};
const populateBuilder$1 = () => populateBuilder;
const uid = ({ strapi: strapi2 }) => ({
  async generateUIDField({
    contentTypeUID,
    field,
    data,
    locale
  }) {
    const contentType = strapi2.contentTypes[contentTypeUID];
    const { attributes } = contentType;
    const {
      targetField,
      default: defaultValue,
      options
    } = attributes[field];
    const targetValue = ___default.default.get(data, targetField);
    if (!___default.default.isEmpty(targetValue)) {
      return this.findUniqueUID({
        contentTypeUID,
        field,
        value: slugify__default.default(targetValue, options),
        locale
      });
    }
    return this.findUniqueUID({
      contentTypeUID,
      field,
      value: slugify__default.default(
        ___default.default.isFunction(defaultValue) ? defaultValue() : defaultValue || contentType.modelName,
        options
      ),
      locale
    });
  },
  async findUniqueUID({
    contentTypeUID,
    field,
    value,
    locale
  }) {
    const foundDocuments = await strapi2.documents(contentTypeUID).findMany({
      filters: {
        [field]: { $startsWith: value }
      },
      locale,
      // TODO: Check UX. When modifying an entry, it only makes sense to check for collisions with other drafts
      // However, when publishing this "available" UID might collide with another published entry
      status: "draft"
    });
    if (!foundDocuments || foundDocuments.length === 0) {
      return value;
    }
    let possibleCollisions;
    if (!Array.isArray(foundDocuments)) {
      possibleCollisions = [foundDocuments[field]];
    } else {
      possibleCollisions = foundDocuments.map((doc) => doc[field]);
    }
    if (!possibleCollisions.includes(value)) {
      return value;
    }
    let i = 1;
    let tmpUId = `${value}-${i}`;
    while (possibleCollisions.includes(tmpUId)) {
      i += 1;
      tmpUId = `${value}-${i}`;
    }
    return tmpUId;
  },
  async checkUIDAvailability({
    contentTypeUID,
    field,
    value,
    locale
  }) {
    const documentCount = await strapi2.documents(contentTypeUID).count({
      filters: {
        [field]: value
      },
      locale,
      // TODO: Check UX. When modifying an entry, it only makes sense to check for collisions with other drafts
      // However, when publishing this "available" UID might collide with another published entry
      status: "draft"
    });
    if (documentCount && documentCount > 0) {
      return false;
    }
    return true;
  }
});
const AVAILABLE_STATUS_FIELDS = [
  "id",
  "locale",
  "updatedAt",
  "createdAt",
  "publishedAt",
  "createdBy",
  "updatedBy",
  "status"
];
const AVAILABLE_LOCALES_FIELDS = [
  "id",
  "locale",
  "updatedAt",
  "createdAt",
  "status",
  "publishedAt",
  "documentId"
];
const CONTENT_MANAGER_STATUS = {
  PUBLISHED: "published",
  DRAFT: "draft",
  MODIFIED: "modified"
};
const getIsVersionLatestModification = (version, otherVersion) => {
  if (!version || !version.updatedAt) {
    return false;
  }
  const versionUpdatedAt = version?.updatedAt ? new Date(version.updatedAt).getTime() : 0;
  const otherUpdatedAt = otherVersion?.updatedAt ? new Date(otherVersion.updatedAt).getTime() : 0;
  return versionUpdatedAt > otherUpdatedAt;
};
const documentMetadata = ({ strapi: strapi2 }) => ({
  /**
   * Returns available locales of a document for the current status
   */
  async getAvailableLocales(uid2, version, allVersions, validatableFields = []) {
    const versionsByLocale = fp.groupBy("locale", allVersions);
    delete versionsByLocale[version.locale];
    const model = strapi2.getModel(uid2);
    const keysToKeep = [...AVAILABLE_LOCALES_FIELDS, ...validatableFields];
    const traversalFunction = async (localeVersion) => strapiUtils.traverseEntity(
      ({ key }, { remove }) => {
        if (keysToKeep.includes(key)) {
          return;
        }
        remove(key);
      },
      { schema: model, getModel: strapi2.getModel.bind(strapi2) },
      // @ts-expect-error fix types DocumentVersion incompatible with Data
      localeVersion
    );
    const mappingResult = await strapiUtils.async.map(
      Object.values(versionsByLocale),
      async (localeVersions) => {
        const mappedLocaleVersions = await strapiUtils.async.map(
          localeVersions,
          traversalFunction
        );
        if (!strapiUtils.contentTypes.hasDraftAndPublish(model)) {
          return mappedLocaleVersions[0];
        }
        const draftVersion = mappedLocaleVersions.find((v) => v.publishedAt === null);
        const otherVersions = mappedLocaleVersions.filter((v) => v.id !== draftVersion?.id);
        if (!draftVersion) {
          return;
        }
        return {
          ...draftVersion,
          status: this.getStatus(draftVersion, otherVersions)
        };
      }
    );
    return mappingResult.filter(Boolean);
  },
  /**
   * Returns available status of a document for the current locale
   */
  getAvailableStatus(version, allVersions) {
    const status = version.publishedAt !== null ? CONTENT_MANAGER_STATUS.DRAFT : CONTENT_MANAGER_STATUS.PUBLISHED;
    const availableStatus = allVersions.find((v) => {
      const matchLocale = v.locale === version.locale;
      const matchStatus = status === "published" ? v.publishedAt !== null : v.publishedAt === null;
      return matchLocale && matchStatus;
    });
    if (!availableStatus)
      return availableStatus;
    return fp.pick(AVAILABLE_STATUS_FIELDS, availableStatus);
  },
  /**
   * Get the available status of many documents, useful for batch operations
   * @param uid
   * @param documents
   * @returns
   */
  async getManyAvailableStatus(uid2, documents) {
    if (!documents.length)
      return [];
    const status = documents[0].publishedAt !== null ? "published" : "draft";
    const locale = documents[0]?.locale;
    const otherStatus = status === "published" ? "draft" : "published";
    return strapi2.documents(uid2).findMany({
      filters: {
        documentId: { $in: documents.map((d) => d.documentId).filter(Boolean) }
      },
      status: otherStatus,
      locale,
      fields: ["documentId", "locale", "updatedAt", "createdAt", "publishedAt"]
    });
  },
  getStatus(version, otherDocumentStatuses) {
    let draftVersion;
    let publishedVersion;
    if (version.publishedAt) {
      publishedVersion = version;
    } else {
      draftVersion = version;
    }
    const otherVersion = otherDocumentStatuses?.at(0);
    if (otherVersion?.publishedAt) {
      publishedVersion = otherVersion;
    } else if (otherVersion) {
      draftVersion = otherVersion;
    }
    if (!draftVersion)
      return CONTENT_MANAGER_STATUS.PUBLISHED;
    if (!publishedVersion)
      return CONTENT_MANAGER_STATUS.DRAFT;
    const isDraftModified = getIsVersionLatestModification(draftVersion, publishedVersion);
    return isDraftModified ? CONTENT_MANAGER_STATUS.MODIFIED : CONTENT_MANAGER_STATUS.PUBLISHED;
  },
  // TODO is it necessary to return metadata on every page of the CM
  // We could refactor this so the locales are only loaded when they're
  // needed. e.g. in the bulk locale action modal.
  async getMetadata(uid2, version, { availableLocales = true, availableStatus = true } = {}) {
    const populate = getValidatableFieldsPopulate(uid2);
    const versions = await strapi2.db.query(uid2).findMany({
      where: { documentId: version.documentId },
      populate: {
        // Populate only fields that require validation for bulk locale actions
        ...populate,
        // NOTE: creator fields are selected in this way to avoid exposing sensitive data
        createdBy: {
          select: ["id", "firstname", "lastname", "email"]
        },
        updatedBy: {
          select: ["id", "firstname", "lastname", "email"]
        }
      }
    });
    const availableLocalesResult = availableLocales ? await this.getAvailableLocales(uid2, version, versions, Object.keys(populate)) : [];
    const availableStatusResult = availableStatus ? this.getAvailableStatus(version, versions) : null;
    return {
      availableLocales: availableLocalesResult,
      availableStatus: availableStatusResult ? [availableStatusResult] : []
    };
  },
  /**
   * Returns associated metadata of a document:
   * - Available locales of the document for the current status
   * - Available status of the document for the current locale
   */
  async formatDocumentWithMetadata(uid2, document, opts = {}) {
    if (!document) {
      return {
        data: document,
        meta: {
          availableLocales: [],
          availableStatus: []
        }
      };
    }
    const hasDraftAndPublish = strapiUtils.contentTypes.hasDraftAndPublish(strapi2.getModel(uid2));
    if (!hasDraftAndPublish) {
      opts.availableStatus = false;
    }
    const meta = await this.getMetadata(uid2, document, opts);
    return {
      data: {
        ...document,
        // Add status to the document only if draft and publish is enabled
        status: hasDraftAndPublish ? this.getStatus(document, meta.availableStatus) : void 0
      },
      meta
    };
  }
});
const { isVisibleAttribute } = strapiUtils__default.default.contentTypes;
const sumDraftCounts = (entity, uid2) => {
  const model = strapi.getModel(uid2);
  return Object.keys(model.attributes).reduce((sum, attributeName) => {
    const attribute = model.attributes[attributeName];
    const value = entity[attributeName];
    if (!value) {
      return sum;
    }
    switch (attribute.type) {
      case "relation": {
        if (isVisibleAttribute(model, attributeName)) {
          return sum + value.count;
        }
        return sum;
      }
      case "component": {
        const compoSum = fp.castArray(value).reduce((acc, componentValue) => {
          return acc + sumDraftCounts(componentValue, attribute.component);
        }, 0);
        return sum + compoSum;
      }
      case "dynamiczone": {
        const dzSum = value.reduce((acc, componentValue) => {
          return acc + sumDraftCounts(componentValue, componentValue.__component);
        }, 0);
        return sum + dzSum;
      }
      default:
        return sum;
    }
  }, 0);
};
const { ApplicationError } = strapiUtils.errors;
const { PUBLISHED_AT_ATTRIBUTE } = strapiUtils.contentTypes.constants;
const omitPublishedAtField = fp.omit(PUBLISHED_AT_ATTRIBUTE);
const omitIdField = fp.omit("id");
const documentManager = ({ strapi: strapi2 }) => {
  return {
    async findOne(id, uid2, opts = {}) {
      return strapi2.documents(uid2).findOne({ ...opts, documentId: id });
    },
    /**
     * Find multiple (or all) locales for a document
     */
    async findLocales(id, uid2, opts) {
      const where = {};
      if (id) {
        where.documentId = id;
      }
      if (Array.isArray(opts.locale)) {
        where.locale = { $in: opts.locale };
      } else if (opts.locale && opts.locale !== "*") {
        where.locale = opts.locale;
      }
      if (typeof opts.isPublished === "boolean") {
        where.publishedAt = { $notNull: opts.isPublished };
      }
      return strapi2.db.query(uid2).findMany({ populate: opts.populate, where });
    },
    async findMany(opts, uid2) {
      const params = { ...opts, populate: getDeepPopulate(uid2) };
      return strapi2.documents(uid2).findMany(params);
    },
    async findPage(opts, uid2) {
      const params = strapiUtils.pagination.withDefaultPagination(opts || {}, {
        maxLimit: 1e3
      });
      const [documents, total = 0] = await Promise.all([
        strapi2.documents(uid2).findMany(params),
        strapi2.documents(uid2).count(params)
      ]);
      return {
        results: documents,
        pagination: strapiUtils.pagination.transformPagedPaginationInfo(params, total)
      };
    },
    async create(uid2, opts = {}) {
      const populate = opts.populate ?? await buildDeepPopulate(uid2);
      const params = { ...opts, status: "draft", populate };
      return strapi2.documents(uid2).create(params);
    },
    async update(id, uid2, opts = {}) {
      const publishData = fp.pipe(omitPublishedAtField, omitIdField)(opts.data || {});
      const populate = opts.populate ?? await buildDeepPopulate(uid2);
      const params = { ...opts, data: publishData, populate, status: "draft" };
      return strapi2.documents(uid2).update({ ...params, documentId: id });
    },
    async clone(id, body, uid2) {
      const populate = await buildDeepPopulate(uid2);
      const params = {
        data: omitIdField(body),
        populate
      };
      return strapi2.documents(uid2).clone({ ...params, documentId: id }).then((result) => result?.entries.at(0));
    },
    /**
     *  Check if a document exists
     */
    async exists(uid2, id) {
      if (id) {
        const count2 = await strapi2.db.query(uid2).count({ where: { documentId: id } });
        return count2 > 0;
      }
      const count = await strapi2.db.query(uid2).count();
      return count > 0;
    },
    async delete(id, uid2, opts = {}) {
      const populate = await buildDeepPopulate(uid2);
      await strapi2.documents(uid2).delete({
        ...opts,
        documentId: id,
        populate
      });
      return {};
    },
    // FIXME: handle relations
    async deleteMany(documentIds, uid2, opts = {}) {
      const deletedEntries = await strapi2.db.transaction(async () => {
        return Promise.all(documentIds.map(async (id) => this.delete(id, uid2, opts)));
      });
      return { count: deletedEntries.length };
    },
    async publish(id, uid2, opts = {}) {
      const populate = await buildDeepPopulate(uid2);
      const params = { ...opts, populate };
      return strapi2.documents(uid2).publish({ ...params, documentId: id }).then((result) => result?.entries);
    },
    async publishMany(uid2, documentIds, locale) {
      return strapi2.db.transaction(async () => {
        const results = await Promise.all(
          documentIds.map((documentId) => this.publish(documentId, uid2, { locale }))
        );
        const publishedEntitiesCount = results.flat().filter(Boolean).length;
        return publishedEntitiesCount;
      });
    },
    async unpublishMany(documentIds, uid2, opts = {}) {
      const unpublishedEntries = await strapi2.db.transaction(async () => {
        return Promise.all(
          documentIds.map(
            (id) => strapi2.documents(uid2).unpublish({ ...opts, documentId: id }).then((result) => result?.entries)
          )
        );
      });
      const unpublishedEntitiesCount = unpublishedEntries.flat().filter(Boolean).length;
      return { count: unpublishedEntitiesCount };
    },
    async unpublish(id, uid2, opts = {}) {
      const populate = await buildDeepPopulate(uid2);
      const params = { ...opts, populate };
      return strapi2.documents(uid2).unpublish({ ...params, documentId: id }).then((result) => result?.entries.at(0));
    },
    async discardDraft(id, uid2, opts = {}) {
      const populate = await buildDeepPopulate(uid2);
      const params = { ...opts, populate };
      return strapi2.documents(uid2).discardDraft({ ...params, documentId: id }).then((result) => result?.entries.at(0));
    },
    async countDraftRelations(id, uid2, locale) {
      const { populate, hasRelations } = getDeepPopulateDraftCount(uid2);
      if (!hasRelations) {
        return 0;
      }
      const document = await strapi2.documents(uid2).findOne({ documentId: id, populate, locale });
      if (!document) {
        throw new ApplicationError(
          `Unable to count draft relations, document with id ${id} and locale ${locale} not found`
        );
      }
      return sumDraftCounts(document, uid2);
    },
    async countManyEntriesDraftRelations(documentIds, uid2, locale) {
      const { populate, hasRelations } = getDeepPopulateDraftCount(uid2);
      if (!hasRelations) {
        return 0;
      }
      let localeFilter = {};
      if (locale) {
        localeFilter = Array.isArray(locale) ? { locale: { $in: locale } } : { locale };
      }
      const entities = await strapi2.db.query(uid2).findMany({
        populate,
        where: {
          documentId: { $in: documentIds },
          ...localeFilter
        }
      });
      const totalNumberDraftRelations = entities.reduce(
        (count, entity) => sumDraftCounts(entity, uid2) + count,
        0
      );
      return totalNumberDraftRelations;
    }
  };
};
const services = {
  components,
  "content-types": service,
  "data-mapper": dataMapper,
  "document-metadata": documentMetadata,
  "document-manager": documentManager,
  "field-sizes": createFieldSizesService,
  metrics,
  "permission-checker": permissionChecker,
  permission,
  "populate-builder": populateBuilder$1,
  uid,
  ...history.services ? history.services : {}
};
const index = () => {
  return {
    register,
    bootstrap,
    destroy,
    controllers,
    routes,
    policies,
    services
  };
};
module.exports = index;
//# sourceMappingURL=index.js.map
