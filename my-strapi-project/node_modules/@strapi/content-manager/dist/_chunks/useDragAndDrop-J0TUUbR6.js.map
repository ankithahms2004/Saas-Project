{"version":3,"file":"useDragAndDrop-J0TUUbR6.js","sources":["../../admin/src/constants/dragAndDrop.ts","../../admin/src/hooks/useKeyboardDragAndDrop.ts","../../admin/src/hooks/useDragAndDrop.ts"],"sourcesContent":["export const ItemTypes = {\n  COMPONENT: 'component',\n  EDIT_FIELD: 'editField',\n  FIELD: 'field',\n  DYNAMIC_ZONE: 'dynamicZone',\n  RELATION: 'relation',\n  BLOCKS: 'blocks',\n} as const;\n","import * as React from 'react';\n\nexport type UseKeyboardDragAndDropCallbacks<TIndex extends number | Array<number> = number> = {\n  onCancel?: (index: TIndex) => void;\n  onDropItem?: (currentIndex: TIndex, newIndex?: TIndex) => void;\n  onGrabItem?: (index: TIndex) => void;\n  onMoveItem?: (newIndex: TIndex, currentIndex: TIndex) => void;\n};\n\n/**\n * Utility hook designed to implement keyboard accessibile drag and drop by\n * returning an onKeyDown handler to be passed to the drag icon button.\n *\n * @internal - You should use `useDragAndDrop` instead.\n */\nexport const useKeyboardDragAndDrop = <TIndex extends number | Array<number> = number>(\n  active: boolean,\n  index: TIndex,\n  { onCancel, onDropItem, onGrabItem, onMoveItem }: UseKeyboardDragAndDropCallbacks<TIndex>\n) => {\n  const [isSelected, setIsSelected] = React.useState(false);\n\n  const handleMove = (movement: 'UP' | 'DOWN') => {\n    if (!isSelected) {\n      return;\n    }\n    if (typeof index === 'number' && onMoveItem) {\n      if (movement === 'UP') {\n        onMoveItem((index - 1) as TIndex, index);\n      } else if (movement === 'DOWN') {\n        onMoveItem((index + 1) as TIndex, index);\n      }\n    }\n  };\n\n  const handleDragClick = () => {\n    if (isSelected) {\n      if (onDropItem) {\n        onDropItem(index);\n      }\n      setIsSelected(false);\n    } else {\n      if (onGrabItem) {\n        onGrabItem(index);\n      }\n      setIsSelected(true);\n    }\n  };\n\n  const handleCancel = () => {\n    if (isSelected) {\n      setIsSelected(false);\n\n      if (onCancel) {\n        onCancel(index);\n      }\n    }\n  };\n\n  const handleKeyDown = <E extends Element>(e: React.KeyboardEvent<E>) => {\n    if (!active) {\n      return;\n    }\n\n    if (e.key === 'Tab' && !isSelected) {\n      return;\n    }\n\n    e.preventDefault();\n\n    switch (e.key) {\n      case ' ':\n      case 'Enter':\n        handleDragClick();\n        break;\n\n      case 'Escape':\n        handleCancel();\n        break;\n\n      case 'ArrowDown':\n      case 'ArrowRight':\n        handleMove('DOWN');\n        break;\n\n      case 'ArrowUp':\n      case 'ArrowLeft':\n        handleMove('UP');\n        break;\n\n      default:\n    }\n  };\n\n  return handleKeyDown;\n};\n","import * as React from 'react';\n\nimport {\n  useDrag,\n  useDrop,\n  type HandlerManager,\n  type ConnectDragSource,\n  type ConnectDropTarget,\n  type ConnectDragPreview,\n  type DragSourceMonitor,\n} from 'react-dnd';\n\nimport {\n  useKeyboardDragAndDrop,\n  type UseKeyboardDragAndDropCallbacks,\n} from './useKeyboardDragAndDrop';\n\nimport type { Data } from '@strapi/types';\n\nconst DIRECTIONS = {\n  UPWARD: 'upward',\n  DOWNWARD: 'downward',\n} as const;\n\nconst DROP_SENSITIVITY = {\n  REGULAR: 'regular',\n  IMMEDIATE: 'immediate',\n} as const;\n\ninterface UseDragAndDropOptions<\n  TIndex extends number | Array<number> = number,\n  TItem extends { index: TIndex } = { index: TIndex },\n> extends UseKeyboardDragAndDropCallbacks<TIndex> {\n  type?: string;\n  index: TIndex;\n  item?: TItem;\n  onStart?: () => void;\n  onEnd?: () => void;\n  dropSensitivity?: (typeof DROP_SENSITIVITY)[keyof typeof DROP_SENSITIVITY];\n}\n\ntype Identifier = ReturnType<HandlerManager['getHandlerId']>;\n\ntype UseDragAndDropReturn<E extends Element = HTMLElement> = [\n  props: {\n    handlerId: Identifier;\n    isDragging: boolean;\n    handleKeyDown: <E extends Element>(event: React.KeyboardEvent<E>) => void;\n    isOverDropTarget: boolean;\n    direction: (typeof DIRECTIONS)[keyof typeof DIRECTIONS] | null;\n  },\n  objectRef: React.RefObject<E>,\n  dropRef: ConnectDropTarget,\n  dragRef: ConnectDragSource,\n  dragPreviewRef: ConnectDragPreview,\n];\n\ntype DropCollectedProps = {\n  handlerId: Identifier;\n  isOver: boolean;\n};\n\n/**\n * A utility hook abstracting the general drag and drop hooks from react-dnd.\n * Centralising the same behaviours and by default offering keyboard support.\n */\nconst useDragAndDrop = <\n  TIndex extends number | Array<number>,\n  TItem extends { index: TIndex; id?: Data.ID; [key: string]: unknown } = {\n    index: TIndex;\n    [key: string]: unknown;\n  },\n  E extends Element = HTMLElement,\n>(\n  active: boolean,\n  {\n    type = 'STRAPI_DND',\n    index,\n    item,\n    onStart,\n    onEnd,\n    onGrabItem,\n    onDropItem,\n    onCancel,\n    onMoveItem,\n    dropSensitivity = DROP_SENSITIVITY.REGULAR,\n  }: UseDragAndDropOptions<TIndex, TItem>\n): UseDragAndDropReturn<E> => {\n  const objectRef = React.useRef<E>(null);\n\n  const [{ handlerId, isOver }, dropRef] = useDrop<TItem, void, DropCollectedProps>({\n    accept: type,\n    collect(monitor) {\n      return {\n        handlerId: monitor.getHandlerId(),\n        isOver: monitor.isOver({ shallow: true }),\n      };\n    },\n    drop(item) {\n      const draggedIndex = item.index;\n      const newIndex = index;\n\n      if (isOver && onDropItem) {\n        onDropItem(draggedIndex, newIndex);\n      }\n    },\n    hover(item, monitor) {\n      if (!objectRef.current || !onMoveItem) {\n        return;\n      }\n\n      const dragIndex = item.index;\n      const newIndex = index;\n\n      const hoverBoundingRect = objectRef.current?.getBoundingClientRect();\n      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n      const clientOffset = monitor.getClientOffset();\n      if (!clientOffset) return;\n\n      const hoverClientY = clientOffset && clientOffset.y - hoverBoundingRect.top;\n      if (typeof dragIndex === 'number' && typeof newIndex === 'number') {\n        if (dragIndex === newIndex) {\n          // Don't replace items with themselves\n          return;\n        }\n\n        if (dropSensitivity === DROP_SENSITIVITY.REGULAR) {\n          // Dragging downwards\n          if (dragIndex < newIndex && hoverClientY < hoverMiddleY) {\n            return;\n          }\n\n          // Dragging upwards\n          if (dragIndex > newIndex && hoverClientY > hoverMiddleY) {\n            return;\n          }\n        }\n\n        // Time to actually perform the action\n        onMoveItem(newIndex, dragIndex);\n        item.index = newIndex;\n      } else {\n        // Using numbers as indices doesn't work for nested list items with path like [1, 1, 0]\n        if (Array.isArray(dragIndex) && Array.isArray(newIndex)) {\n          // Indices comparison to find item position in nested list\n          const minLength = Math.min(dragIndex.length, newIndex.length);\n          let areEqual = true;\n          let isLessThan = false;\n          let isGreaterThan = false;\n\n          for (let i = 0; i < minLength; i++) {\n            if (dragIndex[i] < newIndex[i]) {\n              isLessThan = true;\n              areEqual = false;\n              break;\n            } else if (dragIndex[i] > newIndex[i]) {\n              isGreaterThan = true;\n              areEqual = false;\n              break;\n            }\n          }\n\n          // Don't replace items with themselves\n          if (areEqual && dragIndex.length === newIndex.length) {\n            return;\n          }\n\n          if (dropSensitivity === DROP_SENSITIVITY.REGULAR) {\n            // Dragging downwards\n            if (isLessThan && !isGreaterThan && hoverClientY < hoverMiddleY) {\n              return;\n            }\n\n            // Dragging upwards\n            if (isGreaterThan && !isLessThan && hoverClientY > hoverMiddleY) {\n              return;\n            }\n          }\n        }\n\n        onMoveItem(newIndex, dragIndex);\n        item.index = newIndex;\n      }\n    },\n  });\n\n  const getDragDirection = (monitor: DragSourceMonitor<TItem, void>) => {\n    if (\n      monitor &&\n      monitor.isDragging() &&\n      !monitor.didDrop() &&\n      monitor.getInitialClientOffset() &&\n      monitor.getClientOffset()\n    ) {\n      const deltaY = monitor.getInitialClientOffset()!.y - monitor.getClientOffset()!.y;\n\n      if (deltaY > 0) return DIRECTIONS.UPWARD;\n\n      if (deltaY < 0) return DIRECTIONS.DOWNWARD;\n\n      return null;\n    }\n\n    return null;\n  };\n\n  const [{ isDragging, direction }, dragRef, dragPreviewRef] = useDrag({\n    type,\n    item() {\n      if (onStart) {\n        onStart();\n      }\n\n      /**\n       * This will be attached and it helps define the preview sizes\n       * when a component is flexy e.g. Relations\n       */\n      const { width } = objectRef.current?.getBoundingClientRect() ?? {};\n\n      return { index, width, ...item };\n    },\n    end() {\n      if (onEnd) {\n        onEnd();\n      }\n    },\n    canDrag: active,\n    /**\n     * This is useful when the item is in a virtualized list.\n     * However, if we don't have an ID then we want the libraries\n     * defaults to take care of this.\n     */\n    isDragging: item?.id\n      ? (monitor) => {\n          return item.id === monitor.getItem().id;\n        }\n      : undefined,\n    collect: (monitor) => ({\n      isDragging: monitor.isDragging(),\n      initialOffset: monitor.getInitialClientOffset(),\n      currentOffset: monitor.getClientOffset(),\n      direction: getDragDirection(monitor),\n    }),\n  });\n\n  const handleKeyDown = useKeyboardDragAndDrop(active, index, {\n    onGrabItem,\n    onDropItem,\n    onCancel,\n    onMoveItem,\n  });\n\n  return [\n    { handlerId, isDragging, handleKeyDown, isOverDropTarget: isOver, direction },\n    objectRef,\n    dropRef,\n    dragRef,\n    dragPreviewRef,\n  ];\n};\n\nexport {\n  useDragAndDrop,\n  UseDragAndDropReturn,\n  UseDragAndDropOptions,\n  DIRECTIONS,\n  DROP_SENSITIVITY,\n};\n"],"names":["React","useDrop","item","useDrag"],"mappings":"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"}