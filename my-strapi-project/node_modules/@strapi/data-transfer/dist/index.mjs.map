{"version":3,"file":"index.mjs","sources":["../src/utils/encryption/encrypt.ts","../src/utils/encryption/decrypt.ts","../src/utils/stream.ts","../src/utils/json.ts","../src/utils/schema.ts","../src/utils/transaction.ts","../src/utils/middleware.ts","../src/engine/validation/schemas/index.ts","../src/errors/constants.ts","../src/errors/base.ts","../src/engine/errors.ts","../src/engine/validation/provider.ts","../src/engine/diagnostic.ts","../src/errors/providers.ts","../src/engine/index.ts","../src/utils/components.ts","../src/strapi/queries/entity.ts","../src/strapi/queries/link.ts","../src/strapi/providers/local-destination/strategies/restore/entities.ts","../src/strapi/providers/local-destination/strategies/restore/configuration.ts","../src/strapi/providers/local-destination/strategies/restore/links.ts","../src/strapi/providers/local-destination/strategies/restore/index.ts","../src/utils/providers.ts","../src/strapi/providers/local-destination/index.ts","../src/strapi/providers/local-source/entities.ts","../src/strapi/providers/local-source/links.ts","../src/strapi/providers/local-source/configuration.ts","../src/strapi/providers/local-source/assets.ts","../src/strapi/providers/local-source/index.ts","../src/strapi/providers/utils.ts","../src/strapi/remote/constants.ts","../src/strapi/providers/remote-destination/index.ts","../src/strapi/providers/remote-source/index.ts","../src/strapi/remote/flows/default.ts","../src/strapi/remote/flows/index.ts","../src/strapi/remote/handlers/constants.ts","../src/strapi/remote/handlers/utils.ts","../src/strapi/remote/handlers/push.ts","../src/strapi/remote/handlers/pull.ts","../src/file/providers/source/utils.ts","../src/file/providers/source/index.ts","../src/file/providers/destination/utils.ts","../src/file/providers/destination/index.ts"],"sourcesContent":["import { createCipheriv, Cipher, scryptSync, CipherKey, BinaryLike } from 'crypto';\nimport { EncryptionStrategy, Strategies, Algorithm } from '../../../types';\n\n// different key values depending on algorithm chosen\nconst getEncryptionStrategy = (algorithm: Algorithm): EncryptionStrategy => {\n  const strategies: Strategies = {\n    'aes-128-ecb'(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 16);\n      const initVector: BinaryLike | null = null;\n      const securityKey: CipherKey = hashedKey;\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes128(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 32);\n      const initVector: BinaryLike | null = hashedKey.slice(16);\n      const securityKey: CipherKey = hashedKey.slice(0, 16);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes192(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 40);\n      const initVector: BinaryLike | null = hashedKey.slice(24);\n      const securityKey: CipherKey = hashedKey.slice(0, 24);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes256(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 48);\n      const initVector: BinaryLike | null = hashedKey.slice(32);\n      const securityKey: CipherKey = hashedKey.slice(0, 32);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n  };\n\n  return strategies[algorithm];\n};\n\n/**\n * It creates a cipher instance used for encryption\n *\n * @param key - The encryption key\n * @param algorithm - The algorithm to use to create the Cipher\n *\n * @returns A {@link Cipher} instance created with the given key & algorithm\n */\nexport const createEncryptionCipher = (\n  key: string,\n  algorithm: Algorithm = 'aes-128-ecb'\n): Cipher => {\n  return getEncryptionStrategy(algorithm)(key);\n};\n","import { Cipher, scryptSync, CipherKey, BinaryLike, createDecipheriv } from 'crypto';\nimport { EncryptionStrategy, Strategies, Algorithm } from '../../../types';\n\n// different key values depending on algorithm chosen\nconst getDecryptionStrategy = (algorithm: Algorithm): EncryptionStrategy => {\n  const strategies: Strategies = {\n    'aes-128-ecb'(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 16);\n      const initVector: BinaryLike | null = null;\n      const securityKey: CipherKey = hashedKey;\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes128(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 32);\n      const initVector: BinaryLike | null = hashedKey.slice(16);\n      const securityKey: CipherKey = hashedKey.slice(0, 16);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes192(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 40);\n      const initVector: BinaryLike | null = hashedKey.slice(24);\n      const securityKey: CipherKey = hashedKey.slice(0, 24);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes256(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 48);\n      const initVector: BinaryLike | null = hashedKey.slice(32);\n      const securityKey: CipherKey = hashedKey.slice(0, 32);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n  };\n\n  return strategies[algorithm];\n};\n\n/**\n * It creates a cipher instance used for decryption\n *\n * @param key - The decryption key\n * @param algorithm - The algorithm to use to create the Cipher\n *\n * @returns A {@link Cipher} instance created with the given key & algorithm\n */\nexport const createDecryptionCipher = (\n  key: string,\n  algorithm: Algorithm = 'aes-128-ecb'\n): Cipher => {\n  return getDecryptionStrategy(algorithm)(key);\n};\n","import { Transform, Readable } from 'stream';\n\ntype TransformOptions = ConstructorParameters<typeof Transform>[0];\n\n/**\n * Create a filter stream that discard chunks which doesn't satisfies the given predicate\n *\n * @param predicate - A filter predicate, takes a stream data chunk as parameter and returns a boolean value\n * @param options - Transform stream options\n */\nexport const filter = <T>(\n  predicate: (value: T) => boolean | Promise<boolean>,\n  options: TransformOptions = { objectMode: true }\n): Transform => {\n  return new Transform({\n    ...options,\n\n    async transform(chunk, _encoding, callback) {\n      const keep = await predicate(chunk);\n\n      callback(null, keep ? chunk : undefined);\n    },\n  });\n};\n\n/**\n * Create a map stream that transform chunks using the given predicate\n *\n * @param predicate - A map predicate, takes a stream data chunk as parameter and returns a mapped value\n * @param options - Transform stream options\n */\nexport const map = <T, U = T>(\n  predicate: (value: T) => U | Promise<U>,\n  options: TransformOptions = { objectMode: true }\n): Transform => {\n  return new Transform({\n    ...options,\n\n    async transform(chunk, _encoding, callback) {\n      const mappedValue = await predicate(chunk);\n\n      callback(null, mappedValue);\n    },\n  });\n};\n\n/**\n * Collect every chunks from a Readable stream.\n *\n * @param stream - The redable stream to collect data from\n * @param options.destroy - If set to true, it automatically calls `destroy()` on the given stream upon receiving the 'end' event\n */\nexport const collect = <T = unknown>(\n  stream: Readable,\n  options: { destroy: boolean } = { destroy: true }\n): Promise<T[]> => {\n  const chunks: T[] = [];\n\n  return new Promise((resolve, reject) => {\n    stream\n      .on('close', () => resolve(chunks))\n      .on('error', reject)\n      .on('data', (chunk) => chunks.push(chunk))\n      .on('end', () => {\n        if (options.destroy) {\n          stream.destroy();\n        }\n\n        resolve(chunks);\n      });\n  });\n};\n","import { isArray, isObject, zip, isEqual, uniq } from 'lodash/fp';\n\nconst createContext = (): Context => ({ path: [] });\n\n/**\n * Compute differences between two JSON objects and returns them\n *\n * @param a - First object\n * @param b - Second object\n * @param ctx - Context used to keep track of the current path during recursion\n */\nexport const diff = (a: unknown, b: unknown, ctx: Context = createContext()): Diff[] => {\n  const diffs: Diff[] = [];\n  const { path } = ctx;\n\n  const aType = typeof a;\n  const bType = typeof b;\n\n  // Define helpers\n\n  const added = () => {\n    diffs.push({ kind: 'added', path, type: bType, value: b });\n    return diffs;\n  };\n\n  const deleted = () => {\n    diffs.push({ kind: 'deleted', path, type: aType, value: a });\n    return diffs;\n  };\n\n  const modified = () => {\n    diffs.push({\n      kind: 'modified',\n      path,\n      types: [aType, bType],\n      values: [a, b],\n    });\n    return diffs;\n  };\n\n  if (isArray(a) && isArray(b)) {\n    let k = 0;\n\n    for (const [aItem, bItem] of zip(a, b)) {\n      const kCtx: Context = { path: [...path, k.toString()] };\n      const kDiffs = diff(aItem, bItem, kCtx);\n\n      diffs.push(...kDiffs);\n\n      k += 1;\n    }\n\n    return diffs;\n  }\n\n  if (isObject(a) && isObject(b)) {\n    const keys = uniq(Object.keys(a).concat(Object.keys(b)));\n\n    for (const key of keys) {\n      const aValue = (a as Record<string, unknown>)[key];\n      const bValue = (b as Record<string, unknown>)[key];\n\n      const nestedDiffs = diff(aValue, bValue, { path: [...path, key] });\n\n      diffs.push(...nestedDiffs);\n    }\n\n    return diffs;\n  }\n\n  if (!isEqual(a, b)) {\n    if (aType === 'undefined') {\n      return added();\n    }\n\n    if (bType === 'undefined') {\n      return deleted();\n    }\n\n    return modified();\n  }\n\n  return diffs;\n};\n\nexport interface AddedDiff<T = unknown> {\n  kind: 'added';\n  path: string[];\n  type: string;\n  value: T;\n}\n\nexport interface ModifiedDiff<T = unknown, P = unknown> {\n  kind: 'modified';\n  path: string[];\n  types: [string, string];\n  values: [T, P];\n}\n\nexport interface DeletedDiff<T = unknown> {\n  kind: 'deleted';\n  path: string[];\n  type: string;\n  value: T;\n}\n\nexport type Diff<T = unknown> = AddedDiff<T> | ModifiedDiff<T> | DeletedDiff<T>;\n\nexport interface Context {\n  path: string[];\n}\n","import type { Struct, Utils } from '@strapi/types';\nimport { mapValues, pick } from 'lodash/fp';\n\n/**\n * List of schema properties that should be kept when sanitizing schemas\n */\nconst VALID_SCHEMA_PROPERTIES = [\n  'collectionName',\n  'info',\n  'options',\n  'pluginOptions',\n  'attributes',\n  'kind',\n  'modelType',\n  'modelName',\n  'uid',\n  'plugin',\n  'globalId',\n];\n\n/**\n * Sanitize a schemas dictionary by omitting unwanted properties\n * The list of allowed properties can be found here: {@link VALID_SCHEMA_PROPERTIES}\n */\nexport const mapSchemasValues = (schemas: Utils.String.Dict<Struct.Schema>) => {\n  return mapValues(pick(VALID_SCHEMA_PROPERTIES), schemas) as Utils.String.Dict<Struct.Schema>;\n};\n\nexport const schemasToValidJSON = (schemas: Utils.String.Dict<Struct.Schema>) => {\n  return JSON.parse(JSON.stringify(schemas));\n};\n","import { EventEmitter } from 'events';\nimport { randomUUID } from 'crypto';\nimport type { Core } from '@strapi/types';\n\nimport { Transaction, TransactionCallback } from '../../types/utils';\n\nexport const createTransaction = (strapi: Core.Strapi): Transaction => {\n  const fns: { fn: TransactionCallback; uuid: string }[] = [];\n\n  let done = false;\n  let resume: null | (() => void) = null;\n\n  const e = new EventEmitter();\n  e.on('spawn', (uuid, cb) => {\n    fns.push({ fn: cb, uuid });\n    resume?.();\n  });\n\n  e.on('close', () => {\n    e.removeAllListeners('rollback');\n    e.removeAllListeners('spawn');\n\n    done = true;\n    resume?.();\n  });\n\n  strapi.db.transaction(async ({ trx, rollback }) => {\n    e.once('rollback', async () => {\n      e.removeAllListeners('close');\n      e.removeAllListeners('spawn');\n\n      try {\n        await rollback();\n        e.emit('rollback_completed');\n      } catch {\n        e.emit('rollback_failed');\n      } finally {\n        done = true;\n        resume?.();\n      }\n    });\n\n    while (!done) {\n      while (fns.length) {\n        const item = fns.shift();\n\n        if (item) {\n          const { fn, uuid } = item;\n\n          try {\n            const res = await fn(trx);\n            e.emit(uuid, { data: res });\n          } catch (error) {\n            e.emit(uuid, { error });\n          }\n        }\n      }\n      if (!done && !fns.length) {\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\n        await new Promise<void>((resolve) => {\n          resume = resolve;\n        });\n      }\n    }\n  });\n\n  return {\n    async attach<T = undefined>(callback: TransactionCallback): Promise<T | undefined> {\n      const uuid = randomUUID();\n      e.emit('spawn', uuid, callback);\n      return new Promise<T | undefined>((resolve, reject) => {\n        e.on(uuid, ({ data, error }) => {\n          if (data) {\n            resolve(data);\n          }\n\n          if (error) {\n            reject(error);\n          }\n          resolve(undefined);\n        });\n      });\n    },\n\n    end() {\n      return e.emit('close');\n    },\n\n    rollback() {\n      return new Promise<boolean>((resolve) => {\n        e.emit('rollback');\n\n        e.once('rollback_failed', () => resolve(false));\n        e.once('rollback_completed', () => resolve(true));\n      });\n    },\n  };\n};\n","import { Middleware } from '../../types';\n\nexport const runMiddleware = async <T>(context: T, middlewares: Middleware<T>[]): Promise<void> => {\n  if (!middlewares.length) {\n    return;\n  }\n  const cb = middlewares[0];\n  await cb(context, async (newContext: T) => {\n    await runMiddleware(newContext, middlewares.slice(1));\n  });\n};\n","import type { Struct } from '@strapi/types';\nimport { isArray, isObject, reject } from 'lodash/fp';\nimport type { Diff } from '../../../utils/json';\nimport * as utils from '../../../utils';\n\nconst OPTIONAL_CONTENT_TYPES = ['audit-log'] as const;\n\nconst isAttributeIgnorable = (diff: Diff) => {\n  return (\n    diff.path.length === 3 &&\n    // Root property must be attributes\n    diff.path[0] === 'attributes' &&\n    // Need a valid string attribute name\n    typeof diff.path[1] === 'string' &&\n    // The diff must be on ignorable attribute properties\n    ['private', 'required', 'configurable', 'default'].includes(diff.path[2])\n  );\n};\n\n// TODO: clean up the type checking, which will require cleaning up the typings in utils/json.ts\n// exclude admin tables that are not transferable and are optionally available (such as audit logs which are only available in EE)\nconst isOptionalAdminType = (diff: Diff) => {\n  // added/deleted\n  if ('value' in diff && isObject(diff.value)) {\n    const name = (diff?.value as Struct.ContentTypeSchema)?.info?.singularName;\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\n  }\n\n  // modified\n  if ('values' in diff && isArray(diff.values) && isObject(diff.values[0])) {\n    const name = (diff?.values[0] as Struct.ContentTypeSchema)?.info?.singularName;\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\n  }\n\n  return false;\n};\n\nconst isIgnorableStrict = (diff: Diff) => isAttributeIgnorable(diff) || isOptionalAdminType(diff);\n\nconst strategies = {\n  // No diffs\n  exact(diffs: Diff[]) {\n    return diffs;\n  },\n\n  // Strict: all content types must match except:\n  // - the property within a content type is an ignorable one\n  // - those that are (not transferrable and optionally available), for example EE features such as audit logs\n  strict(diffs: Diff[]) {\n    return reject(isIgnorableStrict, diffs);\n  },\n};\n\nconst compareSchemas = <T, P>(a: T, b: P, strategy: keyof typeof strategies) => {\n  const diffs = utils.json.diff(a, b);\n  return strategies[strategy](diffs);\n};\n\nexport { compareSchemas };\n","import { ErrorDiagnosticSeverity } from '../engine/diagnostic';\n\nexport const SeverityKind: Record<string, ErrorDiagnosticSeverity> = {\n  FATAL: 'fatal',\n  ERROR: 'error',\n  SILLY: 'silly',\n} as const;\nexport type Severity = (typeof SeverityKind)[keyof typeof SeverityKind];\n","import { Severity } from './constants';\n\nclass DataTransferError<T = unknown> extends Error {\n  origin: string;\n\n  severity: Severity;\n\n  details: T | null;\n\n  constructor(origin: string, severity: Severity, message?: string, details?: T | null) {\n    super(message);\n\n    this.origin = origin;\n    this.severity = severity;\n    this.details = details ?? null;\n  }\n}\n\nexport { DataTransferError };\n","import { DataTransferError, Severity, SeverityKind } from '../errors';\n\ntype TransferEngineStep = 'initialization' | 'validation' | 'transfer';\n\ntype TransferEngineErrorDetails<P extends TransferEngineStep = TransferEngineStep, U = never> = {\n  step: P;\n} & ([U] extends [never] ? unknown : { details?: U });\n\nclass TransferEngineError<\n  P extends TransferEngineStep = TransferEngineStep,\n  U = never,\n  T extends TransferEngineErrorDetails<P, U> = TransferEngineErrorDetails<P, U>,\n> extends DataTransferError<T> {\n  constructor(severity: Severity, message?: string, details?: T | null) {\n    super('engine', severity, message, details);\n  }\n}\n\nclass TransferEngineInitializationError extends TransferEngineError<'initialization'> {\n  constructor(message?: string) {\n    super(SeverityKind.FATAL, message, { step: 'initialization' });\n  }\n}\n\nclass TransferEngineValidationError<\n  T extends { check: string } = { check: string },\n> extends TransferEngineError<'validation', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'validation', details });\n  }\n}\n\nclass TransferEngineTransferError<\n  T extends { check: string } = { check: string },\n> extends TransferEngineError<'transfer', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'transfer', details });\n  }\n}\n\nexport {\n  TransferEngineError,\n  TransferEngineInitializationError,\n  TransferEngineValidationError,\n  TransferEngineTransferError,\n};\n","import { capitalize } from 'lodash/fp';\n\nimport type { IDestinationProvider, ISourceProvider, ProviderType } from '../../../types';\nimport { TransferEngineValidationError } from '../errors';\n\nconst reject = (reason: string): never => {\n  throw new TransferEngineValidationError(`Invalid provider supplied. ${reason}`);\n};\n\nconst validateProvider = <T extends ProviderType>(\n  type: ProviderType,\n  provider?: ([T] extends ['source'] ? ISourceProvider : IDestinationProvider) | null\n) => {\n  if (!provider) {\n    return reject(\n      `Expected an instance of \"${capitalize(type)}Provider\", but got \"${typeof provider}\" instead.`\n    );\n  }\n\n  if (provider.type !== type) {\n    return reject(\n      `Expected the provider to be of type \"${type}\" but got \"${provider.type}\" instead.`\n    );\n  }\n};\n\nexport { validateProvider };\n","import { EventEmitter } from 'events';\n\nexport interface IDiagnosticReporterOptions {\n  stackSize?: number;\n}\n\nexport type GenericDiagnostic<K extends DiagnosticKind, T = unknown> = {\n  kind: K;\n  details: {\n    message: string;\n    createdAt: Date;\n  } & T;\n};\n\nexport type DiagnosticKind = 'error' | 'warning' | 'info';\n\nexport type DiagnosticListener<T extends DiagnosticKind = DiagnosticKind> = (\n  diagnostic: { kind: T } & Diagnostic extends infer U ? U : never\n) => void | Promise<void>;\n\nexport type DiagnosticEvent = 'diagnostic' | `diagnostic.${DiagnosticKind}`;\n\nexport type GetEventListener<E extends DiagnosticEvent> = E extends 'diagnostic'\n  ? DiagnosticListener\n  : E extends `diagnostic.${infer K}`\n    ? K extends DiagnosticKind\n      ? DiagnosticListener<K>\n      : never\n    : never;\n\nexport type Diagnostic = ErrorDiagnostic | WarningDiagnostic | InfoDiagnostic;\n\nexport type ErrorDiagnosticSeverity = 'fatal' | 'error' | 'silly';\n\nexport type ErrorDiagnostic = GenericDiagnostic<\n  'error',\n  {\n    name: string;\n    severity: ErrorDiagnosticSeverity;\n    error: Error;\n  }\n>;\n\nexport type WarningDiagnostic = GenericDiagnostic<\n  'warning',\n  {\n    origin?: string;\n  }\n>;\n\nexport type InfoDiagnostic<T = unknown> = GenericDiagnostic<\n  'info',\n  {\n    params?: T;\n  }\n>;\n\nexport interface IDiagnosticReporter {\n  stack: {\n    readonly size: number;\n    readonly items: Diagnostic[];\n  };\n\n  report(diagnostic: Diagnostic): IDiagnosticReporter;\n  onDiagnostic(listener: DiagnosticListener): IDiagnosticReporter;\n  on<T extends DiagnosticKind>(kind: T, listener: DiagnosticListener<T>): IDiagnosticReporter;\n}\n\nconst createDiagnosticReporter = (\n  options: IDiagnosticReporterOptions = {}\n): IDiagnosticReporter => {\n  const { stackSize = -1 } = options;\n\n  const emitter = new EventEmitter();\n  const stack: Diagnostic[] = [];\n\n  const addListener = <T extends DiagnosticEvent>(event: T, listener: GetEventListener<T>) => {\n    emitter.on(event, listener);\n  };\n\n  const isDiagnosticValid = (diagnostic: Diagnostic) => {\n    if (!diagnostic.kind || !diagnostic.details || !diagnostic.details.message) {\n      return false;\n    }\n    return true;\n  };\n\n  return {\n    stack: {\n      get size() {\n        return stack.length;\n      },\n\n      get items() {\n        return stack;\n      },\n    },\n\n    report(diagnostic: Diagnostic) {\n      if (!isDiagnosticValid(diagnostic)) {\n        return this;\n      }\n\n      emitter.emit('diagnostic', diagnostic);\n      emitter.emit(`diagnostic.${diagnostic.kind}`, diagnostic);\n\n      if (stackSize !== -1 && stack.length >= stackSize) {\n        stack.shift();\n      }\n\n      stack.push(diagnostic);\n\n      return this;\n    },\n\n    onDiagnostic(listener: DiagnosticListener) {\n      addListener('diagnostic', listener);\n\n      return this;\n    },\n\n    on<T extends DiagnosticKind>(kind: T, listener: DiagnosticListener<T>) {\n      addListener(`diagnostic.${kind}`, listener as never);\n\n      return this;\n    },\n  };\n};\n\nexport { createDiagnosticReporter };\n","import { ErrorCode } from '../../types';\nimport { DataTransferError } from './base';\nimport { Severity, SeverityKind } from './constants';\n\ntype ProviderStep = 'initialization' | 'validation' | 'transfer';\n\nexport type ProviderErrorDetails<P extends ProviderStep = ProviderStep, U = never> = {\n  step: P;\n  code?: ErrorCode;\n} & ([U] extends [never] ? unknown : { details?: U });\n\nexport class ProviderError<\n  P extends ProviderStep = ProviderStep,\n  U = never,\n  T extends ProviderErrorDetails<P, U> = ProviderErrorDetails<P, U>,\n> extends DataTransferError<T> {\n  constructor(severity: Severity, message?: string, details?: T | null) {\n    super('provider', severity, message, details);\n  }\n}\n\nexport class ProviderInitializationError extends ProviderError<'initialization'> {\n  constructor(message?: string) {\n    super(SeverityKind.FATAL, message, { step: 'initialization' });\n  }\n}\n\n// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T\nexport class ProviderValidationError<T = ProviderErrorDetails> extends ProviderError<\n  'validation',\n  T\n> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.SILLY, message, { step: 'validation', details });\n  }\n}\n// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T\nexport class ProviderTransferError<T = ProviderErrorDetails> extends ProviderError<'transfer', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'transfer', details });\n  }\n}\n","import { PassThrough, Transform, Readable, Writable } from 'stream';\nimport { extname } from 'path';\nimport { EOL } from 'os';\nimport type Chain from 'stream-chain';\nimport { chain } from 'stream-chain';\nimport { isEmpty, uniq, last, isNumber, set, pick } from 'lodash/fp';\nimport { diff as semverDiff } from 'semver';\n\nimport type { Struct, Utils } from '@strapi/types';\n\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IEntity,\n  ILink,\n  IMetadata,\n  ISourceProvider,\n  ITransferEngine,\n  ITransferEngineOptions,\n  TransferProgress,\n  ITransferResults,\n  TransferStage,\n  TransferTransform,\n  IProvider,\n  TransferFilters,\n  TransferFilterPreset,\n  StreamItem,\n  SchemaDiffHandler,\n  SchemaDiffHandlerContext,\n  ErrorHandler,\n  ErrorHandlerContext,\n  ErrorHandlers,\n  ErrorCode,\n} from '../../types';\nimport type { Diff } from '../utils/json';\n\nimport { compareSchemas, validateProvider } from './validation';\n\nimport { TransferEngineError, TransferEngineValidationError } from './errors';\nimport {\n  createDiagnosticReporter,\n  IDiagnosticReporter,\n  ErrorDiagnosticSeverity,\n} from './diagnostic';\nimport { DataTransferError } from '../errors';\nimport * as utils from '../utils';\nimport { ProviderTransferError } from '../errors/providers';\n\nexport const TRANSFER_STAGES: ReadonlyArray<TransferStage> = Object.freeze([\n  'entities',\n  'links',\n  'assets',\n  'schemas',\n  'configuration',\n]);\n\nexport type TransferGroupFilter = Record<TransferFilterPreset, TransferFilters>;\n\n/**\n * Preset filters for only/exclude options\n * */\nexport const TransferGroupPresets: TransferGroupFilter = {\n  content: {\n    links: true, // Example: content includes the entire links stage\n    entities: true,\n    // TODO: If we need to implement filtering on a running stage, it would be done like this, but we still need to implement it\n    // [\n    //   // Example: content processes the entities stage, but filters individual entities\n    //   {\n    //     filter(data) {\n    //       return shouldIncludeThisData(data);\n    //     },\n    //   },\n    // ],\n  },\n  files: {\n    assets: true,\n  },\n  config: {\n    configuration: true,\n  },\n};\n\nexport const DEFAULT_VERSION_STRATEGY = 'ignore';\nexport const DEFAULT_SCHEMA_STRATEGY = 'strict';\n\ntype SchemaMap = Utils.String.Dict<Struct.Schema>;\n\nclass TransferEngine<\n  S extends ISourceProvider = ISourceProvider,\n  D extends IDestinationProvider = IDestinationProvider,\n> implements ITransferEngine\n{\n  sourceProvider: ISourceProvider;\n\n  destinationProvider: IDestinationProvider;\n\n  options: ITransferEngineOptions;\n\n  #metadata: { source?: IMetadata; destination?: IMetadata } = {};\n\n  #schema: { source?: SchemaMap; destination?: SchemaMap } = {};\n\n  // Progress of the current stage\n  progress: {\n    // metrics on the progress such as size and record count\n    data: TransferProgress;\n    // stream that emits events\n    stream: PassThrough;\n  };\n\n  diagnostics: IDiagnosticReporter;\n\n  #handlers: {\n    schemaDiff: SchemaDiffHandler[];\n    errors: Partial<ErrorHandlers>;\n  } = {\n    schemaDiff: [],\n    errors: {},\n  };\n\n  onSchemaDiff(handler: SchemaDiffHandler) {\n    this.#handlers?.schemaDiff?.push(handler);\n  }\n\n  addErrorHandler(handlerName: ErrorCode, handler: ErrorHandler) {\n    if (!this.#handlers.errors[handlerName]) {\n      this.#handlers.errors[handlerName] = [];\n    }\n    this.#handlers.errors[handlerName]?.push(handler);\n  }\n\n  async attemptResolveError(error: Error) {\n    const context: ErrorHandlerContext = {};\n    if (error instanceof ProviderTransferError && error.details?.details.code) {\n      const errorCode = error.details?.details.code as ErrorCode;\n      if (!this.#handlers.errors[errorCode]) {\n        this.#handlers.errors[errorCode] = [];\n      }\n      await utils.middleware.runMiddleware(context ?? {}, this.#handlers.errors[errorCode] ?? []);\n    }\n\n    return !!context.ignore;\n  }\n\n  // Save the currently open stream so that we can access it at any time\n  #currentStream?: Writable;\n\n  constructor(sourceProvider: S, destinationProvider: D, options: ITransferEngineOptions) {\n    this.diagnostics = createDiagnosticReporter();\n\n    validateProvider('source', sourceProvider);\n    validateProvider('destination', destinationProvider);\n\n    this.sourceProvider = sourceProvider;\n    this.destinationProvider = destinationProvider;\n    this.options = options;\n\n    this.progress = { data: {}, stream: new PassThrough({ objectMode: true }) };\n  }\n\n  /**\n   * Report a fatal error and throw it\n   */\n  panic(error: Error) {\n    this.reportError(error, 'fatal');\n\n    throw error;\n  }\n\n  /**\n   * Report an error diagnostic\n   */\n  reportError(error: Error, severity: ErrorDiagnosticSeverity) {\n    this.diagnostics.report({\n      kind: 'error',\n      details: {\n        severity,\n        createdAt: new Date(),\n        name: error.name,\n        message: error.message,\n        error,\n      },\n    });\n  }\n\n  /**\n   * Report a warning diagnostic\n   */\n  reportWarning(message: string, origin?: string) {\n    this.diagnostics.report({\n      kind: 'warning',\n      details: { createdAt: new Date(), message, origin },\n    });\n  }\n\n  /**\n   * Report an info diagnostic\n   */\n  reportInfo(message: string, params?: unknown) {\n    this.diagnostics.report({\n      kind: 'info',\n      details: { createdAt: new Date(), message, params },\n    });\n  }\n\n  /**\n   * Create and return a transform stream based on the given stage and options.\n   *\n   * Allowed transformations includes 'filter' and 'map'.\n   */\n  #createStageTransformStream<T extends TransferStage>(\n    key: T,\n    options: { includeGlobal?: boolean } = {}\n  ): PassThrough | Transform {\n    const { includeGlobal = true } = options;\n    const { throttle } = this.options;\n    const { global: globalTransforms, [key]: stageTransforms } = this.options?.transforms ?? {};\n\n    let stream: PassThrough | Chain = new PassThrough({ objectMode: true });\n\n    const applyTransforms = <U>(transforms: TransferTransform<U>[] = []) => {\n      const chainTransforms: StreamItem[] = [];\n      for (const transform of transforms) {\n        if ('filter' in transform) {\n          chainTransforms.push(utils.stream.filter(transform.filter));\n        }\n\n        if ('map' in transform) {\n          chainTransforms.push(utils.stream.map(transform.map));\n        }\n      }\n      if (chainTransforms.length) {\n        stream = stream.pipe(chain(chainTransforms));\n      }\n    };\n\n    if (includeGlobal) {\n      applyTransforms(globalTransforms);\n    }\n\n    if (isNumber(throttle) && throttle > 0) {\n      stream = stream.pipe(\n        new PassThrough({\n          objectMode: true,\n          async transform(data, _encoding, callback) {\n            await new Promise((resolve) => {\n              setTimeout(resolve, throttle);\n            });\n            callback(null, data);\n          },\n        })\n      );\n    }\n\n    applyTransforms(stageTransforms as TransferTransform<unknown>[]);\n\n    return stream;\n  }\n\n  /**\n   * Update the Engine's transfer progress data for a given stage.\n   *\n   * Providing aggregate options enable custom computation to get the size (bytes) or the aggregate key associated with the data\n   */\n  #updateTransferProgress<T = unknown>(\n    stage: TransferStage,\n    data: T,\n    aggregate?: {\n      size?: (value: T) => number;\n      key?: (value: T) => string;\n    }\n  ) {\n    if (!this.progress.data[stage]) {\n      this.progress.data[stage] = { count: 0, bytes: 0, startTime: Date.now() };\n    }\n\n    const stageProgress = this.progress.data[stage];\n\n    if (!stageProgress) {\n      return;\n    }\n\n    const size = aggregate?.size?.(data) ?? JSON.stringify(data).length;\n    const key = aggregate?.key?.(data);\n\n    stageProgress.count += 1;\n    stageProgress.bytes += size;\n\n    // Handle aggregate updates if necessary\n    if (key) {\n      if (!stageProgress.aggregates) {\n        stageProgress.aggregates = {};\n      }\n\n      const { aggregates } = stageProgress;\n\n      if (!aggregates[key]) {\n        aggregates[key] = { count: 0, bytes: 0 };\n      }\n\n      aggregates[key].count += 1;\n      aggregates[key].bytes += size;\n    }\n  }\n\n  /**\n   * Create and return a PassThrough stream.\n   *\n   * Upon writing data into it, it'll update the Engine's transfer progress data and trigger stage update events.\n   */\n  #progressTracker(\n    stage: TransferStage,\n    aggregate?: {\n      size?(value: unknown): number;\n      key?(value: unknown): string;\n    }\n  ) {\n    return new PassThrough({\n      objectMode: true,\n      transform: (data, _encoding, callback) => {\n        this.#updateTransferProgress(stage, data, aggregate);\n        this.#emitStageUpdate('progress', stage);\n        callback(null, data);\n      },\n    });\n  }\n\n  /**\n   * Shorthand method used to trigger transfer update events to every listeners\n   */\n  #emitTransferUpdate(type: 'init' | 'start' | 'finish' | 'error', payload?: object) {\n    this.progress.stream.emit(`transfer::${type}`, payload);\n  }\n\n  /**\n   * Shorthand method used to trigger stage update events to every listeners\n   */\n  #emitStageUpdate(\n    type: 'start' | 'finish' | 'progress' | 'skip' | 'error',\n    transferStage: TransferStage\n  ) {\n    this.progress.stream.emit(`stage::${type}`, {\n      data: this.progress.data,\n      stage: transferStage,\n    });\n  }\n\n  /**\n   * Run a version check between two strapi version (source and destination) using the strategy given to the engine during initialization.\n   *\n   * If there is a mismatch, throws a validation error.\n   */\n  #assertStrapiVersionIntegrity(sourceVersion?: string, destinationVersion?: string) {\n    const strategy = this.options.versionStrategy || DEFAULT_VERSION_STRATEGY;\n\n    const reject = () => {\n      throw new TransferEngineValidationError(\n        `The source and destination provide are targeting incompatible Strapi versions (using the \"${strategy}\" strategy). The source (${this.sourceProvider.name}) version is ${sourceVersion} and the destination (${this.destinationProvider.name}) version is ${destinationVersion}`,\n        {\n          check: 'strapi.version',\n          strategy,\n          versions: { source: sourceVersion, destination: destinationVersion },\n        }\n      );\n    };\n\n    if (\n      !sourceVersion ||\n      !destinationVersion ||\n      strategy === 'ignore' ||\n      destinationVersion === sourceVersion\n    ) {\n      return;\n    }\n\n    let diff;\n    try {\n      diff = semverDiff(sourceVersion, destinationVersion);\n    } catch {\n      reject();\n    }\n\n    if (!diff) {\n      return;\n    }\n\n    const validPatch = ['prelease', 'build'];\n    const validMinor = [...validPatch, 'patch', 'prepatch'];\n    const validMajor = [...validMinor, 'minor', 'preminor'];\n    if (strategy === 'patch' && validPatch.includes(diff)) {\n      return;\n    }\n    if (strategy === 'minor' && validMinor.includes(diff)) {\n      return;\n    }\n    if (strategy === 'major' && validMajor.includes(diff)) {\n      return;\n    }\n\n    reject();\n  }\n\n  /**\n   * Run a check between two set of schemas (source and destination) using the strategy given to the engine during initialization.\n   *\n   * If there are differences and/or incompatibilities between source and destination schemas, then throw a validation error.\n   */\n  #assertSchemasMatching(sourceSchemas: SchemaMap, destinationSchemas: SchemaMap) {\n    const strategy = this.options.schemaStrategy || DEFAULT_SCHEMA_STRATEGY;\n\n    if (strategy === 'ignore') {\n      return;\n    }\n\n    const keys = uniq(Object.keys(sourceSchemas).concat(Object.keys(destinationSchemas)));\n    const diffs: { [key: string]: Diff[] } = {};\n\n    keys.forEach((key) => {\n      const sourceSchema = sourceSchemas[key];\n      const destinationSchema = destinationSchemas[key];\n      const schemaDiffs = compareSchemas(sourceSchema, destinationSchema, strategy);\n\n      if (schemaDiffs.length) {\n        diffs[key] = schemaDiffs as Diff<Struct.Schema>[];\n      }\n    });\n\n    if (!isEmpty(diffs)) {\n      const formattedDiffs = Object.entries(diffs)\n        .map(([uid, ctDiffs]) => {\n          let msg = `- ${uid}:${EOL}`;\n\n          msg += ctDiffs\n            .sort((a, b) => (a.kind > b.kind ? -1 : 1))\n            .map((diff) => {\n              const path = diff.path.join('.');\n\n              if (diff.kind === 'added') {\n                return `${path} exists in destination schema but not in source schema and the data will not be transferred.`;\n              }\n\n              if (diff.kind === 'deleted') {\n                return `${path} exists in source schema but not in destination schema and the data will not be transferred.`;\n              }\n\n              if (diff.kind === 'modified') {\n                if (diff.types[0] === diff.types[1]) {\n                  return `Schema value changed at \"${path}\": \"${diff.values[0]}\" (${diff.types[0]}) => \"${diff.values[1]}\" (${diff.types[1]})`;\n                }\n\n                return `Schema has differing data types at \"${path}\": \"${diff.values[0]}\" (${diff.types[0]}) => \"${diff.values[1]}\" (${diff.types[1]})`;\n              }\n\n              throw new TransferEngineValidationError(`Invalid diff found for \"${uid}\"`, {\n                check: `schema on ${uid}`,\n              });\n            })\n            .map((line) => `  - ${line}`)\n            .join(EOL);\n\n          return msg;\n        })\n        .join(EOL);\n\n      throw new TransferEngineValidationError(\n        `Invalid schema changes detected during integrity checks (using the ${strategy} strategy). Please find a summary of the changes below:\\n${formattedDiffs}`,\n        {\n          check: 'schema.changes',\n          strategy,\n          diffs,\n        }\n      );\n    }\n  }\n\n  shouldSkipStage(stage: TransferStage) {\n    const { exclude, only } = this.options;\n\n    // schemas must always be included\n    if (stage === 'schemas') {\n      return false;\n    }\n\n    // everything is included by default unless 'only' has been set\n    let included = isEmpty(only);\n    if (only && only.length > 0) {\n      included = only.some((transferGroup) => {\n        return TransferGroupPresets[transferGroup][stage];\n      });\n    }\n\n    if (exclude && exclude.length > 0) {\n      if (included) {\n        included = !exclude.some((transferGroup) => {\n          return TransferGroupPresets[transferGroup][stage];\n        });\n      }\n    }\n\n    return !included;\n  }\n\n  async #transferStage(options: {\n    stage: TransferStage;\n    source?: Readable;\n    destination?: Writable;\n    transform?: PassThrough | Chain;\n    tracker?: PassThrough;\n  }) {\n    const { stage, source, destination, transform, tracker } = options;\n\n    const updateEndTime = () => {\n      const stageData = this.progress.data[stage];\n\n      if (stageData) {\n        stageData.endTime = Date.now();\n      }\n    };\n\n    if (!source || !destination || this.shouldSkipStage(stage)) {\n      // Wait until source and destination are closed\n      const results = await Promise.allSettled(\n        [source, destination].map((stream) => {\n          // if stream is undefined or already closed, resolve immediately\n          if (!stream || stream.destroyed) {\n            return Promise.resolve();\n          }\n\n          // Wait until the close event is produced and then destroy the stream and resolve\n          return new Promise((resolve, reject) => {\n            stream.on('close', resolve).on('error', reject).destroy();\n          });\n        })\n      );\n\n      results.forEach((state) => {\n        if (state.status === 'rejected') {\n          this.reportWarning(state.reason, `transfer(${stage})`);\n        }\n      });\n\n      this.#emitStageUpdate('skip', stage);\n\n      return;\n    }\n\n    this.#emitStageUpdate('start', stage);\n\n    await new Promise<void>((resolve, reject) => {\n      let stream: Readable = source;\n\n      if (transform) {\n        stream = stream.pipe(transform);\n      }\n\n      if (tracker) {\n        stream = stream.pipe(tracker);\n      }\n\n      this.#currentStream = stream\n        .pipe(destination)\n        .on('error', (e) => {\n          updateEndTime();\n          this.#emitStageUpdate('error', stage);\n          this.reportError(e, 'error');\n          destination.destroy(e);\n          reject(e);\n        })\n        .on('close', () => {\n          this.#currentStream = undefined;\n          updateEndTime();\n          resolve();\n        });\n    });\n\n    this.#emitStageUpdate('finish', stage);\n  }\n\n  // Cause an ongoing transfer to abort gracefully\n  async abortTransfer(): Promise<void> {\n    const err = new TransferEngineError('fatal', 'Transfer aborted.');\n    if (!this.#currentStream) {\n      throw err;\n    }\n    this.#currentStream.destroy(err);\n  }\n\n  async init(): Promise<void> {\n    // Resolve providers' resource and store\n    // them in the engine's internal state\n    await this.#resolveProviderResource();\n\n    // Update the destination provider's source metadata\n    const { source: sourceMetadata } = this.#metadata;\n\n    if (sourceMetadata) {\n      this.destinationProvider.setMetadata?.('source', sourceMetadata);\n    }\n  }\n\n  /**\n   * Run the bootstrap method in both source and destination providers\n   */\n  async bootstrap(): Promise<void> {\n    const results = await Promise.allSettled([\n      this.sourceProvider.bootstrap?.(),\n      this.destinationProvider.bootstrap?.(),\n    ]);\n\n    results.forEach((result) => {\n      if (result.status === 'rejected') {\n        this.panic(result.reason);\n      }\n    });\n  }\n\n  /**\n   * Run the close method in both source and destination providers\n   */\n  async close(): Promise<void> {\n    const results = await Promise.allSettled([\n      this.sourceProvider.close?.(),\n      this.destinationProvider.close?.(),\n    ]);\n\n    results.forEach((result) => {\n      if (result.status === 'rejected') {\n        this.panic(result.reason);\n      }\n    });\n  }\n\n  async #resolveProviderResource() {\n    const sourceMetadata = await this.sourceProvider.getMetadata();\n    const destinationMetadata = await this.destinationProvider.getMetadata();\n\n    if (sourceMetadata) {\n      this.#metadata.source = sourceMetadata;\n    }\n\n    if (destinationMetadata) {\n      this.#metadata.destination = destinationMetadata;\n    }\n  }\n\n  async #getSchemas() {\n    if (!this.#schema.source) {\n      this.#schema.source = (await this.sourceProvider.getSchemas?.()) as SchemaMap;\n    }\n\n    if (!this.#schema.destination) {\n      this.#schema.destination = (await this.destinationProvider.getSchemas?.()) as SchemaMap;\n    }\n\n    return {\n      sourceSchemas: this.#schema.source,\n      destinationSchemas: this.#schema.destination,\n    };\n  }\n\n  async integrityCheck() {\n    const sourceMetadata = await this.sourceProvider.getMetadata();\n    const destinationMetadata = await this.destinationProvider.getMetadata();\n\n    if (sourceMetadata && destinationMetadata) {\n      this.#assertStrapiVersionIntegrity(\n        sourceMetadata?.strapi?.version,\n        destinationMetadata?.strapi?.version\n      );\n    }\n\n    const { sourceSchemas, destinationSchemas } = await this.#getSchemas();\n\n    try {\n      if (sourceSchemas && destinationSchemas) {\n        this.#assertSchemasMatching(sourceSchemas, destinationSchemas);\n      }\n    } catch (error) {\n      // if this is a schema matching error, allow handlers to resolve it\n      if (error instanceof TransferEngineValidationError && error.details?.details?.diffs) {\n        const schemaDiffs = error.details?.details?.diffs as Record<string, Diff[]>;\n\n        const context: SchemaDiffHandlerContext = {\n          ignoredDiffs: {},\n          diffs: schemaDiffs,\n          source: this.sourceProvider,\n          destination: this.destinationProvider,\n        };\n\n        // if we don't have any handlers, throw the original error\n        if (isEmpty(this.#handlers.schemaDiff)) {\n          throw error;\n        }\n\n        await utils.middleware.runMiddleware<SchemaDiffHandlerContext>(\n          context,\n          this.#handlers.schemaDiff\n        );\n\n        // if there are any remaining diffs that weren't ignored\n        const unresolvedDiffs = utils.json.diff(context.diffs, context.ignoredDiffs);\n        if (unresolvedDiffs.length) {\n          this.panic(\n            new TransferEngineValidationError('Unresolved differences in schema', {\n              check: 'schema.changes',\n              unresolvedDiffs,\n            })\n          );\n        }\n\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  async transfer(): Promise<ITransferResults<S, D>> {\n    // reset data between transfers\n    this.progress.data = {};\n\n    try {\n      this.#emitTransferUpdate('init');\n      await this.bootstrap();\n      await this.init();\n\n      await this.integrityCheck();\n\n      this.#emitTransferUpdate('start');\n\n      await this.beforeTransfer();\n\n      // Run the transfer stages\n      await this.transferSchemas();\n      await this.transferEntities();\n      await this.transferAssets();\n      await this.transferLinks();\n      await this.transferConfiguration();\n      // Gracefully close the providers\n      await this.close();\n\n      this.#emitTransferUpdate('finish');\n    } catch (e: unknown) {\n      this.#emitTransferUpdate('error', { error: e });\n\n      const lastDiagnostic = last(this.diagnostics.stack.items);\n      // Do not report an error diagnostic if the last one reported the same error\n      if (\n        e instanceof Error &&\n        (!lastDiagnostic || lastDiagnostic.kind !== 'error' || lastDiagnostic.details.error !== e)\n      ) {\n        this.reportError(e, (e as DataTransferError).severity || 'fatal');\n      }\n\n      // Rollback the destination provider if an exception is thrown during the transfer\n      // Note: This will be configurable in the future\n      await this.destinationProvider.rollback?.(e as Error);\n\n      throw e;\n    }\n\n    return {\n      source: this.sourceProvider.results,\n      destination: this.destinationProvider.results,\n      engine: this.progress.data,\n    };\n  }\n\n  async beforeTransfer(): Promise<void> {\n    const runWithDiagnostic = async (provider: IProvider) => {\n      try {\n        await provider.beforeTransfer?.();\n      } catch (error) {\n        if (error instanceof Error) {\n          const resolved = await this.attemptResolveError(error);\n\n          if (resolved) {\n            return;\n          }\n          this.panic(error);\n        } else {\n          this.panic(\n            new Error(`Unknwon error when executing \"beforeTransfer\" on the ${origin} provider`)\n          );\n        }\n      }\n    };\n\n    await runWithDiagnostic(this.sourceProvider);\n    await runWithDiagnostic(this.destinationProvider);\n  }\n\n  async transferSchemas(): Promise<void> {\n    const stage: TransferStage = 'schemas';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createSchemasReadStream?.();\n    const destination = await this.destinationProvider.createSchemasWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage, {\n      key: (value: Struct.Schema) => value.modelType,\n    });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferEntities(): Promise<void> {\n    const stage: TransferStage = 'entities';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createEntitiesReadStream?.();\n    const destination = await this.destinationProvider.createEntitiesWriteStream?.();\n\n    const transform = chain([\n      this.#createStageTransformStream(stage),\n      new Transform({\n        objectMode: true,\n        transform: async (entity: IEntity, _encoding, callback) => {\n          const { destinationSchemas: schemas } = await this.#getSchemas();\n\n          if (!schemas) {\n            return callback(null, entity);\n          }\n\n          // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown\n          const availableContentTypes = Object.entries(schemas)\n            .filter(([, schema]) => schema.modelType === 'contentType')\n            .map(([uid]) => uid);\n\n          // If the type of the transferred entity doesn't exist in the destination, then discard it\n          if (!availableContentTypes.includes(entity.type)) {\n            return callback(null, undefined);\n          }\n\n          const { type, data } = entity;\n          const attributes = schemas[type].attributes;\n          const attributesToKeep = Object.keys(attributes).concat('documentId');\n          const updatedEntity = set('data', pick(attributesToKeep, data), entity);\n\n          callback(null, updatedEntity);\n        },\n      }),\n    ]);\n\n    const tracker = this.#progressTracker(stage, { key: (value: IEntity) => value.type });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferLinks(): Promise<void> {\n    const stage: TransferStage = 'links';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createLinksReadStream?.();\n    const destination = await this.destinationProvider.createLinksWriteStream?.();\n\n    const transform = chain([\n      this.#createStageTransformStream(stage),\n      new Transform({\n        objectMode: true,\n        transform: async (link: ILink, _encoding, callback) => {\n          const { destinationSchemas: schemas } = await this.#getSchemas();\n          if (!schemas) {\n            return callback(null, link);\n          }\n\n          // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown\n          const availableContentTypes = Object.keys(schemas);\n\n          const isValidType = (uid: string) => availableContentTypes.includes(uid);\n\n          if (!isValidType(link.left.type) || !isValidType(link.right.type)) {\n            return callback(null, undefined); // ignore the link\n          }\n\n          callback(null, link);\n        },\n      }),\n    ]);\n\n    const tracker = this.#progressTracker(stage);\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferAssets(): Promise<void> {\n    const stage: TransferStage = 'assets';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createAssetsReadStream?.();\n    const destination = await this.destinationProvider.createAssetsWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage, {\n      size: (value: IAsset) => value.stats.size,\n      key: (value: IAsset) => extname(value.filename) || 'No extension',\n    });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferConfiguration(): Promise<void> {\n    const stage: TransferStage = 'configuration';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createConfigurationReadStream?.();\n    const destination = await this.destinationProvider.createConfigurationWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage);\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n}\n\nexport const createTransferEngine = <S extends ISourceProvider, D extends IDestinationProvider>(\n  sourceProvider: S,\n  destinationProvider: D,\n  options: ITransferEngineOptions\n): TransferEngine<S, D> => {\n  return new TransferEngine<S, D>(sourceProvider, destinationProvider, options);\n};\n\nexport type {\n  TransferEngine,\n  ITransferEngine,\n  ITransferEngineOptions,\n  ISourceProvider,\n  IDestinationProvider,\n  TransferStage,\n  TransferFilterPreset,\n  ErrorHandlerContext,\n  SchemaDiffHandlerContext,\n  ITransferResults,\n};\n\nexport * as errors from './errors';\n","import _ from 'lodash';\nimport { get, has, omit, pipe, assign } from 'lodash/fp';\n\nimport { contentTypes as contentTypesUtils, async, errors } from '@strapi/utils';\nimport type { Modules, UID, Data, Utils, Schema, Core } from '@strapi/types';\n\ntype LoadedComponents<TUID extends UID.Schema> = Data.Entity<\n  TUID,\n  Schema.AttributeNamesByType<TUID, 'component' | 'dynamiczone'>\n>;\n\ntype ComponentValue = Schema.Attribute.Value<\n  Schema.Attribute.Component<UID.Component, false> | Schema.Attribute.Component<UID.Component, true>\n>;\n\ntype ComponentBody = {\n  [key: string]: Schema.Attribute.Value<\n    | Schema.Attribute.Component<UID.Component, false>\n    | Schema.Attribute.Component<UID.Component, true>\n    | Schema.Attribute.DynamicZone\n  >;\n};\n\nconst isDialectMySQL = () => strapi.db?.dialect.client === 'mysql';\n\nfunction omitComponentData(\n  contentType: Schema.ContentType,\n  data: Modules.EntityService.Params.Data.Input<Schema.ContentType['uid']>\n): Partial<Modules.EntityService.Params.Data.Input<Schema.ContentType['uid']>>;\nfunction omitComponentData(\n  contentType: Schema.Component,\n  data: Modules.EntityService.Params.Data.Input<Schema.Component['uid']>\n): Partial<Modules.EntityService.Params.Data.Input<Schema.Component['uid']>>;\nfunction omitComponentData(\n  contentType: Schema.ContentType | Schema.Component,\n  data: Modules.EntityService.Params.Data.Input<Schema.ContentType['uid'] | Schema.Component['uid']>\n): Partial<\n  Modules.EntityService.Params.Data.Input<Schema.ContentType['uid'] | Schema.Component['uid']>\n> {\n  const { attributes } = contentType;\n  const componentAttributes = Object.keys(attributes).filter((attributeName) =>\n    contentTypesUtils.isComponentAttribute(attributes[attributeName])\n  );\n\n  return omit(componentAttributes, data);\n}\n\n// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer\nconst createComponents = async <\n  TUID extends UID.Schema,\n  TData extends Modules.EntityService.Params.Data.Input<TUID>,\n>(\n  uid: TUID,\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data) || !contentTypesUtils.isComponentAttribute(attribute)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[attributeName as keyof TData];\n\n      if (componentValue === null) {\n        continue;\n      }\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        const components = (await async.map(\n          componentValue,\n          (value: any) => createComponent(componentUID, value),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        )) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n\n        componentBody[attributeName] = components.map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await createComponent(\n          componentUID,\n          componentValue as Modules.EntityService.Params.Data.Input<UID.Component>\n        );\n        componentBody[attributeName] = {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[\n        attributeName as keyof TData\n      ] as Modules.EntityService.Params.Attribute.GetValue<Schema.Attribute.DynamicZone>;\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      const createDynamicZoneComponents = async (\n        value: Utils.Array.Values<typeof dynamiczoneValues>\n      ) => {\n        const { id } = await createComponent(value.__component, value);\n        return {\n          id,\n          __component: value.__component,\n          __pivot: {\n            field: attributeName,\n          },\n        };\n      };\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(\n        dynamiczoneValues,\n        createDynamicZoneComponents,\n        { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n      );\n\n      continue;\n    }\n  }\n\n  return componentBody;\n};\n\nconst getComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entity: { id: Modules.EntityService.Params.Attribute.ID }\n): Promise<LoadedComponents<TUID>> => {\n  const componentAttributes = contentTypesUtils.getComponentAttributes(strapi.getModel(uid));\n\n  if (_.isEmpty(componentAttributes)) {\n    return {} as LoadedComponents<TUID>;\n  }\n\n  return strapi.db.query(uid).load(entity, componentAttributes) as Promise<LoadedComponents<TUID>>;\n};\n\n/*\n  delete old components\n  create or update\n*/\nconst updateComponents = async <\n  TUID extends UID.Schema,\n  TData extends Partial<Modules.EntityService.Params.Data.Input<TUID>>,\n>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  for (const attributeName of Object.keys(attributes)) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[\n        attributeName as keyof TData\n      ] as Schema.Attribute.Value<Schema.Attribute.Component>;\n\n      await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        const components = (await async.map(\n          componentValue,\n          (value: any) => updateOrCreateComponent(componentUID, value),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        )) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n\n        componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await updateOrCreateComponent(componentUID, componentValue);\n        componentBody[attributeName] = component && {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[\n        attributeName as keyof TData\n      ] as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n      await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(\n        dynamiczoneValues,\n        async (value: any) => {\n          const { id } = await updateOrCreateComponent(value.__component, value);\n\n          return {\n            id,\n            __component: value.__component,\n            __pivot: {\n              field: attributeName,\n            },\n          };\n        },\n        { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n      );\n\n      continue;\n    }\n  }\n\n  return componentBody;\n};\n\nconst pickStringifiedId = ({\n  id,\n}: {\n  id: Modules.EntityService.Params.Attribute.ID;\n}): Modules.EntityService.Params.Attribute.ID & string => {\n  if (typeof id === 'string') {\n    return id;\n  }\n\n  return `${id}`;\n};\n\nconst deleteOldComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  componentUID: UID.Component,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  componentValue: Schema.Attribute.Value<Schema.Attribute.Component>\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as ComponentValue;\n\n  const idsToKeep = _.castArray(componentValue).filter(has('id')).map(pickStringifiedId);\n  const allIds = _.castArray(previousValue).filter(has('id')).map(pickStringifiedId);\n\n  idsToKeep.forEach((id) => {\n    if (!allIds.includes(id)) {\n      throw new errors.ApplicationError(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n    }\n  });\n\n  const idsToDelete = _.difference(allIds, idsToKeep);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      await deleteComponent(componentUID, { id: idToDelete });\n    }\n  }\n};\n\nconst deleteOldDZComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  dynamiczoneValues: Schema.Attribute.Value<Schema.Attribute.DynamicZone>\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n  const idsToKeep = _.castArray(dynamiczoneValues)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  const allIds = _.castArray(previousValue)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  idsToKeep.forEach(({ id, __component }) => {\n    if (!allIds.find((el) => el.id === id && el.__component === __component)) {\n      const err = new Error(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n\n      Object.assign(err, { status: 400 });\n      throw err;\n    }\n  });\n\n  type IdsToDelete = Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n  const idsToDelete = allIds.reduce((acc, { id, __component }) => {\n    if (!idsToKeep.find((el) => el.id === id && el.__component === __component)) {\n      acc.push({ id, __component });\n    }\n\n    return acc;\n  }, [] as IdsToDelete);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      const { id, __component } = idToDelete;\n      await deleteComponent(__component, { id });\n    }\n  }\n};\n\nconst deleteComponents = async <TUID extends UID.Schema, TEntity extends Data.Entity<TUID>>(\n  uid: TUID,\n  entityToDelete: TEntity,\n  { loadComponents = true } = {}\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (attribute.type === 'component' || attribute.type === 'dynamiczone') {\n      let value;\n      if (loadComponents) {\n        value = await strapi.db.query(uid).load(entityToDelete, attributeName);\n      } else {\n        value = entityToDelete[attributeName as keyof TEntity];\n      }\n\n      if (!value) {\n        continue;\n      }\n\n      if (attribute.type === 'component') {\n        const { component: componentUID } = attribute;\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        await async.map(\n          _.castArray(value),\n          (subValue: any) => deleteComponent(componentUID, subValue),\n          {\n            concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity,\n          }\n        );\n      } else {\n        // delete dynamic zone components\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        await async.map(\n          _.castArray(value),\n          (subValue: any) => deleteComponent(subValue.__component, subValue),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        );\n      }\n\n      continue;\n    }\n  }\n};\n\n/** *************************\n    Component queries\n************************** */\n\n// components can have nested compos so this must be recursive\nconst createComponent = async <TUID extends UID.Component = UID.Component>(\n  uid: TUID,\n  data: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  const model = strapi.getModel(uid) as Schema.Component;\n\n  const componentData = await createComponents(uid, data);\n  const transform = pipe(\n    // Make sure we don't save the component with a pre-defined ID\n    omit('id'),\n    // Remove the component data from the original data object ...\n    (payload) => omitComponentData(model, payload),\n    // ... and assign the newly created component instead\n    assign(componentData)\n  );\n\n  return strapi.db.query(uid).create({ data: transform(data) });\n};\n\n// components can have nested compos so this must be recursive\nconst updateComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  const model = strapi.getModel(uid) as Schema.Component;\n\n  const componentData = await updateComponents(uid, componentToUpdate, data);\n\n  return strapi.db.query(uid).update({\n    where: {\n      id: componentToUpdate.id,\n    },\n    data: Object.assign(omitComponentData(model, data), componentData),\n  });\n};\n\nconst updateOrCreateComponent = <TUID extends UID.Component>(\n  componentUID: TUID,\n  value: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  if (value === null) {\n    return null;\n  }\n\n  // update\n  if ('id' in value && typeof value.id !== 'undefined') {\n    // TODO: verify the compo is associated with the entity\n    return updateComponent(componentUID, { id: value.id }, value);\n  }\n\n  // create\n  return createComponent(componentUID, value);\n};\n\nconst deleteComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToDelete: Data.Component<TUID>\n) => {\n  await deleteComponents(uid, componentToDelete);\n  await strapi.db.query(uid).delete({ where: { id: componentToDelete.id } });\n};\n\n/**\n * Resolve the component UID of an entity's attribute based\n * on a given path (components & dynamic zones only)\n */\nconst resolveComponentUID = ({\n  paths,\n  strapi,\n  data,\n  contentType,\n}: {\n  paths: string[];\n  strapi: Core.Strapi;\n  data: any;\n  contentType: Schema.ContentType;\n}): UID.Schema | undefined => {\n  let value: unknown = data;\n  let cType:\n    | Schema.ContentType\n    | Schema.Component\n    | ((...opts: any[]) => Schema.ContentType | Schema.Component) = contentType;\n  for (const path of paths) {\n    value = get(path, value);\n\n    // Needed when the value of cType should be computed\n    // based on the next value (eg: dynamic zones)\n    if (typeof cType === 'function') {\n      cType = cType(value);\n    }\n\n    if (path in cType.attributes) {\n      const attribute: Schema.Attribute.AnyAttribute = cType.attributes[path];\n\n      if (attribute.type === 'component') {\n        cType = strapi.getModel(attribute.component);\n      }\n\n      if (attribute.type === 'dynamiczone') {\n        cType = ({ __component }: { __component: UID.Component }) => strapi.getModel(__component);\n      }\n    }\n  }\n\n  if ('uid' in cType) {\n    return cType.uid;\n  }\n\n  return undefined;\n};\n\nexport {\n  omitComponentData,\n  getComponents,\n  createComponents,\n  updateComponents,\n  deleteComponents,\n  deleteComponent,\n  resolveComponentUID,\n};\n","import { assign, isArray, isEmpty, isObject, map, omit, size } from 'lodash/fp';\n\nimport type { Core, UID, Data, Struct } from '@strapi/types';\nimport * as componentsService from '../../utils/components';\n\nconst sanitizeComponentLikeAttributes = <T extends Struct.Schema>(\n  model: T,\n  data: Data.Entity<T['uid']>\n) => {\n  const { attributes } = model;\n\n  const componentLikeAttributesKey = Object.entries(attributes)\n    .filter(([, attribute]) => attribute.type === 'component' || attribute.type === 'dynamiczone')\n    .map(([key]) => key);\n\n  return omit(componentLikeAttributesKey, data);\n};\n\nconst omitInvalidCreationAttributes = omit(['id']);\n\nconst createEntityQuery = (strapi: Core.Strapi): any => {\n  const components = {\n    async assignToEntity(uid: UID.Schema, data: any) {\n      const model = strapi.getModel(uid);\n\n      const entityComponents = await componentsService.createComponents(uid, data);\n      const dataWithoutComponents = sanitizeComponentLikeAttributes(model, data);\n\n      return assign(entityComponents, dataWithoutComponents);\n    },\n\n    async get<T extends object>(uid: string, entity: T) {\n      return componentsService.getComponents(uid as UID.Schema, entity as any);\n    },\n\n    delete<T extends object>(uid: string, componentsToDelete: T) {\n      return componentsService.deleteComponents(uid as UID.Schema, componentsToDelete as any, {\n        loadComponents: false,\n      });\n    },\n  };\n\n  const query = (uid: UID.Schema) => {\n    const create = async <T extends { data: U }, U extends object>(params: T) => {\n      const dataWithComponents = await components.assignToEntity(uid, params.data);\n      const sanitizedData = omitInvalidCreationAttributes(dataWithComponents);\n\n      return strapi.db.query(uid).create({ ...params, data: sanitizedData });\n    };\n\n    const createMany = async <T extends { data: U[] }, U extends object>(params: T) => {\n      return (\n        Promise.resolve(params.data)\n          // Create components for each entity\n          .then(map((data) => components.assignToEntity(uid, data)))\n          // Remove unwanted attributes\n          .then(map(omitInvalidCreationAttributes))\n          // Execute a strapi db createMany query with all the entities + their created components\n          .then((data) => strapi.db.query(uid).createMany({ ...params, data }))\n      );\n    };\n\n    const deleteMany = async <T extends object>(params?: T) => {\n      const entitiesToDelete = await strapi.db.query(uid).findMany(params ?? {});\n\n      if (!entitiesToDelete.length) {\n        return null;\n      }\n\n      const componentsToDelete = await Promise.all(\n        entitiesToDelete.map((entityToDelete) => components.get(uid, entityToDelete))\n      );\n\n      const deletedEntities = await strapi.db.query(uid).deleteMany(params);\n      await Promise.all(componentsToDelete.map((compos) => components.delete(uid, compos)));\n\n      return deletedEntities;\n    };\n\n    const getDeepPopulateComponentLikeQuery = (\n      contentType: Struct.Schema,\n      params = { select: '*' }\n    ) => {\n      const { attributes } = contentType;\n\n      const populate: any = {};\n\n      const entries: [string, any][] = Object.entries(attributes);\n\n      for (const [key, attribute] of entries) {\n        if (attribute.type === 'component') {\n          const component = strapi.getModel(attribute.component);\n          const subPopulate = getDeepPopulateComponentLikeQuery(component, params);\n\n          if ((isArray(subPopulate) || isObject(subPopulate)) && size(subPopulate) > 0) {\n            populate[key] = { ...params, populate: subPopulate };\n          }\n\n          if (isArray(subPopulate) && isEmpty(subPopulate)) {\n            populate[key] = { ...params };\n          }\n        }\n\n        if (attribute.type === 'dynamiczone') {\n          const { components: componentsUID } = attribute;\n\n          const on: any = {};\n\n          for (const componentUID of componentsUID) {\n            const component = strapi.getModel(componentUID);\n            const subPopulate = getDeepPopulateComponentLikeQuery(component, params);\n\n            if ((isArray(subPopulate) || isObject(subPopulate)) && size(subPopulate) > 0) {\n              on[componentUID] = { ...params, populate: subPopulate };\n            }\n\n            if (isArray(subPopulate) && isEmpty(subPopulate)) {\n              on[componentUID] = { ...params };\n            }\n          }\n\n          populate[key] = size(on) > 0 ? { on } : true;\n        }\n      }\n\n      const values = Object.values(populate);\n\n      if (values.every((value) => value === true)) {\n        return Object.keys(populate);\n      }\n\n      return populate;\n    };\n\n    return {\n      create,\n      createMany,\n      deleteMany,\n      getDeepPopulateComponentLikeQuery,\n\n      get deepPopulateComponentLikeQuery() {\n        const contentType = strapi.getModel(uid);\n\n        return getDeepPopulateComponentLikeQuery(contentType);\n      },\n    };\n  };\n\n  return query;\n};\n\nexport { createEntityQuery };\n","import type { Knex } from 'knex';\nimport { clone, isNil } from 'lodash/fp';\nimport type { Core } from '@strapi/types';\n\nimport { ILink } from '../../../types';\n\n// TODO: Remove any types when we'll have types for DB metadata\n\nexport const createLinkQuery = (strapi: Core.Strapi, trx?: Knex.Transaction) => {\n  const query = () => {\n    const { connection } = strapi.db;\n\n    // TODO: Export utils from database and use the addSchema that is already written\n    const addSchema = (tableName: string) => {\n      const schemaName = connection.client.connectionSettings.schema;\n      return schemaName ? `${schemaName}.${tableName}` : tableName;\n    };\n\n    async function* generateAllForAttribute(uid: string, fieldName: string): AsyncGenerator<ILink> {\n      const metadata = strapi.db.metadata.get(uid);\n\n      if (!metadata) {\n        throw new Error(`No metadata found for ${uid}`);\n      }\n\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\n\n      if (!(fieldName in attributes)) {\n        throw new Error(`${fieldName} is not a valid relational attribute name`);\n      }\n\n      const attribute = attributes[fieldName];\n\n      const kind = getLinkKind(attribute, uid);\n      const { relation, target } = attribute;\n\n      // The relation is stored in the same table\n      // TODO: handle manyToOne joinColumn\n      if (attribute.joinColumn) {\n        const joinColumnName: string = attribute.joinColumn.name;\n\n        const qb = connection\n          .queryBuilder()\n          .select('id', joinColumnName)\n          .from(addSchema(metadata.tableName));\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        // TODO: stream the query to improve performances\n        const entries = await qb;\n\n        for (const entry of entries) {\n          const ref = entry[joinColumnName];\n\n          if (ref !== null) {\n            yield {\n              kind,\n              relation,\n              left: { type: uid, ref: entry.id, field: fieldName },\n              right: { type: target, ref },\n            };\n          }\n        }\n      }\n\n      // The relation uses a join table\n      if (attribute.joinTable) {\n        const {\n          name,\n          joinColumn,\n          inverseJoinColumn,\n          orderColumnName,\n          morphColumn,\n          inverseOrderColumnName,\n        } = attribute.joinTable;\n\n        const qb = connection.queryBuilder().from(addSchema(name));\n\n        type Columns = {\n          left: { ref: string | null; order?: string };\n          right: { ref: string | null; order?: string; type?: string; field?: string };\n        };\n\n        const columns: Columns = {\n          left: { ref: null },\n          right: { ref: null },\n        };\n\n        const left: Partial<ILink['left']> = { type: uid, field: fieldName };\n        const right: Partial<ILink['right']> = {};\n\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\n          right.type = attribute.target;\n          right.field = attribute.inversedBy;\n\n          columns.left.ref = joinColumn.name;\n          columns.right.ref = inverseJoinColumn.name;\n\n          if (orderColumnName) {\n            columns.left.order = orderColumnName as string;\n          }\n\n          if (inverseOrderColumnName) {\n            columns.right.order = inverseOrderColumnName as string;\n          }\n        }\n\n        if (kind === 'relation.morph') {\n          columns.left.ref = joinColumn.name;\n\n          columns.right.ref = morphColumn.idColumn.name;\n          columns.right.type = morphColumn.typeColumn.name;\n          columns.right.field = 'field';\n          columns.right.order = 'order';\n        }\n\n        const validColumns = [\n          // Left\n          columns.left.ref,\n          columns.left.order,\n          // Right\n          columns.right.ref,\n          columns.right.type,\n          columns.right.field,\n          columns.right.order,\n        ].filter((column: string | null | undefined) => !isNil(column));\n\n        qb.select(validColumns);\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        // TODO: stream the query to improve performances\n        const entries = await qb;\n\n        for (const entry of entries) {\n          if (columns.left.ref) {\n            left.ref = entry[columns.left.ref];\n          }\n\n          if (columns.right.ref) {\n            right.ref = entry[columns.right.ref];\n          }\n\n          if (columns.left.order) {\n            left.pos = entry[columns.left.order as string];\n          }\n\n          if (columns.right.order) {\n            right.pos = entry[columns.right.order as string];\n          }\n\n          if (columns.right.type) {\n            right.type = entry[columns.right.type as string];\n          }\n\n          if (columns.right.field) {\n            right.field = entry[columns.right.field as string];\n          }\n\n          const link: ILink = {\n            kind,\n            relation,\n            left: clone(left as ILink['left']),\n            right: clone(right as ILink['right']),\n          };\n\n          yield link;\n        }\n      }\n\n      if (attribute.morphColumn) {\n        const { typeColumn, idColumn } = attribute.morphColumn;\n\n        const qb = connection\n          .queryBuilder()\n          .select('id', typeColumn.name, idColumn.name)\n          .from(addSchema(metadata.tableName))\n          .whereNotNull(typeColumn.name)\n          .whereNotNull(idColumn.name);\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        const entries = await qb;\n\n        for (const entry of entries) {\n          const ref = entry[idColumn.name];\n\n          yield {\n            kind,\n            relation,\n            left: { type: uid, ref: entry.id, field: fieldName },\n            right: { type: entry[typeColumn.name], ref },\n          };\n        }\n      }\n    }\n\n    async function* generateAll(uid: string): AsyncGenerator<ILink> {\n      const metadata = strapi.db.metadata.get(uid);\n\n      if (!metadata) {\n        throw new Error(`No metadata found for ${uid}`);\n      }\n\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\n\n      for (const fieldName of Object.keys(attributes)) {\n        for await (const link of generateAllForAttribute(uid, fieldName)) {\n          yield link;\n        }\n      }\n    }\n\n    const insert = async (link: ILink) => {\n      const { kind, left, right } = link;\n\n      const metadata = strapi.db.metadata.get(left.type);\n      const attribute = metadata.attributes[left.field];\n\n      const payload = {};\n\n      /**\n       * This _should_ only happen for attributes that are added dynamically e.g. review-workflow stages\n       * and a user is importing EE data into a CE project.\n       */\n      if (!attribute) {\n        return;\n      }\n\n      if (attribute.type !== 'relation') {\n        throw new Error(`Attribute ${left.field} is not a relation`);\n      }\n\n      if ('joinColumn' in attribute && attribute.joinColumn) {\n        const joinColumnName = attribute.joinColumn.name;\n\n        // Note: this addSchema may not be necessary, but is added for safety\n        const qb = connection(addSchema(metadata.tableName))\n          .where('id', left.ref)\n          .update({ [joinColumnName]: right.ref });\n        if (trx) {\n          qb.transacting(trx);\n        }\n        await qb;\n      }\n\n      if ('joinTable' in attribute && attribute.joinTable) {\n        const { joinTable } = attribute;\n\n        if (joinTable.joinColumn) {\n          Object.assign(payload, { [joinTable.joinColumn.name]: left.ref });\n        }\n\n        const assignInverseColumn = () => {\n          if ('inverseJoinColumn' in joinTable && joinTable.inverseJoinColumn) {\n            Object.assign(payload, {\n              [joinTable.inverseJoinColumn.name]: right.ref,\n            });\n          }\n        };\n\n        const assignOrderColumns = () => {\n          if ('orderColumnName' in joinTable && joinTable.orderColumnName) {\n            Object.assign(payload, { [joinTable.orderColumnName]: left.pos ?? null });\n          }\n\n          if ('inverseOrderColumnName' in joinTable && joinTable.inverseOrderColumnName) {\n            Object.assign(payload, { [joinTable.inverseOrderColumnName]: right.pos ?? null });\n          }\n        };\n\n        const assignMorphColumns = () => {\n          if ('morphColumn' in joinTable && joinTable.morphColumn) {\n            const { idColumn, typeColumn } = joinTable.morphColumn ?? {};\n\n            if (idColumn) {\n              Object.assign(payload, { [idColumn.name]: right.ref });\n            }\n\n            if (typeColumn) {\n              Object.assign(payload, { [typeColumn.name]: right.type });\n            }\n\n            Object.assign(payload, { order: right.pos ?? null, field: right.field ?? null });\n          }\n        };\n\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\n          assignInverseColumn();\n        }\n\n        if (kind === 'relation.morph') {\n          assignMorphColumns();\n        }\n\n        assignOrderColumns();\n        const qb = connection.insert(payload).into(addSchema(joinTable.name));\n        if (trx) {\n          await trx.transaction(async (nestedTrx) => {\n            await qb.transacting(nestedTrx);\n          });\n        }\n      }\n\n      if ('morphColumn' in attribute && attribute.morphColumn) {\n        const { morphColumn } = attribute;\n\n        const qb = connection(addSchema(metadata.tableName))\n          .where('id', left.ref)\n          .update({\n            [morphColumn.idColumn.name]: right.ref,\n            [morphColumn.typeColumn.name]: right.type,\n          });\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        await qb;\n      }\n    };\n\n    return { generateAll, generateAllForAttribute, insert };\n  };\n\n  return query;\n};\n\nexport const filterValidRelationalAttributes = (attributes: Record<string, any>) => {\n  const isOwner = (attribute: any) => {\n    return attribute.owner || (!attribute.mappedBy && !attribute.morphBy);\n  };\n\n  const isComponentLike = (attribute: any) => attribute.joinTable?.name.endsWith('_cmps');\n\n  return Object.entries(attributes)\n    .filter(([, attribute]) => {\n      return attribute.type === 'relation' && isOwner(attribute) && !isComponentLike(attribute);\n    })\n    .reduce<Record<string, any>>((acc, [key, attribute]) => ({ ...acc, [key]: attribute }), {});\n};\n\nconst getLinkKind = (attribute: any, uid: string): ILink['kind'] => {\n  if (attribute.relation.startsWith('morph')) {\n    return 'relation.morph';\n  }\n\n  if (attribute.target === uid) {\n    return 'relation.circular';\n  }\n\n  return 'relation.basic';\n};\n","import { Writable } from 'stream';\nimport type { Core, UID } from '@strapi/types';\n\nimport { last } from 'lodash/fp';\n\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport type { IEntity, Transaction } from '../../../../../../types';\nimport { json } from '../../../../../utils';\nimport * as queries from '../../../../queries';\nimport { resolveComponentUID } from '../../../../../utils/components';\n\ninterface IEntitiesRestoreStreamOptions {\n  strapi: Core.Strapi;\n  updateMappingTable<TSchemaUID extends UID.Schema>(\n    type: TSchemaUID,\n    oldID: number,\n    newID: number\n  ): void;\n  transaction?: Transaction;\n}\n\nexport const createEntitiesWriteStream = (options: IEntitiesRestoreStreamOptions) => {\n  const { strapi, updateMappingTable, transaction } = options;\n  const query = queries.entity.createEntityQuery(strapi);\n\n  return new Writable({\n    objectMode: true,\n\n    async write(entity: IEntity, _encoding, callback) {\n      await transaction?.attach(async () => {\n        const { type, id, data } = entity;\n        const { create, getDeepPopulateComponentLikeQuery } = query(type);\n        const contentType = strapi.getModel(type);\n\n        try {\n          const created = await create({\n            data,\n            populate: getDeepPopulateComponentLikeQuery(contentType, { select: 'id' }),\n            select: 'id',\n          });\n\n          // Compute differences between original & new entities\n          const diffs = json.diff(data, created);\n\n          updateMappingTable(type, id, created.id);\n\n          // For each difference found on an ID attribute,\n          // update the mapping the table accordingly\n          diffs.forEach((diff) => {\n            if (diff.kind === 'modified' && last(diff.path) === 'id' && 'kind' in contentType) {\n              const target = resolveComponentUID({ paths: diff.path, data, contentType, strapi });\n\n              // If no type is found for the given path, then ignore the diff\n              if (!target) {\n                return;\n              }\n\n              const [oldID, newID] = diff.values as [number, number];\n\n              updateMappingTable(target, oldID, newID);\n            }\n          });\n        } catch (e) {\n          if (e instanceof Error) {\n            return callback(e);\n          }\n\n          return callback(new ProviderTransferError(`Failed to create \"${type}\" (${id})`));\n        }\n\n        return callback(null);\n      });\n    },\n  });\n};\n","import { Writable } from 'stream';\nimport { omit } from 'lodash/fp';\nimport chalk from 'chalk';\nimport type { Core } from '@strapi/types';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport { IConfiguration, Transaction } from '../../../../../../types';\n\nconst omitInvalidCreationAttributes = omit(['id']);\n\nconst restoreCoreStore = async <T extends { value: unknown }>(strapi: Core.Strapi, values: T) => {\n  const data = omitInvalidCreationAttributes(values);\n  return strapi.db.query('strapi::core-store').create({\n    data: {\n      ...data,\n      value: JSON.stringify(data.value),\n    },\n  });\n};\n\nconst restoreWebhooks = async <T extends { value: unknown }>(strapi: Core.Strapi, values: T) => {\n  const data = omitInvalidCreationAttributes(values);\n  return strapi.db.query('strapi::webhook').create({ data });\n};\n\nexport const restoreConfigs = async (strapi: Core.Strapi, config: IConfiguration) => {\n  if (config.type === 'core-store') {\n    return restoreCoreStore(strapi, config.value as { value: unknown });\n  }\n\n  if (config.type === 'webhook') {\n    return restoreWebhooks(strapi, config.value as { value: unknown });\n  }\n};\n\nexport const createConfigurationWriteStream = async (\n  strapi: Core.Strapi,\n  transaction?: Transaction\n) => {\n  return new Writable({\n    objectMode: true,\n    async write<T extends { id: number }>(\n      config: IConfiguration<T>,\n      _encoding: BufferEncoding,\n      callback: (error?: Error | null) => void\n    ) {\n      await transaction?.attach(async () => {\n        try {\n          await restoreConfigs(strapi, config);\n        } catch (error) {\n          return callback(\n            new ProviderTransferError(\n              `Failed to import ${chalk.yellowBright(config.type)} (${chalk.greenBright(\n                config.value.id\n              )}`\n            )\n          );\n        }\n        callback();\n      });\n    },\n  });\n};\n","import { Writable } from 'stream';\nimport type { Core } from '@strapi/types';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport { ILink, Transaction } from '../../../../../../types';\nimport { createLinkQuery } from '../../../../queries/link';\n\ninterface ErrorWithCode extends Error {\n  code: string;\n}\n\nconst isErrorWithCode = (error: any): error is ErrorWithCode => {\n  return error && typeof error.code === 'string';\n};\n\nconst isForeignKeyConstraintError = (e: Error) => {\n  const MYSQL_FK_ERROR_CODES = ['1452', '1557', '1216', '1217', '1451'];\n  const POSTGRES_FK_ERROR_CODE = '23503';\n  const SQLITE_FK_ERROR_CODE = 'SQLITE_CONSTRAINT_FOREIGNKEY';\n\n  if (isErrorWithCode(e) && e.code) {\n    return [SQLITE_FK_ERROR_CODE, POSTGRES_FK_ERROR_CODE, ...MYSQL_FK_ERROR_CODES].includes(e.code);\n  }\n\n  return e.message.toLowerCase().includes('foreign key constraint');\n};\n\nexport const createLinksWriteStream = (\n  mapID: (uid: string, id: number) => number | undefined,\n  strapi: Core.Strapi,\n  transaction?: Transaction,\n  onWarning?: (message: string) => void\n) => {\n  return new Writable({\n    objectMode: true,\n    async write(link: ILink, _encoding, callback) {\n      await transaction?.attach(async (trx) => {\n        const { left, right } = link;\n        const query = createLinkQuery(strapi, trx);\n\n        const originalLeftRef = left.ref;\n        const originalRightRef = right.ref;\n\n        // Map IDs if needed\n        left.ref = mapID(left.type, originalLeftRef) ?? originalLeftRef;\n        right.ref = mapID(right.type, originalRightRef) ?? originalRightRef;\n\n        try {\n          await query().insert(link);\n        } catch (e) {\n          if (e instanceof Error) {\n            if (isForeignKeyConstraintError(e)) {\n              onWarning?.(\n                `Skipping link ${left.type}:${originalLeftRef} -> ${right.type}:${originalRightRef} due to a foreign key constraint.`\n              );\n              return callback(null);\n            }\n            return callback(e);\n          }\n\n          return callback(\n            new ProviderTransferError(\n              `An error happened while trying to import a ${left.type} link.`\n            )\n          );\n        }\n\n        callback(null);\n      });\n    },\n  });\n};\n","import type { Core, UID, Struct } from '@strapi/types';\nimport type { Model } from '@strapi/database';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport * as queries from '../../../../queries';\n\nexport interface IRestoreOptions {\n  assets?: boolean; // delete media library files before transfer\n  configuration?: {\n    webhook?: boolean; // delete webhooks before transfer\n    coreStore?: boolean; // delete core store before transfer\n  };\n  entities?: {\n    include?: string[]; // only delete these stage entities before transfer\n    exclude?: string[]; // exclude these stage entities from deletion\n    filters?: ((contentType: Struct.ContentTypeSchema) => boolean)[]; // custom filters to exclude a content type from deletion\n    params?: { [uid: string]: unknown }; // params object passed to deleteMany before transfer for custom deletions\n  };\n}\n\ninterface IDeleteResults {\n  count: number;\n  aggregate: { [uid: string]: { count: number } };\n}\n\nexport const deleteRecords = async (strapi: Core.Strapi, options: IRestoreOptions) => {\n  const entities = await deleteEntitiesRecords(strapi, options);\n  const configuration = await deleteConfigurationRecords(strapi, options);\n\n  return {\n    count: entities.count + configuration.count,\n    entities,\n    configuration,\n  };\n};\n\nconst deleteEntitiesRecords = async (\n  strapi: Core.Strapi,\n  options: IRestoreOptions = {}\n): Promise<IDeleteResults> => {\n  const { entities } = options;\n\n  const models = strapi.get('models').get() as Model[];\n  const contentTypes = Object.values(strapi.contentTypes) as Struct.ContentTypeSchema[];\n\n  const contentTypesToClear = contentTypes\n    .filter((contentType) => {\n      let removeThisContentType = true;\n\n      // include means \"only include these types\" so if it's not in here, it's not being included\n      if (entities?.include) {\n        removeThisContentType = entities.include.includes(contentType.uid);\n      }\n\n      // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept\n      if (entities?.exclude && entities.exclude.includes(contentType.uid)) {\n        removeThisContentType = false;\n      }\n\n      if (entities?.filters) {\n        removeThisContentType = entities.filters.every((filter) => filter(contentType));\n      }\n\n      return removeThisContentType;\n    })\n    .map((contentType) => contentType.uid);\n\n  const modelsToClear = models\n    .filter((model) => {\n      if (contentTypesToClear.includes(model.uid as UID.ContentType)) {\n        return false;\n      }\n\n      let removeThisModel = true;\n\n      // include means \"only include these types\" so if it's not in here, it's not being included\n      if (entities?.include) {\n        removeThisModel = entities.include.includes(model.uid);\n      }\n\n      // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept\n      if (entities?.exclude && entities.exclude.includes(model.uid)) {\n        removeThisModel = false;\n      }\n\n      return removeThisModel;\n    })\n    .map((model) => model.uid);\n\n  const [results, updateResults] = useResults([...contentTypesToClear, ...modelsToClear]);\n\n  const contentTypeQuery = queries.entity.createEntityQuery(strapi);\n\n  const contentTypePromises = contentTypesToClear.map(async (uid) => {\n    const result = await contentTypeQuery(uid).deleteMany(entities?.params);\n\n    if (result) {\n      updateResults(result.count || 0, uid);\n    }\n  });\n\n  const modelsPromises = modelsToClear.map(async (uid) => {\n    const result = await strapi.db.query(uid).deleteMany({});\n\n    if (result) {\n      updateResults(result.count || 0, uid);\n    }\n  });\n\n  await Promise.all([...contentTypePromises, ...modelsPromises]);\n\n  return results;\n};\n\nconst deleteConfigurationRecords = async (\n  strapi: Core.Strapi,\n  options: IRestoreOptions = {}\n): Promise<IDeleteResults> => {\n  const { coreStore = true, webhook = true } = options?.configuration ?? {};\n\n  const models: string[] = [];\n\n  if (coreStore) {\n    models.push('strapi::core-store');\n  }\n\n  if (webhook) {\n    models.push('strapi::webhook');\n  }\n\n  const [results, updateResults] = useResults(models);\n\n  const deletePromises = models.map(async (uid) => {\n    const result = await strapi.db.query(uid).deleteMany({});\n\n    if (result) {\n      updateResults(result.count, uid);\n    }\n  });\n\n  await Promise.all(deletePromises);\n\n  return results;\n};\n\nconst useResults = (\n  keys: string[]\n): [IDeleteResults, (count: number, key?: string) => void | never] => {\n  const results: IDeleteResults = {\n    count: 0,\n    aggregate: keys.reduce((acc, key) => ({ ...acc, [key]: { count: 0 } }), {}),\n  };\n\n  const update = (count: number, key?: string) => {\n    if (key) {\n      if (!(key in results.aggregate)) {\n        throw new ProviderTransferError(`Unknown key \"${key}\" provided in results update`);\n      }\n\n      results.aggregate[key].count += count;\n    }\n\n    results.count += count;\n  };\n\n  return [results, update];\n};\n\nexport * from './entities';\nexport * from './configuration';\nexport * from './links';\n","import type { Core } from '@strapi/types';\n\nimport { ProviderInitializationError } from '../errors/providers';\n\nexport type ValidStrapiAssertion = (strapi: unknown, msg?: string) => asserts strapi is Core.Strapi;\n\nexport const assertValidStrapi: ValidStrapiAssertion = (strapi?: unknown, msg = '') => {\n  if (!strapi) {\n    throw new ProviderInitializationError(`${msg}. Strapi instance not found.`);\n  }\n};\n","import { Writable, Readable } from 'stream';\nimport path from 'path';\nimport * as fse from 'fs-extra';\nimport type { Knex } from 'knex';\nimport type { Core, Struct } from '@strapi/types';\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IFile,\n  IMetadata,\n  ProviderType,\n  Transaction,\n} from '../../../../types';\n\nimport { restore } from './strategies';\nimport * as utils from '../../../utils';\nimport {\n  ProviderInitializationError,\n  ProviderTransferError,\n  ProviderValidationError,\n} from '../../../errors/providers';\nimport { assertValidStrapi } from '../../../utils/providers';\n\nexport const VALID_CONFLICT_STRATEGIES = ['restore'];\nexport const DEFAULT_CONFLICT_STRATEGY = 'restore';\n\nexport interface ILocalStrapiDestinationProviderOptions {\n  getStrapi(): Core.Strapi | Promise<Core.Strapi>; // return an initialized instance of Strapi\n\n  autoDestroy?: boolean; // shut down the instance returned by getStrapi() at the end of the transfer\n  restore?: restore.IRestoreOptions; // erase data in strapi database before transfer; required if strategy is 'restore'\n  strategy: 'restore'; // conflict management strategy; only the restore strategy is available at this time\n}\n\nclass LocalStrapiDestinationProvider implements IDestinationProvider {\n  name = 'destination::local-strapi';\n\n  type: ProviderType = 'destination';\n\n  options: ILocalStrapiDestinationProviderOptions;\n\n  strapi?: Core.Strapi;\n\n  transaction?: Transaction;\n\n  uploadsBackupDirectoryName: string;\n\n  onWarning?: ((message: string) => void) | undefined;\n\n  /**\n   * The entities mapper is used to map old entities to their new IDs\n   */\n  #entitiesMapper: { [type: string]: { [id: number]: number } };\n\n  constructor(options: ILocalStrapiDestinationProviderOptions) {\n    this.options = options;\n    this.#entitiesMapper = {};\n    this.uploadsBackupDirectoryName = `uploads_backup_${Date.now()}`;\n  }\n\n  async bootstrap(): Promise<void> {\n    this.#validateOptions();\n    this.strapi = await this.options.getStrapi();\n    if (!this.strapi) {\n      throw new ProviderInitializationError('Could not access local strapi');\n    }\n\n    this.transaction = utils.transaction.createTransaction(this.strapi);\n  }\n\n  // TODO: either move this to restore strategy, or restore strategy should given access to these instead of repeating the logic possibly in a different way\n  #areAssetsIncluded = () => {\n    return this.options.restore?.assets;\n  };\n\n  #isContentTypeIncluded = (type: string) => {\n    const notIncluded =\n      this.options.restore?.entities?.include &&\n      !this.options.restore?.entities?.include?.includes(type);\n    const excluded =\n      this.options.restore?.entities?.exclude &&\n      this.options.restore?.entities.exclude.includes(type);\n\n    return !excluded && !notIncluded;\n  };\n\n  async close(): Promise<void> {\n    const { autoDestroy } = this.options;\n    this.transaction?.end();\n\n    // Basically `!== false` but more deterministic\n    if (autoDestroy === undefined || autoDestroy === true) {\n      await this.strapi?.destroy();\n    }\n  }\n\n  #validateOptions() {\n    if (!VALID_CONFLICT_STRATEGIES.includes(this.options.strategy)) {\n      throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {\n        check: 'strategy',\n        strategy: this.options.strategy,\n        validStrategies: VALID_CONFLICT_STRATEGIES,\n      });\n    }\n\n    // require restore options when using restore\n    if (this.options.strategy === 'restore' && !this.options.restore) {\n      throw new ProviderValidationError('Missing restore options');\n    }\n  }\n\n  async #deleteFromRestoreOptions() {\n    assertValidStrapi(this.strapi);\n    if (!this.options.restore) {\n      throw new ProviderValidationError('Missing restore options');\n    }\n    return restore.deleteRecords(this.strapi, this.options.restore);\n  }\n\n  async #deleteAllAssets(trx?: Knex.Transaction) {\n    assertValidStrapi(this.strapi);\n\n    // if we're not restoring files, don't touch the files\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n\n    const stream: Readable = this.strapi.db\n      // Create a query builder instance (default type is 'select')\n      .queryBuilder('plugin::upload.file')\n      // Fetch all columns\n      .select('*')\n      // Attach the transaction\n      .transacting(trx)\n      // Get a readable stream\n      .stream();\n\n    // TODO use bulk delete when exists in providers\n    for await (const file of stream) {\n      await this.strapi.plugin('upload').provider.delete(file);\n      if (file.formats) {\n        for (const fileFormat of Object.values(file.formats)) {\n          await this.strapi.plugin('upload').provider.delete(fileFormat);\n        }\n      }\n    }\n  }\n\n  async rollback() {\n    await this.transaction?.rollback();\n  }\n\n  async beforeTransfer() {\n    if (!this.strapi) {\n      throw new Error('Strapi instance not found');\n    }\n\n    await this.transaction?.attach(async (trx) => {\n      try {\n        if (this.options.strategy === 'restore') {\n          await this.#handleAssetsBackup();\n          await this.#deleteAllAssets(trx);\n          await this.#deleteFromRestoreOptions();\n        }\n      } catch (error) {\n        throw new Error(`restore failed ${error}`);\n      }\n    });\n  }\n\n  getMetadata(): IMetadata {\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n    const strapiVersion = this.strapi.config.get<string>('info.strapi');\n    const createdAt = new Date().toISOString();\n\n    return {\n      createdAt,\n      strapi: {\n        version: strapiVersion,\n      },\n    };\n  }\n\n  getSchemas(): Record<string, Struct.Schema> {\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n\n    const schemas = utils.schema.schemasToValidJSON({\n      ...this.strapi.contentTypes,\n      ...this.strapi.components,\n    });\n\n    return utils.schema.mapSchemasValues(schemas);\n  }\n\n  createEntitiesWriteStream(): Writable {\n    assertValidStrapi(this.strapi, 'Not able to import entities');\n    const { strategy } = this.options;\n\n    const updateMappingTable = (type: string, oldID: number, newID: number) => {\n      if (!this.#entitiesMapper[type]) {\n        this.#entitiesMapper[type] = {};\n      }\n\n      Object.assign(this.#entitiesMapper[type], { [oldID]: newID });\n    };\n\n    if (strategy === 'restore') {\n      return restore.createEntitiesWriteStream({\n        strapi: this.strapi,\n        updateMappingTable,\n        transaction: this.transaction,\n      });\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {\n      check: 'strategy',\n      strategy: this.options.strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n\n  async #handleAssetsBackup() {\n    assertValidStrapi(this.strapi, 'Not able to create the assets backup');\n\n    // if we're not restoring assets, don't back them up because they won't be touched\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n\n    if (this.strapi.config.get<{ provider: string }>('plugin::upload').provider === 'local') {\n      const assetsDirectory = path.join(this.strapi.dirs.static.public, 'uploads');\n      const backupDirectory = path.join(\n        this.strapi.dirs.static.public,\n        this.uploadsBackupDirectoryName\n      );\n\n      try {\n        // Check access before attempting to do anything\n        await fse.access(\n          assetsDirectory,\n          // eslint-disable-next-line no-bitwise\n          fse.constants.W_OK | fse.constants.R_OK | fse.constants.F_OK\n        );\n        // eslint-disable-next-line no-bitwise\n        await fse.access(path.join(assetsDirectory, '..'), fse.constants.W_OK | fse.constants.R_OK);\n\n        await fse.move(assetsDirectory, backupDirectory);\n        await fse.mkdir(assetsDirectory);\n        // Create a .gitkeep file to ensure the directory is not empty\n        await fse.outputFile(path.join(assetsDirectory, '.gitkeep'), '');\n      } catch (err) {\n        throw new ProviderTransferError(\n          'The backup folder for the assets could not be created inside the public folder. Please ensure Strapi has write permissions on the public directory',\n          {\n            code: 'ASSETS_DIRECTORY_ERR',\n          }\n        );\n      }\n      return backupDirectory;\n    }\n  }\n\n  async #removeAssetsBackup() {\n    assertValidStrapi(this.strapi, 'Not able to remove Assets');\n    // if we're not restoring assets, don't back them up because they won't be touched\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n\n    // TODO: this should catch all thrown errors and bubble it up to engine so it can be reported as a non-fatal diagnostic message telling the user they may need to manually delete assets\n    if (this.strapi.config.get<{ provider: string }>('plugin::upload').provider === 'local') {\n      assertValidStrapi(this.strapi);\n      const backupDirectory = path.join(\n        this.strapi.dirs.static.public,\n        this.uploadsBackupDirectoryName\n      );\n      await fse.rm(backupDirectory, { recursive: true, force: true });\n    }\n  }\n\n  // TODO: Move this logic to the restore strategy\n  async createAssetsWriteStream(): Promise<Writable> {\n    assertValidStrapi(this.strapi, 'Not able to stream Assets');\n\n    if (!this.#areAssetsIncluded()) {\n      throw new ProviderTransferError(\n        'Attempting to transfer assets when `assets` is not set in restore options'\n      );\n    }\n\n    const removeAssetsBackup = this.#removeAssetsBackup.bind(this);\n    const strapi = this.strapi;\n    const transaction = this.transaction;\n    const backupDirectory = this.uploadsBackupDirectoryName;\n    const fileEntitiesMapper = this.#entitiesMapper['plugin::upload.file'];\n\n    const restoreMediaEntitiesContent = this.#isContentTypeIncluded('plugin::upload.file');\n\n    return new Writable({\n      objectMode: true,\n      async final(next) {\n        // Delete the backup folder\n        await removeAssetsBackup();\n        next();\n      },\n      async write(chunk: IAsset, _encoding, callback) {\n        await transaction?.attach(async () => {\n          // TODO: Remove this logic in V5\n          if (!chunk.metadata) {\n            // If metadata does not exist is because it is an old backup file\n            const assetsDirectory = path.join(strapi.dirs.static.public, 'uploads');\n            const entryPath = path.join(assetsDirectory, chunk.filename);\n            const writableStream = fse.createWriteStream(entryPath);\n            chunk.stream\n              .pipe(writableStream)\n              .on('close', () => {\n                callback(null);\n              })\n              .on('error', async (error: NodeJS.ErrnoException) => {\n                const errorMessage =\n                  error.code === 'ENOSPC'\n                    ? \" Your server doesn't have space to proceed with the import. \"\n                    : ' ';\n\n                try {\n                  await fse.rm(assetsDirectory, { recursive: true, force: true });\n                  this.destroy(\n                    new ProviderTransferError(\n                      `There was an error during the transfer process.${errorMessage}The original files have been restored to ${assetsDirectory}`\n                    )\n                  );\n                } catch (err) {\n                  throw new ProviderTransferError(\n                    `There was an error doing the rollback process. The original files are in ${backupDirectory}, but we failed to restore them to ${assetsDirectory}`\n                  );\n                } finally {\n                  callback(error);\n                }\n              });\n            return;\n          }\n\n          const uploadData = {\n            ...chunk.metadata,\n            stream: Readable.from(chunk.stream),\n            buffer: chunk?.buffer,\n          };\n\n          const provider = strapi.config.get<{ provider: string }>('plugin::upload').provider;\n\n          try {\n            await strapi.plugin('upload').provider.uploadStream(uploadData);\n\n            // if we're not supposed to transfer the associated entities, stop here\n            if (!restoreMediaEntitiesContent) {\n              return callback();\n            }\n\n            // Files formats are stored within the parent file entity\n            if (uploadData?.type) {\n              // Support usage of main hash for older versions\n              const condition = uploadData?.id\n                ? { id: fileEntitiesMapper[uploadData.id] }\n                : { hash: uploadData.mainHash };\n              const entry: IFile = await strapi.db.query('plugin::upload.file').findOne({\n                where: condition,\n              });\n              const specificFormat = entry?.formats?.[uploadData.type];\n              if (specificFormat) {\n                specificFormat.url = uploadData.url;\n              }\n              await strapi.db.query('plugin::upload.file').update({\n                where: { id: entry.id },\n                data: {\n                  formats: entry.formats,\n                  provider,\n                },\n              });\n              return callback();\n            }\n            const entry: IFile = await strapi.db.query('plugin::upload.file').findOne({\n              where: { id: fileEntitiesMapper[uploadData.id] },\n            });\n            entry.url = uploadData.url;\n            await strapi.db.query('plugin::upload.file').update({\n              where: { id: entry.id },\n              data: {\n                url: entry.url,\n                provider,\n              },\n            });\n            callback();\n          } catch (error) {\n            callback(new Error(`Error while uploading asset ${chunk.filename} ${error}`));\n          }\n        });\n      },\n    });\n  }\n\n  async createConfigurationWriteStream(): Promise<Writable> {\n    assertValidStrapi(this.strapi, 'Not able to stream Configurations');\n\n    const { strategy } = this.options;\n\n    if (strategy === 'restore') {\n      return restore.createConfigurationWriteStream(this.strapi, this.transaction);\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${strategy}`, {\n      check: 'strategy',\n      strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n\n  async createLinksWriteStream(): Promise<Writable> {\n    if (!this.strapi) {\n      throw new Error('Not able to stream links. Strapi instance not found');\n    }\n\n    const { strategy } = this.options;\n    const mapID = (uid: string, id: number): number | undefined => this.#entitiesMapper[uid]?.[id];\n\n    if (strategy === 'restore') {\n      return restore.createLinksWriteStream(mapID, this.strapi, this.transaction, this.onWarning);\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${strategy}`, {\n      check: 'strategy',\n      strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n}\n\nexport const createLocalStrapiDestinationProvider = (\n  options: ILocalStrapiDestinationProviderOptions\n) => {\n  return new LocalStrapiDestinationProvider(options);\n};\n","import { Readable, Transform } from 'stream';\nimport type { Core, Struct } from '@strapi/types';\n\nimport * as shared from '../../queries';\nimport { IEntity } from '../../../../types';\n\n/**\n * Generate and consume content-types streams in order to stream each entity individually\n */\nexport const createEntitiesStream = (strapi: Core.Strapi): Readable => {\n  const contentTypes: Struct.ContentTypeSchema[] = Object.values(strapi.contentTypes);\n\n  async function* contentTypeStreamGenerator() {\n    for (const contentType of contentTypes) {\n      const query = shared.entity.createEntityQuery(strapi).call(null, contentType.uid);\n\n      const stream: Readable = strapi.db\n        // Create a query builder instance (default type is 'select')\n        .queryBuilder(contentType.uid)\n        // Fetch all columns\n        .select('*')\n        // Apply the populate\n        .populate(query.deepPopulateComponentLikeQuery)\n        // Get a readable stream\n        .stream();\n\n      yield { contentType, stream };\n    }\n  }\n\n  return Readable.from(\n    (async function* entitiesGenerator(): AsyncGenerator<{\n      entity: IEntity;\n      contentType: Struct.ContentTypeSchema;\n    }> {\n      for await (const { stream, contentType } of contentTypeStreamGenerator()) {\n        try {\n          for await (const entity of stream) {\n            yield { entity, contentType };\n          }\n        } catch {\n          // ignore\n        } finally {\n          stream.destroy();\n        }\n      }\n    })()\n  );\n};\n\n/**\n * Create an entity transform stream which convert the output of\n * the multi-content-types stream to the transfer entity format\n */\nexport const createEntitiesTransformStream = (): Transform => {\n  return new Transform({\n    objectMode: true,\n    transform(data, _encoding, callback) {\n      const { entity, contentType } = data;\n      const { id, ...attributes } = entity;\n\n      callback(null, {\n        type: contentType.uid,\n        id,\n        data: attributes,\n      });\n    },\n  });\n};\n","import { Readable } from 'stream';\nimport type { Core } from '@strapi/types';\n\nimport type { ILink } from '../../../../types';\nimport { createLinkQuery } from '../../queries/link';\n\n/**\n * Create a Readable which will stream all the links from a Strapi instance\n */\nexport const createLinksStream = (strapi: Core.Strapi): Readable => {\n  const uids = [...Object.keys(strapi.contentTypes), ...Object.keys(strapi.components)] as string[];\n\n  // Async generator stream that returns every link from a Strapi instance\n  return Readable.from(\n    (async function* linkGenerator(): AsyncGenerator<ILink> {\n      const query = createLinkQuery(strapi);\n\n      for (const uid of uids) {\n        const generator = query().generateAll(uid);\n\n        for await (const link of generator) {\n          yield link;\n        }\n      }\n    })()\n  );\n};\n","import { Readable } from 'stream';\nimport { chain } from 'stream-chain';\nimport { set } from 'lodash/fp';\nimport type { Core } from '@strapi/types';\n\nimport type { IConfiguration } from '../../../../types';\n\n/**\n * Create a readable stream that export the Strapi app configuration\n */\nexport const createConfigurationStream = (strapi: Core.Strapi): Readable => {\n  return Readable.from(\n    (async function* configurationGenerator(): AsyncGenerator<IConfiguration> {\n      // Core Store\n      const coreStoreStream = chain([\n        strapi.db.queryBuilder('strapi::core-store').stream(),\n        (data) => set('value', JSON.parse(data.value), data),\n        wrapConfigurationItem('core-store'),\n      ]);\n\n      // Webhook\n      const webhooksStream = chain([\n        strapi.db.queryBuilder('strapi::webhook').stream(),\n        wrapConfigurationItem('webhook'),\n      ]);\n\n      const streams = [coreStoreStream, webhooksStream];\n\n      for (const stream of streams) {\n        for await (const item of stream) {\n          yield item;\n        }\n      }\n    })()\n  );\n};\n\nconst wrapConfigurationItem = (type: 'core-store' | 'webhook') => (value: unknown) => ({\n  type,\n  value,\n});\n","import { join } from 'path';\nimport { Duplex, PassThrough, Readable } from 'stream';\nimport * as webStream from 'stream/web';\nimport { stat, createReadStream, ReadStream } from 'fs-extra';\nimport type { Core } from '@strapi/types';\n\nimport type { IAsset, IFile } from '../../../../types';\n\nfunction getFileStream(\n  filepath: string,\n  strapi: Core.Strapi,\n  isLocal = false\n): PassThrough | ReadStream {\n  if (isLocal) {\n    // Todo: handle errors\n    return createReadStream(filepath);\n  }\n\n  const readableStream = new PassThrough();\n\n  // fetch the image from remote url and stream it\n  strapi\n    .fetch(filepath)\n    .then((res: Response) => {\n      if (res.status !== 200) {\n        readableStream.emit('error', new Error(`Request failed with status code ${res.status}`));\n        return;\n      }\n\n      if (res.body) {\n        // pipe the image data\n        Readable.fromWeb(new webStream.ReadableStream(res.body)).pipe(readableStream);\n      } else {\n        readableStream.emit('error', new Error('Empty data found for file'));\n      }\n    })\n    .catch((error: unknown) => {\n      readableStream.emit('error', error);\n    });\n\n  return readableStream;\n}\n\nfunction getFileStats(\n  filepath: string,\n  strapi: Core.Strapi,\n  isLocal = false\n): Promise<{ size: number }> {\n  if (isLocal) {\n    return stat(filepath);\n  }\n  return new Promise((resolve, reject) => {\n    strapi\n      .fetch(filepath)\n      .then((res: Response) => {\n        if (res.status !== 200) {\n          reject(new Error(`Request failed with status code ${res.status}`));\n          return;\n        }\n\n        const contentLength = res.headers.get('content-length');\n        const stats = {\n          size: contentLength ? parseInt(contentLength, 10) : 0,\n        };\n\n        resolve(stats);\n      })\n      .catch((error: unknown) => {\n        reject(error);\n      });\n  });\n}\n\nasync function signFile(file: IFile) {\n  const { provider } = strapi.plugins.upload;\n  const { provider: providerName } = strapi.config.get('plugin.upload') as { provider: string };\n  const isPrivate = await provider.isPrivate();\n  if (file?.provider === providerName && isPrivate) {\n    const signUrl = async (file: IFile) => {\n      const signedUrl = await provider.getSignedUrl(file);\n      file.url = signedUrl.url;\n    };\n\n    // Sign the original file\n    await signUrl(file);\n    // Sign each file format\n    if (file.formats) {\n      for (const format of Object.keys(file.formats)) {\n        await signUrl(file.formats[format]);\n      }\n    }\n  }\n}\n\n/**\n * Generate and consume assets streams in order to stream each file individually\n */\nexport const createAssetsStream = (strapi: Core.Strapi): Duplex => {\n  const generator: () => AsyncGenerator<IAsset, void> = async function* () {\n    const stream: Readable = strapi.db\n      .queryBuilder('plugin::upload.file')\n      // Create a query builder instance (default type is 'select')\n      // Fetch all columns\n      .select('*')\n      // Get a readable stream\n      .stream();\n\n    for await (const file of stream) {\n      const isLocalProvider = file.provider === 'local';\n      if (!isLocalProvider) {\n        await signFile(file);\n      }\n      const filepath = isLocalProvider ? join(strapi.dirs.static.public, file.url) : file.url;\n      const stats = await getFileStats(filepath, strapi, isLocalProvider);\n      const stream = getFileStream(filepath, strapi, isLocalProvider);\n\n      yield {\n        metadata: file,\n        filepath,\n        filename: file.hash + file.ext,\n        stream,\n        stats: { size: stats.size },\n      };\n\n      if (file.formats) {\n        for (const format of Object.keys(file.formats)) {\n          const fileFormat = file.formats[format];\n          const fileFormatFilepath = isLocalProvider\n            ? join(strapi.dirs.static.public, fileFormat.url)\n            : fileFormat.url;\n          const fileFormatStats = await getFileStats(fileFormatFilepath, strapi, isLocalProvider);\n          const fileFormatStream = getFileStream(fileFormatFilepath, strapi, isLocalProvider);\n          const metadata = { ...fileFormat, type: format, id: file.id, mainHash: file.hash };\n          yield {\n            metadata,\n            filepath: fileFormatFilepath,\n            filename: fileFormat.hash + fileFormat.ext,\n            stream: fileFormatStream,\n            stats: { size: fileFormatStats.size },\n          };\n        }\n      }\n    }\n  };\n\n  return Duplex.from(generator());\n};\n","import { Readable } from 'stream';\nimport { chain } from 'stream-chain';\nimport type { Core, Struct } from '@strapi/types';\n\nimport type { IMetadata, ISourceProvider, ProviderType } from '../../../../types';\nimport { createEntitiesStream, createEntitiesTransformStream } from './entities';\nimport { createLinksStream } from './links';\nimport { createConfigurationStream } from './configuration';\nimport { createAssetsStream } from './assets';\nimport * as utils from '../../../utils';\nimport { assertValidStrapi } from '../../../utils/providers';\n\nexport interface ILocalStrapiSourceProviderOptions {\n  getStrapi(): Core.Strapi | Promise<Core.Strapi>; // return an initialized instance of Strapi\n\n  autoDestroy?: boolean; // shut down the instance returned by getStrapi() at the end of the transfer\n}\n\nexport const createLocalStrapiSourceProvider = (options: ILocalStrapiSourceProviderOptions) => {\n  return new LocalStrapiSourceProvider(options);\n};\n\nclass LocalStrapiSourceProvider implements ISourceProvider {\n  name = 'source::local-strapi';\n\n  type: ProviderType = 'source';\n\n  options: ILocalStrapiSourceProviderOptions;\n\n  strapi?: Core.Strapi;\n\n  constructor(options: ILocalStrapiSourceProviderOptions) {\n    this.options = options;\n  }\n\n  async bootstrap(): Promise<void> {\n    this.strapi = await this.options.getStrapi();\n  }\n\n  async close(): Promise<void> {\n    const { autoDestroy } = this.options;\n\n    // Basically `!== false` but more deterministic\n    if (autoDestroy === undefined || autoDestroy === true) {\n      await this.strapi?.destroy();\n    }\n  }\n\n  getMetadata(): IMetadata {\n    const strapiVersion = strapi.config.get<string>('info.strapi');\n    const createdAt = new Date().toISOString();\n\n    return {\n      createdAt,\n      strapi: {\n        version: strapiVersion,\n      },\n    };\n  }\n\n  async createEntitiesReadStream(): Promise<Readable> {\n    assertValidStrapi(this.strapi, 'Not able to stream entities');\n\n    return chain([\n      // Entities stream\n      createEntitiesStream(this.strapi),\n\n      // Transform stream\n      createEntitiesTransformStream(),\n    ]);\n  }\n\n  createLinksReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream links');\n\n    return createLinksStream(this.strapi);\n  }\n\n  createConfigurationReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream configuration');\n\n    return createConfigurationStream(this.strapi);\n  }\n\n  getSchemas(): Record<string, Struct.Schema> {\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n\n    const schemas = utils.schema.schemasToValidJSON({\n      ...this.strapi.contentTypes,\n      ...this.strapi.components,\n    });\n\n    return utils.schema.mapSchemasValues(schemas);\n  }\n\n  createSchemasReadStream(): Readable {\n    return Readable.from(Object.values(this.getSchemas()));\n  }\n\n  createAssetsReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream assets');\n\n    return createAssetsStream(this.strapi);\n  }\n}\n\nexport type ILocalStrapiSourceProvider = InstanceType<typeof LocalStrapiSourceProvider>;\n","import { randomUUID } from 'crypto';\nimport { RawData, WebSocket } from 'ws';\n\nimport type { Client, Server } from '../../../types/remote/protocol';\n\nimport {\n  ProviderError,\n  ProviderTransferError,\n  ProviderInitializationError,\n  ProviderValidationError,\n  ProviderErrorDetails,\n} from '../../errors/providers';\n\ninterface IDispatcherState {\n  transfer?: { kind: Client.TransferKind; id: string };\n}\n\ninterface IDispatchOptions {\n  attachTransfer?: boolean;\n}\n\ntype Dispatch<T> = Omit<T, 'transferID' | 'uuid'>;\n\nexport const createDispatcher = (\n  ws: WebSocket,\n  retryMessageOptions = {\n    retryMessageMaxRetries: 5,\n    retryMessageTimeout: 30000,\n  }\n) => {\n  const state: IDispatcherState = {};\n\n  type DispatchMessage = Dispatch<Client.Message>;\n\n  const dispatch = async <U = null>(\n    message: DispatchMessage,\n    options: IDispatchOptions = {}\n  ): Promise<U | null> => {\n    if (!ws) {\n      throw new Error('No websocket connection found');\n    }\n\n    return new Promise<U | null>((resolve, reject) => {\n      const uuid = randomUUID();\n      const payload = { ...message, uuid };\n      let numberOfTimesMessageWasSent = 0;\n\n      if (options.attachTransfer) {\n        Object.assign(payload, { transferID: state.transfer?.id });\n      }\n\n      const stringifiedPayload = JSON.stringify(payload);\n      ws.send(stringifiedPayload, (error) => {\n        if (error) {\n          reject(error);\n        }\n      });\n      const { retryMessageMaxRetries, retryMessageTimeout } = retryMessageOptions;\n      const sendPeriodically = () => {\n        if (numberOfTimesMessageWasSent <= retryMessageMaxRetries) {\n          numberOfTimesMessageWasSent += 1;\n          ws.send(stringifiedPayload, (error) => {\n            if (error) {\n              reject(error);\n            }\n          });\n        } else {\n          reject(new ProviderError('error', 'Request timed out'));\n        }\n      };\n      const interval = setInterval(sendPeriodically, retryMessageTimeout);\n\n      const onResponse = (raw: RawData) => {\n        const response: Server.Message<U> = JSON.parse(raw.toString());\n        if (response.uuid === uuid) {\n          clearInterval(interval);\n          if (response.error) {\n            const message = response.error.message;\n            const details = response.error.details?.details as ProviderErrorDetails;\n            const step = response.error.details?.step;\n            let error = new ProviderError('error', message, details);\n            if (step === 'transfer') {\n              error = new ProviderTransferError(message, details);\n            } else if (step === 'validation') {\n              error = new ProviderValidationError(message, details);\n            } else if (step === 'initialization') {\n              error = new ProviderInitializationError(message);\n            }\n            return reject(error);\n          }\n          resolve(response.data ?? null);\n        } else {\n          ws.once('message', onResponse);\n        }\n      };\n\n      ws.once('message', onResponse);\n    });\n  };\n\n  const dispatchCommand = <U extends Client.Command>(\n    payload: {\n      command: U;\n    } & ([Client.GetCommandParams<U>] extends [never]\n      ? unknown\n      : { params?: Client.GetCommandParams<U> })\n  ) => {\n    return dispatch({ type: 'command', ...payload } as Client.CommandMessage);\n  };\n\n  const dispatchTransferAction = async <T>(action: Client.Action['action']) => {\n    const payload: Dispatch<Client.Action> = { type: 'transfer', kind: 'action', action };\n\n    return dispatch<T>(payload, { attachTransfer: true }) ?? Promise.resolve(null);\n  };\n\n  const dispatchTransferStep = async <\n    T,\n    A extends Client.TransferPushMessage['action'] = Client.TransferPushMessage['action'],\n    S extends Client.TransferPushStep = Client.TransferPushStep,\n  >(\n    payload: {\n      step: S;\n      action: A;\n    } & (A extends 'stream' ? { data: Client.GetTransferPushStreamData<S> } : unknown)\n  ) => {\n    const message: Dispatch<Client.TransferPushMessage> = {\n      type: 'transfer',\n      kind: 'step',\n      ...payload,\n    };\n\n    return dispatch<T>(message, { attachTransfer: true }) ?? Promise.resolve(null);\n  };\n\n  const setTransferProperties = (\n    properties: Exclude<IDispatcherState['transfer'], undefined>\n  ): void => {\n    state.transfer = { ...properties };\n  };\n\n  return {\n    get transferID() {\n      return state.transfer?.id;\n    },\n\n    get transferKind() {\n      return state.transfer?.kind;\n    },\n\n    setTransferProperties,\n\n    dispatch,\n    dispatchCommand,\n    dispatchTransferAction,\n    dispatchTransferStep,\n  };\n};\n\ntype WebsocketParams = ConstructorParameters<typeof WebSocket>;\ntype Address = WebsocketParams[0];\ntype Options = WebsocketParams[2];\n\nexport const connectToWebsocket = (address: Address, options?: Options): Promise<WebSocket> => {\n  return new Promise((resolve, reject) => {\n    const server = new WebSocket(address, options);\n    server.once('open', () => {\n      resolve(server);\n    });\n\n    server.on('unexpected-response', (_req, res) => {\n      if (res.statusCode === 401) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Authentication Error'\n          )\n        );\n      }\n\n      if (res.statusCode === 403) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Authorization Error'\n          )\n        );\n      }\n\n      if (res.statusCode === 404) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Data transfer is not enabled on the remote host'\n          )\n        );\n      }\n\n      return reject(\n        new ProviderInitializationError(\n          `Failed to initialize the connection: Unexpected server response ${res.statusCode}`\n        )\n      );\n    });\n\n    server.once('error', (err) => {\n      reject(\n        new ProviderTransferError(err.message, {\n          details: {\n            error: err.message,\n          },\n        })\n      );\n    });\n  });\n};\n\nexport const trimTrailingSlash = (input: string): string => {\n  return input.replace(/\\/$/, '');\n};\n\nexport const wait = (ms: number) => {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n\nexport const waitUntil = async (test: () => boolean, interval: number): Promise<void> => {\n  while (!test()) {\n    await wait(interval);\n  }\n\n  return Promise.resolve();\n};\n","export const TRANSFER_PATH = '/transfer/runner' as const;\nexport const TRANSFER_METHODS = ['push', 'pull'] as const;\n\nexport type TransferPath = typeof TRANSFER_PATH;\nexport type TransferMethod = (typeof TRANSFER_METHODS)[number];\n","import { randomUUID } from 'crypto';\nimport { Writable } from 'stream';\nimport { WebSocket } from 'ws';\nimport { once } from 'lodash/fp';\nimport type { Struct, Utils } from '@strapi/types';\n\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash } from '../utils';\n\nimport type { IDestinationProvider, IMetadata, ProviderType, IAsset } from '../../../../types';\nimport type { Client, Server, Auth } from '../../../../types/remote/protocol';\nimport type { ILocalStrapiDestinationProviderOptions } from '../local-destination';\nimport { TRANSFER_PATH } from '../../remote/constants';\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\n\nexport interface IRemoteStrapiDestinationProviderOptions\n  extends Pick<ILocalStrapiDestinationProviderOptions, 'restore' | 'strategy'> {\n  url: URL; // the url of the remote Strapi admin\n  auth?: Auth.ITransferTokenAuth;\n  retryMessageOptions?: {\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\n  };\n}\n\nconst jsonLength = (obj: object) => Buffer.byteLength(JSON.stringify(obj));\n\nclass RemoteStrapiDestinationProvider implements IDestinationProvider {\n  name = 'destination::remote-strapi';\n\n  type: ProviderType = 'destination';\n\n  options: IRemoteStrapiDestinationProviderOptions;\n\n  ws: WebSocket | null;\n\n  dispatcher: ReturnType<typeof createDispatcher> | null;\n\n  transferID: string | null;\n\n  constructor(options: IRemoteStrapiDestinationProviderOptions) {\n    this.options = options;\n    this.ws = null;\n    this.dispatcher = null;\n    this.transferID = null;\n  }\n\n  async initTransfer(): Promise<string> {\n    const { strategy, restore } = this.options;\n\n    const query = this.dispatcher?.dispatchCommand({\n      command: 'init',\n      params: { options: { strategy, restore }, transfer: 'push' },\n    });\n\n    const res = (await query) as Server.Payload<Server.InitMessage>;\n    if (!res?.transferID) {\n      throw new ProviderTransferError('Init failed, invalid response from the server');\n    }\n    return res.transferID;\n  }\n\n  #startStepOnce(stage: Client.TransferPushStep) {\n    return once(() => this.#startStep(stage));\n  }\n\n  async #startStep<T extends Client.TransferPushStep>(step: T) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n\n  async #endStep<T extends Client.TransferPushStep>(step: T) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'end', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n\n  async #streamStep<T extends Client.TransferPushStep>(\n    step: T,\n    data: Client.GetTransferPushStreamData<T>\n  ) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'stream', step, data });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n\n  #writeStream(step: Exclude<Client.TransferPushStep, 'assets'>): Writable {\n    type Step = typeof step;\n\n    const batchSize = 1024 * 1024; // 1MB;\n    const startTransferOnce = this.#startStepOnce(step);\n\n    let batch = [] as Client.GetTransferPushStreamData<Step>;\n\n    const batchLength = () => jsonLength(batch);\n\n    return new Writable({\n      objectMode: true,\n\n      final: async (callback) => {\n        if (batch.length > 0) {\n          const streamError = await this.#streamStep(step, batch);\n\n          batch = [];\n\n          if (streamError) {\n            return callback(streamError);\n          }\n        }\n        const e = await this.#endStep(step);\n\n        callback(e);\n      },\n\n      write: async (chunk, _encoding, callback) => {\n        const startError = await startTransferOnce();\n        if (startError) {\n          return callback(startError);\n        }\n\n        batch.push(chunk);\n\n        if (batchLength() >= batchSize) {\n          const streamError = await this.#streamStep(step, batch);\n\n          batch = [];\n\n          if (streamError) {\n            return callback(streamError);\n          }\n        }\n\n        callback();\n      },\n    });\n  }\n\n  async bootstrap(): Promise<void> {\n    const { url, auth } = this.options;\n    const validProtocols = ['https:', 'http:'];\n\n    let ws: WebSocket;\n\n    if (!validProtocols.includes(url.protocol)) {\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\n        check: 'url',\n        details: {\n          protocol: url.protocol,\n          validProtocols,\n        },\n      });\n    }\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\n      url.pathname\n    )}${TRANSFER_PATH}/push`;\n\n    // No auth defined, trying public access for transfer\n    if (!auth) {\n      ws = await connectToWebsocket(wsUrl);\n    }\n\n    // Common token auth, this should be the main auth method\n    else if (auth.type === 'token') {\n      const headers = { Authorization: `Bearer ${auth.token}` };\n      ws = await connectToWebsocket(wsUrl, { headers });\n    }\n\n    // Invalid auth method provided\n    else {\n      throw new ProviderValidationError('Auth method not available', {\n        check: 'auth.type',\n        details: {\n          auth: auth.type,\n        },\n      });\n    }\n\n    this.ws = ws;\n    const { retryMessageOptions } = this.options;\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions);\n\n    this.transferID = await this.initTransfer();\n\n    this.dispatcher.setTransferProperties({ id: this.transferID, kind: 'push' });\n\n    await this.dispatcher.dispatchTransferAction('bootstrap');\n  }\n\n  async close() {\n    // Gracefully close the remote transfer process\n    if (this.transferID && this.dispatcher) {\n      await this.dispatcher.dispatchTransferAction('close');\n\n      await this.dispatcher.dispatchCommand({\n        command: 'end',\n        params: { transferID: this.transferID },\n      });\n    }\n\n    await new Promise<void>((resolve) => {\n      const { ws } = this;\n\n      if (!ws || ws.CLOSED) {\n        resolve();\n        return;\n      }\n\n      ws.on('close', () => resolve()).close();\n    });\n  }\n\n  getMetadata() {\n    return this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata') ?? null;\n  }\n\n  async beforeTransfer() {\n    await this.dispatcher?.dispatchTransferAction('beforeTransfer');\n  }\n\n  async rollback() {\n    await this.dispatcher?.dispatchTransferAction('rollback');\n  }\n\n  getSchemas() {\n    if (!this.dispatcher) {\n      return Promise.resolve(null);\n    }\n\n    return this.dispatcher.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\n  }\n\n  createEntitiesWriteStream(): Writable {\n    return this.#writeStream('entities');\n  }\n\n  createLinksWriteStream(): Writable {\n    return this.#writeStream('links');\n  }\n\n  createConfigurationWriteStream(): Writable {\n    return this.#writeStream('configuration');\n  }\n\n  createAssetsWriteStream(): Writable | Promise<Writable> {\n    let batch: Client.TransferAssetFlow[] = [];\n    let hasStarted = false;\n\n    const batchSize = 1024 * 1024; // 1MB;\n    const batchLength = () => {\n      return batch.reduce(\n        (acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc),\n        0\n      );\n    };\n    const startAssetsTransferOnce = this.#startStepOnce('assets');\n\n    const flush = async () => {\n      const streamError = await this.#streamStep('assets', batch);\n      batch = [];\n      return streamError;\n    };\n\n    const safePush = async (chunk: Client.TransferAssetFlow) => {\n      batch.push(chunk);\n\n      if (batchLength() >= batchSize) {\n        const streamError = await flush();\n        if (streamError) {\n          throw streamError;\n        }\n      }\n    };\n\n    return new Writable({\n      objectMode: true,\n      final: async (callback) => {\n        if (batch.length > 0) {\n          await flush();\n        }\n\n        if (hasStarted) {\n          const endStepError = await this.#endStep('assets');\n\n          if (endStepError) {\n            return callback(endStepError);\n          }\n        }\n\n        return callback(null);\n      },\n\n      async write(asset: IAsset, _encoding, callback) {\n        const startError = await startAssetsTransferOnce();\n        if (startError) {\n          return callback(startError);\n        }\n\n        hasStarted = true;\n\n        const assetID = randomUUID();\n        const { filename, filepath, stats, stream, metadata } = asset;\n\n        try {\n          await safePush({\n            action: 'start',\n            assetID,\n            data: { filename, filepath, stats, metadata },\n          });\n\n          for await (const chunk of stream) {\n            await safePush({ action: 'stream', assetID, data: chunk });\n          }\n\n          await safePush({ action: 'end', assetID });\n\n          callback();\n        } catch (error) {\n          if (error instanceof Error) {\n            callback(error);\n          }\n        }\n      },\n    });\n  }\n}\n\nexport const createRemoteStrapiDestinationProvider = (\n  options: IRemoteStrapiDestinationProviderOptions\n) => {\n  return new RemoteStrapiDestinationProvider(options);\n};\n","import { PassThrough, Readable, Writable } from 'stream';\nimport type { Struct, Utils } from '@strapi/types';\nimport { WebSocket } from 'ws';\nimport { castArray } from 'lodash/fp';\n\nimport type {\n  IAsset,\n  IMetadata,\n  ISourceProvider,\n  ISourceProviderTransferResults,\n  MaybePromise,\n  Protocol,\n  ProviderType,\n  TransferStage,\n} from '../../../../types';\nimport { Client, Server, Auth } from '../../../../types/remote/protocol';\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\nimport { TRANSFER_PATH } from '../../remote/constants';\nimport { ILocalStrapiSourceProviderOptions } from '../local-source';\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash, wait, waitUntil } from '../utils';\n\nexport interface IRemoteStrapiSourceProviderOptions extends ILocalStrapiSourceProviderOptions {\n  url: URL; // the url of the remote Strapi admin\n  auth?: Auth.ITransferTokenAuth;\n  retryMessageOptions?: {\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\n  };\n}\n\nclass RemoteStrapiSourceProvider implements ISourceProvider {\n  name = 'source::remote-strapi';\n\n  type: ProviderType = 'source';\n\n  options: IRemoteStrapiSourceProviderOptions;\n\n  ws: WebSocket | null;\n\n  dispatcher: ReturnType<typeof createDispatcher> | null;\n\n  constructor(options: IRemoteStrapiSourceProviderOptions) {\n    this.options = options;\n    this.ws = null;\n    this.dispatcher = null;\n  }\n\n  results?: ISourceProviderTransferResults | undefined;\n\n  async #createStageReadStream(stage: Exclude<TransferStage, 'schemas'>) {\n    const startResult = await this.#startStep(stage);\n\n    if (startResult instanceof Error) {\n      throw startResult;\n    }\n\n    const { id: processID } = startResult as { id: string };\n\n    const stream = new PassThrough({ objectMode: true });\n\n    const listener = async (raw: Buffer) => {\n      const parsed = JSON.parse(raw.toString());\n      // If not a message related to our transfer process, ignore it\n      if (!parsed.uuid || parsed?.data?.type !== 'transfer' || parsed?.data?.id !== processID) {\n        this.ws?.once('message', listener);\n        return;\n      }\n\n      const { uuid, data: message } = parsed;\n      const { ended, error, data } = message;\n\n      if (error) {\n        await this.#respond(uuid);\n        stream.destroy(error);\n        return;\n      }\n\n      if (ended) {\n        await this.#respond(uuid);\n        await this.#endStep(stage);\n\n        stream.end();\n        return;\n      }\n\n      // if we get a single items instead of a batch\n      for (const item of castArray(data)) {\n        stream.push(item);\n      }\n\n      this.ws?.once('message', listener);\n\n      await this.#respond(uuid);\n    };\n\n    this.ws?.once('message', listener);\n\n    return stream;\n  }\n\n  createEntitiesReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('entities');\n  }\n\n  createLinksReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('links');\n  }\n\n  writeAsync = <T>(stream: Writable, data: T) => {\n    return new Promise<void>((resolve, reject) => {\n      stream.write(data, (error) => {\n        if (error) {\n          reject(error);\n        }\n\n        resolve();\n      });\n    });\n  };\n\n  async createAssetsReadStream(): Promise<Readable> {\n    // Create the streams used to transfer the assets\n    const stream = await this.#createStageReadStream('assets');\n    const pass = new PassThrough({ objectMode: true });\n\n    // Init the asset map\n    const assets: {\n      [filename: string]: IAsset & {\n        stream: PassThrough;\n        queue: Array<Protocol.Client.TransferAssetFlow & { action: 'stream' }>;\n        status: 'idle' | 'busy' | 'closed' | 'errored';\n      };\n    } = {};\n\n    stream\n      /**\n       * Process a payload of many transfer assets and performs the following tasks:\n       * - Start: creates a stream for new assets.\n       * - Stream: writes asset chunks to the asset's stream.\n       * - End: closes the stream after the asset s transferred and cleanup related resources.\n       */\n      .on('data', async (payload: Protocol.Client.TransferAssetFlow[]) => {\n        for (const item of payload) {\n          const { action, assetID } = item;\n\n          // Creates the stream to send the incoming asset through\n          if (action === 'start') {\n            // Ignore the item if a transfer has already been started for the same asset ID\n            if (assets[assetID]) {\n              continue;\n            }\n\n            // Register the asset\n            assets[assetID] = {\n              ...item.data,\n              stream: new PassThrough(),\n              status: 'idle',\n              queue: [],\n            };\n\n            // Connect the individual asset stream to the main asset stage stream\n            // Note: nothing is transferred until data chunks are fed to the asset stream\n            await this.writeAsync(pass, assets[assetID]);\n          }\n\n          // Writes the asset's data chunks to their corresponding stream\n          else if (action === 'stream') {\n            // If the asset hasn't been registered, or if it's been closed already, then ignore the message\n            if (!assets[assetID]) {\n              continue;\n            }\n\n            switch (assets[assetID].status) {\n              // The asset is ready to accept a new chunk, write it now\n              case 'idle':\n                await writeAssetChunk(assetID, item.data);\n                break;\n              // The resource is busy, queue the current chunk so that it gets transferred as soon as possible\n              case 'busy':\n                assets[assetID].queue.push(item);\n                break;\n              // Ignore asset chunks for assets with a closed/errored status\n              case 'closed':\n              case 'errored':\n              default:\n                break;\n            }\n          }\n\n          // All the asset chunks have been transferred\n          else if (action === 'end') {\n            // If the asset has already been closed, or if it was never registered, ignore the command\n            if (!assets[assetID]) {\n              continue;\n            }\n\n            switch (assets[assetID].status) {\n              // There's no ongoing activity, the asset is ready to be closed\n              case 'idle':\n              case 'errored':\n                await closeAssetStream(assetID);\n                break;\n              // The resource is busy, wait for a different state and close the stream.\n              case 'busy':\n                await Promise.race([\n                  // Either: wait for the asset to be ready to be closed\n                  waitUntil(() => assets[assetID].status !== 'busy', 100),\n                  // Or: if the last chunks are still not processed after ten seconds\n                  wait(10000),\n                ]);\n\n                await closeAssetStream(assetID);\n                break;\n              // Ignore commands for assets being currently closed\n              case 'closed':\n              default:\n                break;\n            }\n          }\n        }\n      })\n      .on('close', () => {\n        pass.end();\n      });\n\n    /**\n     * Writes a chunk of data for the specified asset with the given id.\n     */\n    const writeAssetChunk = async (id: string, data: unknown) => {\n      if (!assets[id]) {\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\n      }\n\n      const { status: currentStatus } = assets[id];\n\n      if (currentStatus !== 'idle') {\n        throw new Error(\n          `Failed to write asset chunk for \"${id}\". The asset is currently \"${currentStatus}\"`\n        );\n      }\n\n      const nextItemInQueue = () => assets[id].queue.shift();\n\n      try {\n        // Lock the asset\n        assets[id].status = 'busy';\n\n        // Save the current chunk\n        await unsafe_writeAssetChunk(id, data);\n\n        // Empty the queue if needed\n        let item = nextItemInQueue();\n\n        while (item) {\n          await unsafe_writeAssetChunk(id, item.data);\n          item = nextItemInQueue();\n        }\n\n        // Unlock the asset\n        assets[id].status = 'idle';\n      } catch {\n        assets[id].status = 'errored';\n      }\n    };\n\n    /**\n     * Writes a chunk of data to the asset's stream.\n     *\n     * Only check if the targeted asset exists, no other validation is done.\n     */\n    const unsafe_writeAssetChunk = async (id: string, data: unknown) => {\n      const asset = assets[id];\n\n      if (!asset) {\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\n      }\n\n      const rawBuffer = data as { type: 'Buffer'; data: Uint8Array };\n      const chunk = Buffer.from(rawBuffer.data);\n\n      await this.writeAsync(asset.stream, chunk);\n    };\n\n    /**\n     * Closes the asset stream associated with the given ID.\n     *\n     * It deletes the stream for the asset upon successful closure.\n     */\n    const closeAssetStream = async (id: string) => {\n      if (!assets[id]) {\n        throw new Error(`Failed to close asset \"${id}\". Asset not found.`);\n      }\n\n      assets[id].status = 'closed';\n\n      await new Promise<void>((resolve, reject) => {\n        const { stream } = assets[id];\n\n        stream\n          .on('close', () => {\n            delete assets[id];\n\n            resolve();\n          })\n          .on('error', reject)\n          .end();\n      });\n    };\n\n    return pass;\n  }\n\n  createConfigurationReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('configuration');\n  }\n\n  async getMetadata(): Promise<IMetadata | null> {\n    const metadata = await this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata');\n\n    return metadata ?? null;\n  }\n\n  assertValidProtocol(url: URL) {\n    const validProtocols = ['https:', 'http:'];\n\n    if (!validProtocols.includes(url.protocol)) {\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\n        check: 'url',\n        details: {\n          protocol: url.protocol,\n          validProtocols,\n        },\n      });\n    }\n  }\n\n  async initTransfer(): Promise<string> {\n    const query = this.dispatcher?.dispatchCommand({\n      command: 'init',\n    });\n\n    const res = (await query) as Server.Payload<Server.InitMessage>;\n\n    if (!res?.transferID) {\n      throw new ProviderTransferError('Init failed, invalid response from the server');\n    }\n\n    return res.transferID;\n  }\n\n  async bootstrap(): Promise<void> {\n    const { url, auth } = this.options;\n    let ws: WebSocket;\n    this.assertValidProtocol(url);\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\n      url.pathname\n    )}${TRANSFER_PATH}/pull`;\n\n    // No auth defined, trying public access for transfer\n    if (!auth) {\n      ws = await connectToWebsocket(wsUrl);\n    }\n\n    // Common token auth, this should be the main auth method\n    else if (auth.type === 'token') {\n      const headers = { Authorization: `Bearer ${auth.token}` };\n      ws = await connectToWebsocket(wsUrl, { headers });\n    }\n\n    // Invalid auth method provided\n    else {\n      throw new ProviderValidationError('Auth method not available', {\n        check: 'auth.type',\n        details: {\n          auth: auth.type,\n        },\n      });\n    }\n\n    this.ws = ws;\n    const { retryMessageOptions } = this.options;\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions);\n    const transferID = await this.initTransfer();\n\n    this.dispatcher.setTransferProperties({ id: transferID, kind: 'pull' });\n    await this.dispatcher.dispatchTransferAction('bootstrap');\n  }\n\n  async close() {\n    await this.dispatcher?.dispatchTransferAction('close');\n\n    await new Promise<void>((resolve) => {\n      const { ws } = this;\n\n      if (!ws || ws.CLOSED) {\n        resolve();\n        return;\n      }\n\n      ws.on('close', () => resolve()).close();\n    });\n  }\n\n  async getSchemas() {\n    const schemas =\n      await this.dispatcher?.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\n\n    return schemas ?? null;\n  }\n\n  async #startStep<T extends Client.TransferPullStep>(step: T) {\n    try {\n      return await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n  }\n\n  async #respond(uuid: string) {\n    return new Promise((resolve, reject) => {\n      this.ws?.send(JSON.stringify({ uuid }), (e) => {\n        if (e) {\n          reject(e);\n        } else {\n          resolve(e);\n        }\n      });\n    });\n  }\n\n  async #endStep<T extends Client.TransferPullStep>(step: T) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'end', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n}\n\nexport const createRemoteStrapiSourceProvider = (options: IRemoteStrapiSourceProviderOptions) => {\n  return new RemoteStrapiSourceProvider(options);\n};\n","import type { Step } from '.';\n\nexport default [\n  {\n    kind: 'action',\n    action: 'bootstrap',\n  },\n  {\n    kind: 'action',\n    action: 'init',\n  },\n  {\n    kind: 'action',\n    action: 'beforeTransfer',\n  },\n  {\n    kind: 'transfer',\n    stage: 'schemas',\n  },\n  {\n    kind: 'transfer',\n    stage: 'entities',\n  },\n  {\n    kind: 'transfer',\n    stage: 'assets',\n  },\n  {\n    kind: 'transfer',\n    stage: 'links',\n  },\n  {\n    kind: 'transfer',\n    stage: 'configuration',\n  },\n  {\n    kind: 'action',\n    action: 'close',\n  },\n] as readonly Step[];\n","import type { TransferStage } from '../../../../types';\n\nexport type Step =\n  | { kind: 'action'; action: string }\n  | { kind: 'transfer'; stage: TransferStage; locked?: boolean };\n\nexport { default as DEFAULT_TRANSFER_FLOW } from './default';\n\ninterface IState {\n  step: Step | null;\n}\n\nexport interface TransferFlow {\n  has(step: Step): boolean;\n  can(step: Step): boolean;\n  cannot(step: Step): boolean;\n  set(step: Step): this;\n  get(): Step | null;\n}\n\nexport const createFlow = (flow: readonly Step[]): TransferFlow => {\n  const state: IState = { step: null };\n\n  /**\n   * Equality check between two steps\n   */\n  const stepEqual = (stepA: Step, stepB: Step): boolean => {\n    if (stepA.kind === 'action' && stepB.kind === 'action') {\n      return stepA.action === stepB.action;\n    }\n\n    if (stepA.kind === 'transfer' && stepB.kind === 'transfer') {\n      return stepA.stage === stepB.stage;\n    }\n\n    return false;\n  };\n\n  /**\n   * Find the index for a given step\n   */\n  const findStepIndex = (step: Step) => flow.findIndex((flowStep) => stepEqual(step, flowStep));\n\n  return {\n    has(step: Step) {\n      return findStepIndex(step) !== -1;\n    },\n\n    can(step: Step) {\n      if (state.step === null) {\n        return true;\n      }\n\n      const indexesDifference = findStepIndex(step) - findStepIndex(state.step);\n\n      // It's possible to send multiple time the same transfer step in a row\n      if (indexesDifference === 0 && step.kind === 'transfer') {\n        return true;\n      }\n\n      return indexesDifference > 0;\n    },\n\n    cannot(step: Step) {\n      return !this.can(step);\n    },\n\n    set(step: Step) {\n      const canSwitch = this.can(step);\n\n      if (!canSwitch) {\n        throw new Error('Impossible to proceed to the given step');\n      }\n\n      state.step = step;\n\n      return this;\n    },\n\n    get() {\n      return state.step;\n    },\n  };\n};\n","export const VALID_TRANSFER_COMMANDS = ['init', 'end', 'status'] as const;\nexport type ValidTransferCommand = (typeof VALID_TRANSFER_COMMANDS)[number];\n","import type { IncomingMessage } from 'node:http';\nimport { randomUUID } from 'crypto';\nimport type { Context } from 'koa';\nimport type { RawData, ServerOptions } from 'ws';\nimport { WebSocket, WebSocketServer } from 'ws';\n\nimport type { Handler, TransferState } from './abstract';\nimport type { Protocol } from '../../../../types';\nimport { ProviderError, ProviderTransferError } from '../../../errors/providers';\nimport { VALID_TRANSFER_COMMANDS, ValidTransferCommand } from './constants';\nimport { TransferMethod } from '../constants';\n\ntype WSCallback = (client: WebSocket, request: IncomingMessage) => void;\n\nexport interface HandlerOptions {\n  verify: (ctx: Context, scope?: TransferMethod) => Promise<void>;\n  server?: ServerOptions;\n}\n\nexport const transformUpgradeHeader = (header = '') => {\n  return header.split(',').map((s) => s.trim().toLowerCase());\n};\n\nlet timeouts: Record<string, number> | undefined;\n\nconst hasHttpServer = () => {\n  // during server restarts, strapi may not have ever been defined at all, so we have to check it first\n  return typeof strapi !== 'undefined' && !!strapi?.server?.httpServer;\n};\n\n// temporarily disable server timeouts while transfer is running\nconst disableTimeouts = () => {\n  if (!hasHttpServer()) {\n    return;\n  }\n\n  const { httpServer } = strapi.server;\n\n  // save the original timeouts to restore after\n  if (!timeouts) {\n    timeouts = {\n      headersTimeout: httpServer.headersTimeout,\n      requestTimeout: httpServer.requestTimeout,\n    };\n  }\n\n  httpServer.headersTimeout = 0;\n  httpServer.requestTimeout = 0;\n\n  strapi.log.info('[Data transfer] Disabling http timeouts');\n};\nconst resetTimeouts = () => {\n  if (!hasHttpServer() || !timeouts) {\n    return;\n  }\n\n  const { httpServer } = strapi.server;\n\n  strapi.log.info('[Data transfer] Restoring http timeouts');\n  httpServer.headersTimeout = timeouts.headersTimeout;\n  httpServer.requestTimeout = timeouts.requestTimeout;\n};\n/**\n * Make sure that the upgrade header is a valid websocket one\n */\nexport const assertValidHeader = (ctx: Context) => {\n  // if it's exactly what we expect, it's fine\n  if (ctx.headers.upgrade === 'websocket') {\n    return;\n  }\n\n  // check if it could be an array that still includes websocket\n  const upgradeHeader = transformUpgradeHeader(ctx.headers.upgrade);\n\n  // Sanitize user input before writing it to our logs\n  const logSafeUpgradeHeader = JSON.stringify(ctx.headers.upgrade)\n    ?.replace(/[^a-z0-9\\s.,|]/gi, '')\n    .substring(0, 50);\n\n  if (!upgradeHeader.includes('websocket')) {\n    throw new Error(\n      `Transfer Upgrade header expected 'websocket', found '${logSafeUpgradeHeader}'. Please ensure that your server or proxy is not modifying the Upgrade header.`\n    );\n  }\n\n  /**\n   * If there's more than expected but it still includes websocket, in theory it could still work\n   * and could be necessary for their certain configurations, so we'll allow it to proceed but\n   * log the unexpected behaviour in case it helps debug an issue\n   * */\n  strapi.log.info(\n    `Transfer Upgrade header expected only 'websocket', found unexpected values: ${logSafeUpgradeHeader}`\n  );\n};\n\nexport const isDataTransferMessage = (message: unknown): message is Protocol.Client.Message => {\n  if (!message || typeof message !== 'object') {\n    return false;\n  }\n\n  const { uuid, type } = message as Record<string, unknown>;\n\n  if (typeof uuid !== 'string' || typeof type !== 'string') {\n    return false;\n  }\n\n  if (!['command', 'transfer'].includes(type)) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Handle the upgrade to ws connection\n */\nexport const handleWSUpgrade = (wss: WebSocketServer, ctx: Context, callback: WSCallback) => {\n  assertValidHeader(ctx);\n\n  wss.handleUpgrade(ctx.req, ctx.request.socket, Buffer.alloc(0), (client, request) => {\n    if (!client) {\n      // If the WebSocket upgrade failed, destroy the socket to avoid hanging\n      ctx.request.socket.destroy();\n      return;\n    }\n\n    disableTimeouts();\n\n    // Create a connection between the client & the server\n    wss.emit('connection', client, ctx.req);\n\n    // Invoke the ws callback\n    callback(client, request);\n  });\n\n  ctx.respond = false;\n};\n\n// Protocol related functions\n\nexport const handlerControllerFactory =\n  <T extends Partial<Handler>>(implementation: (proto: Handler) => T) =>\n  (options: HandlerOptions) => {\n    const { verify, server: serverOptions } = options ?? {};\n\n    const wss = new WebSocket.Server({ ...serverOptions, noServer: true });\n\n    return async (ctx: Context) => {\n      const cb: WSCallback = (ws) => {\n        const state: TransferState = { id: undefined };\n        const messageUUIDs = new Set<string>();\n\n        const cannotRespondHandler = (err: unknown) => {\n          strapi?.log?.error(\n            '[Data transfer] Cannot send error response to client, closing connection'\n          );\n          strapi?.log?.error(err);\n          try {\n            ws.terminate();\n            ctx.req.socket.destroy();\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Failed to close socket on error');\n          }\n        };\n\n        const prototype: Handler = {\n          // Transfer ID\n          get transferID() {\n            return state.id;\n          },\n\n          set transferID(id) {\n            state.id = id;\n          },\n\n          // Started at\n          get startedAt() {\n            return state.startedAt;\n          },\n\n          set startedAt(timestamp) {\n            state.startedAt = timestamp;\n          },\n\n          get response() {\n            return state.response;\n          },\n\n          set response(response) {\n            state.response = response;\n          },\n\n          addUUID(uuid) {\n            messageUUIDs.add(uuid);\n          },\n\n          hasUUID(uuid) {\n            return messageUUIDs.has(uuid);\n          },\n\n          isTransferStarted() {\n            return this.transferID !== undefined && this.startedAt !== undefined;\n          },\n\n          assertValidTransfer() {\n            const isStarted = this.isTransferStarted();\n\n            if (!isStarted) {\n              throw new Error('Invalid Transfer Process');\n            }\n          },\n\n          assertValidTransferCommand(command: ValidTransferCommand) {\n            const isDefined = typeof this[command] === 'function';\n            const isValidTransferCommand = VALID_TRANSFER_COMMANDS.includes(command);\n\n            if (!isDefined || !isValidTransferCommand) {\n              throw new Error('Invalid transfer command');\n            }\n          },\n\n          async respond(uuid, e, data) {\n            let details = {};\n            return new Promise<void>((resolve, reject) => {\n              if (!uuid && !e) {\n                reject(new Error('Missing uuid for this message'));\n                return;\n              }\n\n              this.response = {\n                uuid,\n                data,\n                e,\n              };\n\n              if (e instanceof ProviderError) {\n                details = e.details;\n              }\n\n              const payload = JSON.stringify({\n                uuid,\n                data: data ?? null,\n                error: e\n                  ? {\n                      code: e?.name ?? 'ERR',\n                      message: e?.message,\n                      details,\n                    }\n                  : null,\n              });\n\n              this.send(payload, (error) => (error ? reject(error) : resolve()));\n            });\n          },\n\n          send(message, cb) {\n            ws.send(message, cb);\n          },\n\n          confirm(message) {\n            return new Promise((resolve, reject) => {\n              const uuid = randomUUID();\n\n              const payload = JSON.stringify({ uuid, data: message });\n\n              this.send(payload, (error) => {\n                if (error) {\n                  reject(error);\n                }\n              });\n\n              const onResponse = (raw: RawData) => {\n                const response = JSON.parse(raw.toString());\n\n                if (response.uuid === uuid) {\n                  resolve(response.data ?? null);\n                } else {\n                  ws.once('message', onResponse);\n                }\n              };\n\n              ws.once('message', onResponse);\n            });\n          },\n\n          async executeAndRespond(uuid, fn) {\n            try {\n              const response = await fn();\n              await this.respond(uuid, null, response);\n            } catch (e) {\n              if (e instanceof Error) {\n                await this.respond(uuid, e).catch(cannotRespondHandler);\n              } else if (typeof e === 'string') {\n                await this.respond(uuid, new ProviderTransferError(e)).catch(cannotRespondHandler);\n              } else {\n                await this.respond(\n                  uuid,\n                  new ProviderTransferError('Unexpected error', {\n                    error: e,\n                  })\n                ).catch(cannotRespondHandler);\n              }\n            }\n          },\n\n          cleanup() {\n            this.transferID = undefined;\n            this.startedAt = undefined;\n            this.response = undefined;\n          },\n\n          teardown() {\n            this.cleanup();\n          },\n\n          verifyAuth(scope?: TransferMethod) {\n            return verify(ctx, scope);\n          },\n\n          // Transfer commands\n          init() {},\n          end() {},\n          status() {},\n\n          // Default prototype implementation for events\n          onMessage() {},\n          onError() {},\n          onClose() {},\n        };\n\n        const handler: Handler = Object.assign(Object.create(prototype), implementation(prototype));\n\n        // Bind ws events to handler methods\n        ws.on('close', async (...args) => {\n          try {\n            await handler.onClose(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error closing connection');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          } finally {\n            resetTimeouts();\n          }\n        });\n        ws.on('error', async (...args) => {\n          try {\n            await handler.onError(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error in error handling');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          }\n        });\n        ws.on('message', async (...args) => {\n          try {\n            await handler.onMessage(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error in message handling');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          }\n        });\n      };\n\n      try {\n        handleWSUpgrade(wss, ctx, cb);\n      } catch (err) {\n        strapi?.log?.error('[Data transfer] Error in websocket upgrade request');\n        strapi?.log?.error(err);\n      }\n    };\n  };\n","import { randomUUID } from 'crypto';\nimport { Writable, PassThrough } from 'stream';\nimport type { Core } from '@strapi/types';\n\nimport type { TransferFlow, Step } from '../flows';\nimport type { TransferStage, IAsset, Protocol } from '../../../../types';\n\nimport { ProviderTransferError } from '../../../errors/providers';\nimport { createLocalStrapiDestinationProvider } from '../../providers';\nimport { createFlow, DEFAULT_TRANSFER_FLOW } from '../flows';\nimport { Handler } from './abstract';\nimport { handlerControllerFactory, isDataTransferMessage } from './utils';\n\nconst VALID_TRANSFER_ACTIONS = [\n  'bootstrap',\n  'close',\n  'rollback',\n  'beforeTransfer',\n  'getMetadata',\n  'getSchemas',\n] as const;\n\ntype PushTransferAction = (typeof VALID_TRANSFER_ACTIONS)[number];\n\nconst TRANSFER_KIND = 'push';\n\nexport interface PushHandler extends Handler {\n  /**\n   * Local Strapi Destination Provider used to write data to the current Strapi instance\n   */\n  provider?: ReturnType<typeof createLocalStrapiDestinationProvider>;\n\n  /**\n   * Holds all the stages' stream for the current transfer handler (one registry per connection)\n   */\n  streams?: { [stage in TransferStage]?: Writable };\n\n  /**\n   * Holds all the transferred assets for the current transfer handler (one registry per connection)\n   */\n  assets: { [filepath: string]: IAsset & { stream: PassThrough } };\n\n  /**\n   * Ochestrate and manage the transfer messages' ordering\n   */\n  flow?: TransferFlow;\n\n  /**\n   * Checks that the given action is a valid push transfer action\n   */\n  assertValidTransferAction(action: string): asserts action is PushTransferAction;\n\n  /**\n   * Create a new writable stream for the given step in the handler's stream registry\n   */\n  createWritableStreamForStep(step: TransferStage): Promise<void>;\n\n  /**\n   * Simple override of the auth verification\n   */\n  verifyAuth(): Promise<void>;\n\n  /**\n   * Callback when receiving a regular transfer message\n   */\n  onTransferMessage(msg: Protocol.Client.TransferMessage): Promise<unknown> | unknown;\n\n  /**\n   * Callback when receiving a transfer action message\n   */\n  onTransferAction(msg: Protocol.Client.Action): Promise<unknown> | unknown;\n\n  /**\n   * Callback when receiving a transfer step message\n   */\n  onTransferStep(msg: Protocol.Client.TransferPushMessage): Promise<unknown> | unknown;\n\n  /**\n   * Start streaming an asset\n   */\n  streamAsset(\n    this: PushHandler,\n    payload: Protocol.Client.GetTransferPushStreamData<'assets'>\n  ): Promise<void>;\n\n  // Transfer Flow\n\n  /**\n   * Try to move to a specific transfer stage & lock the step\n   */\n  lockTransferStep(stage: TransferStage): void;\n\n  /**\n   * Try to move to unlock the current step\n   */\n  unlockTransferStep(stage: TransferStage): void;\n\n  /**\n   * Checks whether it's possible to stream a chunk for the given stage\n   */\n  assertValidStreamTransferStep(stage: TransferStage): void;\n}\n\nconst writeAsync = <T>(stream: Writable, data: T) => {\n  return new Promise<void>((resolve, reject) => {\n    stream.write(data, (error) => {\n      if (error) {\n        reject(error);\n      }\n\n      resolve();\n    });\n  });\n};\n\nexport const createPushController = handlerControllerFactory<Partial<PushHandler>>((proto) => ({\n  isTransferStarted(this: PushHandler) {\n    return proto.isTransferStarted.call(this) && this.provider !== undefined;\n  },\n\n  verifyAuth(this: PushHandler) {\n    return proto.verifyAuth.call(this, TRANSFER_KIND);\n  },\n\n  cleanup(this: PushHandler) {\n    proto.cleanup.call(this);\n\n    this.streams = {};\n    this.assets = {};\n\n    delete this.flow;\n    delete this.provider;\n  },\n\n  teardown(this: PushHandler) {\n    if (this.provider) {\n      this.provider.rollback();\n    }\n\n    proto.teardown.call(this);\n  },\n\n  assertValidTransfer(this: PushHandler) {\n    proto.assertValidTransfer.call(this);\n\n    if (this.provider === undefined) {\n      throw new Error('Invalid Transfer Process');\n    }\n  },\n\n  assertValidTransferAction(this: PushHandler, action: PushTransferAction) {\n    if (VALID_TRANSFER_ACTIONS.includes(action)) {\n      return;\n    }\n\n    throw new ProviderTransferError(`Invalid action provided: \"${action}\"`, {\n      action,\n      validActions: Object.keys(VALID_TRANSFER_ACTIONS),\n    });\n  },\n\n  assertValidStreamTransferStep(this: PushHandler, stage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    if (currentStep?.kind === 'transfer' && !currentStep.locked) {\n      throw new ProviderTransferError(\n        `You need to initialize the transfer stage (${nextStep}) before starting to stream data`\n      );\n    }\n\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${nextStep}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n  },\n\n  async createWritableStreamForStep(this: PushHandler, step: Exclude<TransferStage, 'schemas'>) {\n    const mapper = {\n      entities: () => this.provider?.createEntitiesWriteStream(),\n      links: () => this.provider?.createLinksWriteStream(),\n      configuration: () => this.provider?.createConfigurationWriteStream(),\n      assets: () => this.provider?.createAssetsWriteStream(),\n    };\n\n    if (!(step in mapper)) {\n      throw new Error('Invalid transfer step, impossible to create a stream');\n    }\n\n    if (!this.streams) {\n      throw new Error('Invalid transfer state');\n    }\n\n    this.streams[step] = await mapper[step]();\n  },\n\n  async onMessage(this: PushHandler, raw) {\n    const msg = JSON.parse(raw.toString());\n\n    if (!isDataTransferMessage(msg)) {\n      return;\n    }\n\n    if (!msg.uuid) {\n      await this.respond(undefined, new Error('Missing uuid in message'));\n    }\n\n    if (proto.hasUUID(msg.uuid)) {\n      const previousResponse = proto.response;\n      if (previousResponse?.uuid === msg.uuid) {\n        await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);\n      }\n      return;\n    }\n\n    const { uuid, type } = msg;\n    proto.addUUID(uuid);\n    // Regular command message (init, end, status)\n    if (type === 'command') {\n      const { command } = msg;\n\n      await this.executeAndRespond(uuid, () => {\n        this.assertValidTransferCommand(command);\n\n        // The status command don't have params\n        if (command === 'status') {\n          return this.status();\n        }\n\n        return this[command](msg.params);\n      });\n    }\n\n    // Transfer message (the transfer must be init first)\n    else if (type === 'transfer') {\n      await this.executeAndRespond(uuid, async () => {\n        await this.verifyAuth();\n\n        this.assertValidTransfer();\n\n        return this.onTransferMessage(msg);\n      });\n    }\n\n    // Invalid messages\n    else {\n      await this.respond(uuid, new Error('Bad Request'));\n    }\n  },\n\n  async onTransferMessage(this: PushHandler, msg) {\n    const { kind } = msg;\n\n    if (kind === 'action') {\n      return this.onTransferAction(msg);\n    }\n\n    if (kind === 'step') {\n      return this.onTransferStep(msg as Protocol.Client.TransferPushMessage);\n    }\n  },\n\n  lockTransferStep(stage: TransferStage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    if (currentStep?.kind === 'transfer' && currentStep.locked) {\n      throw new ProviderTransferError(\n        `It's not possible to start a new transfer stage (${stage}) while another one is in progress (${currentStep.stage})`\n      );\n    }\n\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n\n    this.flow?.set({ ...nextStep, locked: true });\n  },\n\n  unlockTransferStep(stage: TransferStage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    // Cannot unlock if not locked (aka: started)\n    if (currentStep?.kind === 'transfer' && !currentStep.locked) {\n      throw new ProviderTransferError(\n        `You need to initialize the transfer stage (${stage}) before ending it`\n      );\n    }\n\n    // Cannot unlock if invalid step provided\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n\n    this.flow?.set({ ...nextStep, locked: false });\n  },\n\n  async onTransferStep(this: PushHandler, msg) {\n    const { step: stage } = msg;\n\n    if (msg.action === 'start') {\n      this.lockTransferStep(stage);\n\n      if (this.streams?.[stage] instanceof Writable) {\n        throw new Error('Stream already created, something went wrong');\n      }\n\n      await this.createWritableStreamForStep(stage);\n\n      return { ok: true };\n    }\n\n    if (msg.action === 'stream') {\n      this.assertValidStreamTransferStep(stage);\n\n      // Stream operation on the current transfer stage\n      const stream = this.streams?.[stage];\n\n      if (!stream) {\n        throw new Error('You need to init first');\n      }\n\n      // Assets are nested streams\n      if (stage === 'assets') {\n        return this.streamAsset(msg.data);\n      }\n\n      // For all other steps\n      await Promise.all(msg.data.map((item) => writeAsync(stream, item)));\n    }\n\n    if (msg.action === 'end') {\n      this.unlockTransferStep(stage);\n\n      const stream = this.streams?.[stage];\n\n      if (stream && !stream.closed) {\n        await new Promise((resolve, reject) => {\n          stream.on('close', resolve).on('error', reject).end();\n        });\n      }\n\n      delete this.streams?.[stage];\n\n      return { ok: true };\n    }\n  },\n\n  async onTransferAction(this: PushHandler, msg) {\n    const { action } = msg;\n\n    this.assertValidTransferAction(action);\n\n    const step: Step = { kind: 'action', action };\n    const isStepRegistered = this.flow?.has(step);\n\n    if (isStepRegistered) {\n      if (this.flow?.cannot(step)) {\n        throw new ProviderTransferError(`Invalid action \"${action}\" found for the current flow `, {\n          action,\n        });\n      }\n\n      this.flow?.set(step);\n    }\n\n    return this.provider?.[action]();\n  },\n\n  async streamAsset(this: PushHandler, payload) {\n    const assetsStream = this.streams?.assets;\n\n    // TODO: close the stream upon receiving an 'end' event instead\n    if (payload === null) {\n      this.streams?.assets?.end();\n      return;\n    }\n\n    for (const item of payload) {\n      const { action, assetID } = item;\n\n      if (!assetsStream) {\n        throw new Error('Stream not defined');\n      }\n\n      if (action === 'start') {\n        this.assets[assetID] = { ...item.data, stream: new PassThrough() };\n        writeAsync(assetsStream, this.assets[assetID]);\n      }\n\n      if (action === 'stream') {\n        // The buffer has gone through JSON operations and is now of shape { type: \"Buffer\"; data: UInt8Array }\n        // We need to transform it back into a Buffer instance\n        const rawBuffer = item.data as unknown as { type: 'Buffer'; data: Uint8Array };\n        const chunk = Buffer.from(rawBuffer.data);\n        await writeAsync(this.assets[assetID].stream, chunk);\n      }\n\n      if (action === 'end') {\n        await new Promise<void>((resolve, reject) => {\n          const { stream: assetStream } = this.assets[assetID];\n          assetStream\n            .on('close', () => {\n              delete this.assets[assetID];\n              resolve();\n            })\n            .on('error', reject)\n            .end();\n        });\n      }\n    }\n  },\n\n  onClose(this: Handler) {\n    this.teardown();\n  },\n\n  onError(this: Handler, err) {\n    this.teardown();\n    strapi.log.error(err);\n  },\n\n  // Commands\n\n  async init(\n    this: PushHandler,\n    params: Protocol.Client.GetCommandParams<'init'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.InitMessage>> {\n    if (this.transferID || this.provider) {\n      throw new Error('Transfer already in progress');\n    }\n\n    await this.verifyAuth();\n\n    this.transferID = randomUUID();\n    this.startedAt = Date.now();\n\n    this.assets = {};\n    this.streams = {};\n\n    this.flow = createFlow(DEFAULT_TRANSFER_FLOW);\n\n    this.provider = createLocalStrapiDestinationProvider({\n      ...params.options,\n      autoDestroy: false,\n      getStrapi: () => strapi as Core.Strapi,\n    });\n\n    this.provider.onWarning = (message) => {\n      // TODO send a warning message to the client\n      strapi.log.warn(message);\n    };\n\n    return { transferID: this.transferID };\n  },\n\n  async status(this: PushHandler) {\n    const isStarted = this.isTransferStarted();\n\n    if (isStarted) {\n      const startedAt = this.startedAt as number;\n\n      return {\n        active: true,\n        kind: TRANSFER_KIND,\n        startedAt,\n        elapsed: Date.now() - startedAt,\n      };\n    }\n\n    return { active: false, kind: null, elapsed: null, startedAt: null };\n  },\n\n  async end(\n    this: PushHandler,\n    params: Protocol.Client.GetCommandParams<'end'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.EndMessage>> {\n    await this.verifyAuth();\n\n    if (this.transferID !== params?.transferID) {\n      throw new ProviderTransferError('Bad transfer ID provided');\n    }\n\n    this.cleanup();\n\n    return { ok: true };\n  },\n}));\n","import { Readable } from 'stream';\nimport { randomUUID } from 'crypto';\nimport type { Core } from '@strapi/types';\n\nimport { Handler } from './abstract';\nimport { handlerControllerFactory, isDataTransferMessage } from './utils';\nimport { createLocalStrapiSourceProvider, ILocalStrapiSourceProvider } from '../../providers';\nimport { ProviderTransferError } from '../../../errors/providers';\nimport type { IAsset, TransferStage, Protocol } from '../../../../types';\nimport { Client } from '../../../../types/remote/protocol';\n\nconst TRANSFER_KIND = 'pull';\nconst VALID_TRANSFER_ACTIONS = ['bootstrap', 'close', 'getMetadata', 'getSchemas'] as const;\n\ntype PullTransferAction = (typeof VALID_TRANSFER_ACTIONS)[number];\n\nexport interface PullHandler extends Handler {\n  provider?: ILocalStrapiSourceProvider;\n\n  streams?: { [stage in TransferStage]?: Readable };\n\n  assertValidTransferAction(action: string): asserts action is PullTransferAction;\n\n  onTransferMessage(msg: Protocol.Client.TransferMessage): Promise<unknown> | unknown;\n  onTransferAction(msg: Protocol.Client.Action): Promise<unknown> | unknown;\n  onTransferStep(msg: Protocol.Client.TransferPullMessage): Promise<unknown> | unknown;\n\n  createReadableStreamForStep(step: TransferStage): Promise<void>;\n\n  flush(stage: TransferStage, id: string): Promise<void> | void;\n}\n\nexport const createPullController = handlerControllerFactory<Partial<PullHandler>>((proto) => ({\n  isTransferStarted(this: PullHandler) {\n    return proto.isTransferStarted.call(this) && this.provider !== undefined;\n  },\n\n  verifyAuth(this: PullHandler) {\n    return proto.verifyAuth.call(this, TRANSFER_KIND);\n  },\n\n  cleanup(this: PullHandler) {\n    proto.cleanup.call(this);\n\n    this.streams = {};\n\n    delete this.provider;\n  },\n\n  assertValidTransferAction(this: PullHandler, action) {\n    // Abstract the constant to string[] to allow looser check on the given action\n    const validActions = VALID_TRANSFER_ACTIONS as unknown as string[];\n\n    if (validActions.includes(action)) {\n      return;\n    }\n\n    throw new ProviderTransferError(`Invalid action provided: \"${action}\"`, {\n      action,\n      validActions: Object.keys(VALID_TRANSFER_ACTIONS),\n    });\n  },\n\n  async onMessage(this: PullHandler, raw) {\n    const msg = JSON.parse(raw.toString());\n\n    if (!isDataTransferMessage(msg)) {\n      return;\n    }\n\n    if (!msg.uuid) {\n      await this.respond(undefined, new Error('Missing uuid in message'));\n    }\n\n    if (proto.hasUUID(msg.uuid)) {\n      const previousResponse = proto.response;\n      if (previousResponse?.uuid === msg.uuid) {\n        await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);\n      }\n      return;\n    }\n\n    const { uuid, type } = msg;\n    proto.addUUID(uuid);\n    // Regular command message (init, end, status)\n    if (type === 'command') {\n      const { command } = msg;\n\n      await this.executeAndRespond(uuid, () => {\n        this.assertValidTransferCommand(command);\n\n        // The status command don't have params\n        if (command === 'status') {\n          return this.status();\n        }\n\n        return this[command](msg.params);\n      });\n    }\n\n    // Transfer message (the transfer must be init first)\n    else if (type === 'transfer') {\n      await this.executeAndRespond(uuid, async () => {\n        await this.verifyAuth();\n\n        this.assertValidTransfer();\n\n        return this.onTransferMessage(msg);\n      });\n    }\n\n    // Invalid messages\n    else {\n      await this.respond(uuid, new Error('Bad Request'));\n    }\n  },\n\n  async onTransferMessage(this: PullHandler, msg) {\n    const { kind } = msg;\n\n    if (kind === 'action') {\n      return this.onTransferAction(msg);\n    }\n\n    if (kind === 'step') {\n      return this.onTransferStep(msg as Protocol.Client.TransferPullMessage);\n    }\n  },\n\n  async onTransferAction(this: PullHandler, msg) {\n    const { action } = msg;\n\n    this.assertValidTransferAction(action);\n\n    return this.provider?.[action]();\n  },\n\n  async flush(this: PullHandler, stage: Client.TransferPullStep, id) {\n    type Stage = typeof stage;\n    const batchSize = 1024 * 1024;\n    let batch = [] as Client.GetTransferPullStreamData<Stage>;\n    const stream = this.streams?.[stage];\n\n    const batchLength = () => Buffer.byteLength(JSON.stringify(batch));\n    const sendBatch = async () => {\n      await this.confirm({\n        type: 'transfer',\n        data: batch,\n        ended: false,\n        error: null,\n        id,\n      });\n    };\n\n    if (!stream) {\n      throw new ProviderTransferError(`No available stream found for ${stage}`);\n    }\n\n    try {\n      for await (const chunk of stream) {\n        if (stage !== 'assets') {\n          batch.push(chunk);\n          if (batchLength() >= batchSize) {\n            await sendBatch();\n            batch = [];\n          }\n        } else {\n          await this.confirm({\n            type: 'transfer',\n            data: [chunk],\n            ended: false,\n            error: null,\n            id,\n          });\n        }\n      }\n\n      if (batch.length > 0 && stage !== 'assets') {\n        await sendBatch();\n        batch = [];\n      }\n      await this.confirm({ type: 'transfer', data: null, ended: true, error: null, id });\n    } catch (e) {\n      await this.confirm({ type: 'transfer', data: null, ended: true, error: e, id });\n    }\n  },\n\n  async onTransferStep(this: PullHandler, msg) {\n    const { step, action } = msg;\n\n    if (action === 'start') {\n      if (this.streams?.[step] instanceof Readable) {\n        throw new Error('Stream already created, something went wrong');\n      }\n\n      const flushUUID = randomUUID();\n\n      await this.createReadableStreamForStep(step);\n      this.flush(step, flushUUID);\n\n      return { ok: true, id: flushUUID };\n    }\n\n    if (action === 'end') {\n      const stream = this.streams?.[step];\n\n      if (stream?.readableEnded === false) {\n        await new Promise((resolve) => {\n          stream?.on('close', resolve).destroy();\n        });\n      }\n\n      delete this.streams?.[step];\n\n      return { ok: true };\n    }\n  },\n\n  async createReadableStreamForStep(this: PullHandler, step: Exclude<TransferStage, 'schemas'>) {\n    const mapper = {\n      entities: () => this.provider?.createEntitiesReadStream(),\n      links: () => this.provider?.createLinksReadStream(),\n      configuration: () => this.provider?.createConfigurationReadStream(),\n      assets: () => {\n        const assets = this.provider?.createAssetsReadStream();\n        let batch: Protocol.Client.TransferAssetFlow[] = [];\n\n        const batchLength = () => {\n          return batch.reduce(\n            (acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc),\n            0\n          );\n        };\n\n        const BATCH_MAX_SIZE = 1024 * 1024; // 1MB\n\n        if (!assets) {\n          throw new Error('bad');\n        }\n        /**\n         * Generates batches of 1MB of data from the assets stream to avoid\n         * sending too many small chunks\n         *\n         * @param stream Assets stream from the local source provider\n         */\n        async function* generator(stream: Readable) {\n          let hasStarted = false;\n          let assetID = '';\n\n          for await (const chunk of stream) {\n            const { stream: assetStream, ...assetData } = chunk as IAsset;\n            if (!hasStarted) {\n              assetID = randomUUID();\n              // Start the transfer of a new asset\n              batch.push({ action: 'start', assetID, data: assetData });\n              hasStarted = true;\n            }\n\n            for await (const assetChunk of assetStream) {\n              // Add the asset data to the batch\n              batch.push({ action: 'stream', assetID, data: assetChunk });\n\n              // if the batch size is bigger than BATCH_MAX_SIZE stream the batch\n              if (batchLength() >= BATCH_MAX_SIZE) {\n                yield batch;\n                batch = [];\n              }\n            }\n\n            // All the asset data has been streamed and gets ready for the next one\n            hasStarted = false;\n            batch.push({ action: 'end', assetID });\n            yield batch;\n            batch = [];\n          }\n        }\n\n        return Readable.from(generator(assets));\n      },\n    };\n\n    if (!(step in mapper)) {\n      throw new Error('Invalid transfer step, impossible to create a stream');\n    }\n\n    if (!this.streams) {\n      throw new Error('Invalid transfer state');\n    }\n\n    this.streams[step] = await mapper[step]();\n  },\n\n  // Commands\n  async init(this: PullHandler) {\n    if (this.transferID || this.provider) {\n      throw new Error('Transfer already in progress');\n    }\n    await this.verifyAuth();\n\n    this.transferID = randomUUID();\n    this.startedAt = Date.now();\n\n    this.streams = {};\n\n    this.provider = createLocalStrapiSourceProvider({\n      autoDestroy: false,\n      getStrapi: () => strapi as Core.Strapi,\n    });\n\n    return { transferID: this.transferID };\n  },\n\n  async end(\n    this: PullHandler,\n    params: Protocol.Client.GetCommandParams<'end'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.EndMessage>> {\n    await this.verifyAuth();\n\n    if (this.transferID !== params?.transferID) {\n      throw new ProviderTransferError('Bad transfer ID provided');\n    }\n\n    this.cleanup();\n\n    return { ok: true };\n  },\n\n  async status(this: PullHandler) {\n    const isStarted = this.isTransferStarted();\n\n    if (!isStarted) {\n      const startedAt = this.startedAt as number;\n      return {\n        active: true,\n        kind: TRANSFER_KIND,\n        startedAt,\n        elapsed: Date.now() - startedAt,\n      };\n    }\n    return { active: false, kind: null, elapsed: null, startedAt: null };\n  },\n}));\n","import path from 'path';\n\n/**\n * Note: in versions of the transfer engine <=4.9.0, exports were generated with windows paths\n * on Windows systems, and posix paths on posix systems.\n *\n * We now store all paths as posix, but need to leave a separator conversion for legacy purposes, and to\n * support manually-created tar files coming from Windows systems (ie, if a user creates a\n * backup file with a windows tar tool rather than using the `export` command)\n *\n * Because of this, export/import files may never contain files with a forward slash in the name, even escaped\n *\n * */\n\n/**\n * Check if the directory of a given filePath (which can be either posix or win32) resolves to the same as the given posix-format path posixDirName\n * We must be able to assume the first argument is a path to a directory and the second is a path to a file, otherwise path.dirname will interpret a path without any slashes as the filename\n *\n * @param {string} posixDirName A posix path pointing to a directory\n * @param {string} filePath an unknown filesystem path pointing to a file\n * @returns {boolean} is the file located in the given directory\n */\nexport const isFilePathInDirname = (posixDirName: string, filePath: string) => {\n  const normalizedDir = path.posix.dirname(unknownPathToPosix(filePath));\n  return isPathEquivalent(posixDirName, normalizedDir);\n};\n\n/**\n *  Check if two paths that can be either in posix or win32 format resolves to the same file\n *\n * @param {string} pathA a path that may be either win32 or posix\n * @param {string} pathB a path that may be either win32 or posix\n *\n * @returns {boolean} do paths point to the same place\n */\nexport const isPathEquivalent = (pathA: string, pathB: string) => {\n  // Check if paths appear to be win32 or posix, and if win32 convert to posix\n  const normalizedPathA = path.posix.normalize(unknownPathToPosix(pathA));\n  const normalizedPathB = path.posix.normalize(unknownPathToPosix(pathB));\n\n  return !path.posix.relative(normalizedPathB, normalizedPathA).length;\n};\n\n/**\n *  Convert an unknown format path (win32 or posix) to a posix path\n *\n * @param {string} filePath a path that may be either win32 or posix\n *\n * @returns {string} a posix path\n */\nexport const unknownPathToPosix = (filePath: string) => {\n  // if it includes a forward slash, it must be posix already -- we will not support win32 with mixed path separators\n  if (filePath.includes(path.posix.sep)) {\n    return filePath;\n  }\n\n  return path.normalize(filePath).split(path.win32.sep).join(path.posix.sep);\n};\n","import type { Readable } from 'stream';\n\nimport zip from 'zlib';\nimport path from 'path';\nimport { pipeline, PassThrough } from 'stream';\nimport fs from 'fs-extra';\nimport tar from 'tar';\nimport { isEmpty, keyBy } from 'lodash/fp';\nimport { chain } from 'stream-chain';\nimport { parser } from 'stream-json/jsonl/Parser';\nimport type { Struct } from '@strapi/types';\n\nimport type { IAsset, IMetadata, ISourceProvider, ProviderType, IFile } from '../../../../types';\n\nimport * as utils from '../../../utils';\nimport { ProviderInitializationError, ProviderTransferError } from '../../../errors/providers';\nimport { isFilePathInDirname, isPathEquivalent, unknownPathToPosix } from './utils';\n\ntype StreamItemArray = Parameters<typeof chain>[0];\n\n/**\n * Constant for the metadata file path\n */\nconst METADATA_FILE_PATH = 'metadata.json';\n\n/**\n * Provider options\n */\nexport interface ILocalFileSourceProviderOptions {\n  file: {\n    path: string; // the file to load\n  };\n\n  encryption: {\n    enabled: boolean; // if the file is encrypted (and should be decrypted)\n    key?: string; // the key to decrypt the file\n  };\n\n  compression: {\n    enabled: boolean; // if the file is compressed (and should be decompressed)\n  };\n}\n\nexport const createLocalFileSourceProvider = (options: ILocalFileSourceProviderOptions) => {\n  return new LocalFileSourceProvider(options);\n};\n\nclass LocalFileSourceProvider implements ISourceProvider {\n  type: ProviderType = 'source';\n\n  name = 'source::local-file';\n\n  options: ILocalFileSourceProviderOptions;\n\n  #metadata?: IMetadata;\n\n  constructor(options: ILocalFileSourceProviderOptions) {\n    this.options = options;\n\n    const { encryption } = this.options;\n\n    if (encryption.enabled && encryption.key === undefined) {\n      throw new Error('Missing encryption key');\n    }\n  }\n\n  /**\n   * Pre flight checks regarding the provided options, making sure that the file can be opened (decrypted, decompressed), etc.\n   */\n  async bootstrap() {\n    const { path: filePath } = this.options.file;\n\n    try {\n      // Read the metadata to ensure the file can be parsed\n      await this.#loadMetadata();\n      // TODO: we might also need to read the schema.jsonl files & implements a custom stream-check\n    } catch (e) {\n      if (this.options?.encryption?.enabled) {\n        throw new ProviderInitializationError(\n          `Key is incorrect or the file '${filePath}' is not a valid Strapi data file.`\n        );\n      }\n      throw new ProviderInitializationError(`File '${filePath}' is not a valid Strapi data file.`);\n    }\n\n    if (!this.#metadata) {\n      throw new ProviderInitializationError('Could not load metadata from Strapi data file.');\n    }\n  }\n\n  async #loadMetadata() {\n    const backupStream = this.#getBackupStream();\n    this.#metadata = await this.#parseJSONFile<IMetadata>(backupStream, METADATA_FILE_PATH);\n  }\n\n  async #loadAssetMetadata(path: string) {\n    const backupStream = this.#getBackupStream();\n    return this.#parseJSONFile<IFile>(backupStream, path);\n  }\n\n  async getMetadata() {\n    if (!this.#metadata) {\n      await this.#loadMetadata();\n    }\n\n    return this.#metadata ?? null;\n  }\n\n  async getSchemas() {\n    const schemaCollection = await utils.stream.collect<Struct.Schema>(\n      this.createSchemasReadStream()\n    );\n\n    if (isEmpty(schemaCollection)) {\n      throw new ProviderInitializationError('Could not load schemas from Strapi data file.');\n    }\n\n    // Group schema by UID\n    const schemas = keyBy('uid', schemaCollection);\n\n    // Transform to valid JSON\n    return utils.schema.schemasToValidJSON(schemas);\n  }\n\n  createEntitiesReadStream(): Readable {\n    return this.#streamJsonlDirectory('entities');\n  }\n\n  createSchemasReadStream(): Readable {\n    return this.#streamJsonlDirectory('schemas');\n  }\n\n  createLinksReadStream(): Readable {\n    return this.#streamJsonlDirectory('links');\n  }\n\n  createConfigurationReadStream(): Readable {\n    // NOTE: TBD\n    return this.#streamJsonlDirectory('configuration');\n  }\n\n  createAssetsReadStream(): Readable | Promise<Readable> {\n    const inStream = this.#getBackupStream();\n    const outStream = new PassThrough({ objectMode: true });\n    const loadAssetMetadata = this.#loadAssetMetadata.bind(this);\n\n    pipeline(\n      [\n        inStream,\n        new tar.Parse({\n          // find only files in the assets/uploads folder\n          filter(filePath, entry) {\n            if (entry.type !== 'File') {\n              return false;\n            }\n            return isFilePathInDirname('assets/uploads', filePath);\n          },\n          async onentry(entry) {\n            const { path: filePath, size = 0 } = entry;\n            const normalizedPath = unknownPathToPosix(filePath);\n            const file = path.basename(normalizedPath);\n            let metadata;\n            try {\n              metadata = await loadAssetMetadata(`assets/metadata/${file}.json`);\n            } catch (error) {\n              console.warn(\n                ` Failed to read metadata for ${file}, Strapi will try to fix this issue automatically`\n              );\n            }\n            const asset: IAsset = {\n              metadata,\n              filename: file,\n              filepath: normalizedPath,\n              stats: { size },\n              stream: entry as unknown as Readable,\n            };\n            outStream.write(asset);\n          },\n        }),\n      ],\n      () => outStream.end()\n    );\n\n    return outStream;\n  }\n\n  #getBackupStream() {\n    const { file, encryption, compression } = this.options;\n\n    const streams: StreamItemArray = [];\n\n    try {\n      streams.push(fs.createReadStream(file.path));\n    } catch (e) {\n      throw new Error(`Could not read backup file path provided at \"${this.options.file.path}\"`);\n    }\n\n    if (encryption.enabled && encryption.key) {\n      streams.push(utils.encryption.createDecryptionCipher(encryption.key));\n    }\n\n    if (compression.enabled) {\n      streams.push(zip.createGunzip());\n    }\n\n    return chain(streams);\n  }\n\n  // `directory` must be posix formatted path\n  #streamJsonlDirectory(directory: string) {\n    const inStream = this.#getBackupStream();\n\n    const outStream = new PassThrough({ objectMode: true });\n\n    pipeline(\n      [\n        inStream,\n        new tar.Parse({\n          filter(filePath, entry) {\n            if (entry.type !== 'File') {\n              return false;\n            }\n\n            return isFilePathInDirname(directory, filePath);\n          },\n\n          async onentry(entry) {\n            const transforms = [\n              // JSONL parser to read the data chunks one by one (line by line)\n              parser({\n                checkErrors: true,\n              }),\n              // The JSONL parser returns each line as key/value\n              (line: { key: string; value: object }) => line.value,\n            ];\n\n            const stream = entry.pipe(chain(transforms));\n\n            try {\n              for await (const chunk of stream) {\n                outStream.write(chunk);\n              }\n            } catch (e: unknown) {\n              outStream.destroy(\n                new ProviderTransferError(\n                  `Error parsing backup files from backup file ${entry.path}: ${\n                    (e as Error).message\n                  }`,\n                  {\n                    details: {\n                      error: e,\n                    },\n                  }\n                )\n              );\n            }\n          },\n        }),\n      ],\n      async () => {\n        // Manually send the 'end' event to the out stream\n        // once every entry has finished streaming its content\n        outStream.end();\n      }\n    );\n\n    return outStream;\n  }\n\n  // For collecting an entire JSON file then parsing it, not for streaming JSONL\n  async #parseJSONFile<T extends object>(fileStream: Readable, filePath: string): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      pipeline(\n        [\n          fileStream,\n          // Custom backup archive parsing\n          new tar.Parse({\n            /**\n             * Filter the parsed entries to only keep the one that matches the given filepath\n             */\n            filter(entryPath, entry) {\n              if (entry.type !== 'File') {\n                return false;\n              }\n\n              return isPathEquivalent(entryPath, filePath);\n            },\n\n            async onentry(entry) {\n              // Collect all the content of the entry file\n              const content = await entry.collect();\n\n              try {\n                // Parse from buffer array to string to JSON\n                const parsedContent = JSON.parse(Buffer.concat(content).toString());\n\n                // Resolve the Promise with the parsed content\n                resolve(parsedContent);\n              } catch (e) {\n                reject(e);\n              } finally {\n                // Cleanup (close the stream associated to the entry)\n                entry.destroy();\n              }\n            },\n          }),\n        ],\n        () => {\n          // If the promise hasn't been resolved and we've parsed all\n          // the archive entries, then the file doesn't exist\n          reject(new Error(`File \"${filePath}\" not found`));\n        }\n      );\n    });\n  }\n}\n","import { Writable } from 'stream';\nimport { posix } from 'path';\nimport tar from 'tar-stream';\n\n/**\n * Create a file path factory for a given path & prefix.\n * Upon being called, the factory will return a file path for a given index\n */\nexport const createFilePathFactory =\n  (type: string) =>\n  (fileIndex = 0): string => {\n    // always write tar files with posix paths so we have a standard format for paths regardless of system\n    return posix.join(\n      // \"{type}\" directory\n      type,\n      // \"${type}_XXXXX.jsonl\" file\n      `${type}_${String(fileIndex).padStart(5, '0')}.jsonl`\n    );\n  };\n\nexport const createTarEntryStream = (\n  archive: tar.Pack,\n  pathFactory: (index?: number) => string,\n  maxSize = 2.56e8\n) => {\n  let fileIndex = 0;\n  let buffer = '';\n\n  const flush = async () => {\n    if (!buffer) {\n      return;\n    }\n\n    fileIndex += 1;\n    const name = pathFactory(fileIndex);\n    const size = buffer.length;\n\n    await new Promise<void>((resolve, reject) => {\n      archive.entry({ name, size }, buffer, (err) => {\n        if (err) {\n          reject(err);\n        }\n\n        resolve();\n      });\n    });\n\n    buffer = '';\n  };\n\n  const push = (chunk: string | Buffer) => {\n    buffer += chunk;\n  };\n\n  return new Writable({\n    async destroy(err, callback) {\n      await flush();\n      callback(err);\n    },\n\n    async write(chunk, _encoding, callback) {\n      const size = chunk.length;\n\n      if (chunk.length > maxSize) {\n        callback(new Error(`payload too large: ${chunk.length}>${maxSize}`));\n        return;\n      }\n\n      if (buffer.length + size > maxSize) {\n        await flush();\n      }\n\n      push(chunk);\n\n      callback(null);\n    },\n  });\n};\n","import path from 'path';\nimport zlib from 'zlib';\nimport { Readable, Writable } from 'stream';\nimport { rm, createWriteStream } from 'fs-extra';\nimport tar from 'tar-stream';\nimport { stringer } from 'stream-json/jsonl/Stringer';\nimport { chain } from 'stream-chain';\n\nimport { createEncryptionCipher } from '../../../utils/encryption';\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IDestinationProviderTransferResults,\n  IMetadata,\n  ProviderType,\n  Stream,\n} from '../../../../types';\nimport { createFilePathFactory, createTarEntryStream } from './utils';\nimport { ProviderTransferError } from '../../../errors/providers';\n\nexport interface ILocalFileDestinationProviderOptions {\n  encryption: {\n    enabled: boolean; // if the file should be encrypted\n    key?: string; // the key to use when encryption.enabled is true\n  };\n\n  compression: {\n    enabled: boolean; // if the file should be compressed with gzip\n  };\n\n  file: {\n    path: string; // the filename to create\n    maxSize?: number; // the max size of a single backup file\n    maxSizeJsonl?: number; // the max lines of each jsonl file before creating the next file\n  };\n}\n\nexport interface ILocalFileDestinationProviderTransferResults\n  extends IDestinationProviderTransferResults {\n  file?: {\n    path?: string;\n  };\n}\n\nexport const createLocalFileDestinationProvider = (\n  options: ILocalFileDestinationProviderOptions\n) => {\n  return new LocalFileDestinationProvider(options);\n};\n\nclass LocalFileDestinationProvider implements IDestinationProvider {\n  name = 'destination::local-file';\n\n  type: ProviderType = 'destination';\n\n  options: ILocalFileDestinationProviderOptions;\n\n  results: ILocalFileDestinationProviderTransferResults = {};\n\n  #providersMetadata: { source?: IMetadata; destination?: IMetadata } = {};\n\n  #archive: { stream?: tar.Pack; pipeline?: Stream } = {};\n\n  constructor(options: ILocalFileDestinationProviderOptions) {\n    this.options = options;\n  }\n\n  get #archivePath() {\n    const { encryption, compression, file } = this.options;\n\n    let filePath = `${file.path}.tar`;\n\n    if (compression.enabled) {\n      filePath += '.gz';\n    }\n\n    if (encryption.enabled) {\n      filePath += '.enc';\n    }\n\n    return filePath;\n  }\n\n  setMetadata(target: ProviderType, metadata: IMetadata): IDestinationProvider {\n    this.#providersMetadata[target] = metadata;\n\n    return this;\n  }\n\n  createGzip(): zlib.Gzip {\n    return zlib.createGzip();\n  }\n\n  bootstrap(): void | Promise<void> {\n    const { compression, encryption } = this.options;\n\n    if (encryption.enabled && !encryption.key) {\n      throw new Error(\"Can't encrypt without a key\");\n    }\n\n    this.#archive.stream = tar.pack();\n\n    const outStream = createWriteStream(this.#archivePath);\n\n    outStream.on('error', (err: NodeJS.ErrnoException) => {\n      if (err.code === 'ENOSPC') {\n        throw new ProviderTransferError(\n          \"Your server doesn't have space to proceed with the import.\"\n        );\n      }\n      throw err;\n    });\n\n    const archiveTransforms: Stream[] = [];\n\n    if (compression.enabled) {\n      archiveTransforms.push(this.createGzip());\n    }\n\n    if (encryption.enabled && encryption.key) {\n      archiveTransforms.push(createEncryptionCipher(encryption.key));\n    }\n\n    this.#archive.pipeline = chain([this.#archive.stream, ...archiveTransforms, outStream]);\n\n    this.results.file = { path: this.#archivePath };\n  }\n\n  async close() {\n    const { stream, pipeline } = this.#archive;\n\n    if (!stream) {\n      return;\n    }\n\n    await this.#writeMetadata();\n    stream.finalize();\n\n    if (pipeline && !pipeline.closed) {\n      await new Promise<void>((resolve, reject) => {\n        pipeline.on('close', resolve).on('error', reject);\n      });\n    }\n  }\n\n  async rollback(): Promise<void> {\n    await this.close();\n    await rm(this.#archivePath, { force: true });\n  }\n\n  getMetadata() {\n    return null;\n  }\n\n  async #writeMetadata(): Promise<void> {\n    const metadata = this.#providersMetadata.source;\n\n    if (metadata) {\n      await new Promise((resolve) => {\n        const outStream = this.#getMetadataStream();\n        const data = JSON.stringify(metadata, null, 2);\n\n        Readable.from(data).pipe(outStream).on('close', resolve);\n      });\n    }\n  }\n\n  #getMetadataStream() {\n    const { stream } = this.#archive;\n\n    if (!stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    return createTarEntryStream(stream, () => 'metadata.json');\n  }\n\n  createSchemasWriteStream() {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    const filePathFactory = createFilePathFactory('schemas');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createEntitiesWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    const filePathFactory = createFilePathFactory('entities');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createLinksWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    const filePathFactory = createFilePathFactory('links');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createConfigurationWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    const filePathFactory = createFilePathFactory('configuration');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createAssetsWriteStream(): Writable {\n    const { stream: archiveStream } = this.#archive;\n\n    if (!archiveStream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    return new Writable({\n      objectMode: true,\n      write(data: IAsset, _encoding, callback) {\n        // always write tar files with posix paths so we have a standard format for paths regardless of system\n        const entryPath = path.posix.join('assets', 'uploads', data.filename);\n\n        const entryMetadataPath = path.posix.join('assets', 'metadata', `${data.filename}.json`);\n        const stringifiedMetadata = JSON.stringify(data.metadata);\n        archiveStream.entry(\n          {\n            name: entryMetadataPath,\n            size: stringifiedMetadata.length,\n          },\n          stringifiedMetadata\n        );\n\n        const entry = archiveStream.entry({\n          name: entryPath,\n          size: data.stats.size,\n        });\n\n        if (!entry) {\n          callback(new Error(`Failed to created an asset tar entry for ${entryPath}`));\n          return;\n        }\n\n        data.stream.pipe(entry);\n\n        entry\n          .on('finish', () => {\n            callback(null);\n          })\n          .on('error', (error) => {\n            callback(error);\n          });\n      },\n    });\n  }\n}\n"],"names":["strategies","stream","reject","path","strapi","diff","utils.json.diff","origin","utils.middleware.runMiddleware","utils.stream.filter","utils.stream.map","size","semverDiff","entity","schema","link","contentTypesUtils","omitInvalidCreationAttributes","componentsService.createComponents","componentsService.getComponents","componentsService.deleteComponents","map","transaction","queries.entity.createEntityQuery","json.diff","contentTypes","filter","utils.transaction.createTransaction","restore.deleteRecords","utils.schema.schemasToValidJSON","utils.schema.mapSchemasValues","restore.createEntitiesWriteStream","entry","restore.createConfigurationWriteStream","restore.createLinksWriteStream","shared.entity.createEntityQuery","file","message","err","cb","VALID_TRANSFER_ACTIONS","TRANSFER_KIND","utils.stream.collect","fs","utils.encryption.createDecryptionCipher","zip","zlib","tar","pipeline"],"mappings":"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"}