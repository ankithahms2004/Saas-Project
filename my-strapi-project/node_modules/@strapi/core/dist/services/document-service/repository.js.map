{"version":3,"file":"repository.js","sources":["../../../src/services/document-service/repository.ts"],"sourcesContent":["import { omit, assoc, merge, curry } from 'lodash/fp';\n\nimport { async, contentTypes as contentTypesUtils, validate } from '@strapi/utils';\n\nimport { UID } from '@strapi/types';\nimport { wrapInTransaction, type RepositoryFactoryMethod } from './common';\nimport * as DP from './draft-and-publish';\nimport * as i18n from './internationalization';\nimport * as components from './components';\n\nimport { createEntriesService } from './entries';\nimport { pickSelectionParams } from './params';\nimport { createDocumentId } from '../../utils/transform-content-types-to-models';\nimport { getDeepPopulate } from './utils/populate';\nimport { transformParamsToQuery } from './transform/query';\nimport { transformParamsDocumentId } from './transform/id-transform';\nimport { createEventManager } from './events';\nimport * as unidirectionalRelations from './utils/unidirectional-relations';\n\nconst { validators } = validate;\n\n// we have to typecast to reconcile the differences between validator and database getModel\nconst getModel = ((schema: UID.Schema) => strapi.getModel(schema)) as (schema: string) => any;\n\nexport const createContentTypeRepository: RepositoryFactoryMethod = (uid) => {\n  const contentType = strapi.contentType(uid);\n  const hasDraftAndPublish = contentTypesUtils.hasDraftAndPublish(contentType);\n\n  // Define the validations that should be performed\n  const sortValidations = ['nonAttributesOperators', 'dynamicZones', 'morphRelations'];\n  const fieldValidations = ['scalarAttributes'];\n  const filtersValidations = ['nonAttributesOperators', 'dynamicZones', 'morphRelations'];\n  const populateValidations = {\n    sort: sortValidations,\n    field: fieldValidations,\n    filters: filtersValidations,\n    populate: ['nonAttributesOperators'],\n  };\n\n  const validateParams = async (params: any) => {\n    const ctx = { schema: contentType, getModel };\n    await validators.validateFilters(ctx, params.filters, filtersValidations);\n    await validators.validateSort(ctx, params.sort, sortValidations);\n    await validators.validateFields(ctx, params.fields, fieldValidations);\n    await validators.validatePopulate(ctx, params.populate, populateValidations);\n\n    // TODO: add validate status, locale, pagination\n\n    return params;\n  };\n\n  const entries = createEntriesService(uid);\n\n  const eventManager = createEventManager(strapi, uid);\n  const emitEvent = curry(eventManager.emitEvent);\n\n  async function findMany(params = {} as any) {\n    const query = await async.pipe(\n      validateParams,\n      DP.defaultToDraft,\n      DP.statusToLookup(contentType),\n      i18n.defaultLocale(contentType),\n      i18n.multiLocaleToLookup(contentType),\n      transformParamsDocumentId(uid),\n      transformParamsToQuery(uid)\n    )(params || {});\n\n    return strapi.db.query(uid).findMany(query);\n  }\n\n  async function findFirst(params = {} as any) {\n    const query = await async.pipe(\n      validateParams,\n      DP.defaultToDraft,\n      DP.statusToLookup(contentType),\n      i18n.defaultLocale(contentType),\n      i18n.localeToLookup(contentType),\n      transformParamsDocumentId(uid),\n      transformParamsToQuery(uid)\n    )(params);\n\n    return strapi.db.query(uid).findOne(query);\n  }\n\n  // TODO: do we really want to add filters on the findOne now that we have findFirst ?\n  async function findOne(opts = {} as any) {\n    const { documentId, ...params } = opts;\n\n    const query = await async.pipe(\n      validateParams,\n      DP.defaultToDraft,\n      DP.statusToLookup(contentType),\n      i18n.defaultLocale(contentType),\n      i18n.localeToLookup(contentType),\n      transformParamsDocumentId(uid),\n      transformParamsToQuery(uid),\n      (query) => assoc('where', { ...query.where, documentId }, query)\n    )(params);\n\n    return strapi.db.query(uid).findOne(query);\n  }\n\n  async function deleteDocument(opts = {} as any) {\n    const { documentId, ...params } = opts;\n\n    const query = await async.pipe(\n      validateParams,\n      omit('status'),\n      i18n.defaultLocale(contentType),\n      i18n.multiLocaleToLookup(contentType),\n      transformParamsToQuery(uid),\n      (query) => assoc('where', { ...query.where, documentId }, query)\n    )(params);\n\n    if (params.status === 'draft') {\n      throw new Error('Cannot delete a draft document');\n    }\n\n    const entriesToDelete = await strapi.db.query(uid).findMany(query);\n\n    // Delete all matched entries and its components\n    const deletedEntries = await async.map(entriesToDelete, (entryToDelete: any) =>\n      entries.delete(entryToDelete.id)\n    );\n\n    entriesToDelete.forEach(emitEvent('entry.delete'));\n\n    return { documentId, entries: deletedEntries };\n  }\n\n  async function create(opts = {} as any) {\n    const { documentId, ...params } = opts;\n\n    const queryParams = await async.pipe(\n      validateParams,\n      DP.filterDataPublishedAt,\n      DP.setStatusToDraft(contentType),\n      DP.statusToData(contentType),\n      i18n.defaultLocale(contentType),\n      i18n.localeToData(contentType)\n    )(params);\n\n    const doc = await entries.create(queryParams);\n\n    emitEvent('entry.create', doc);\n\n    if (hasDraftAndPublish && params.status === 'published') {\n      return publish({\n        ...params,\n        documentId: doc.documentId,\n      }).then((doc) => doc.entries[0]);\n    }\n\n    return doc;\n  }\n\n  async function clone(opts = {} as any) {\n    const { documentId, ...params } = opts;\n\n    const queryParams = await async.pipe(\n      validateParams,\n      DP.filterDataPublishedAt,\n      i18n.defaultLocale(contentType),\n      i18n.multiLocaleToLookup(contentType)\n    )(params);\n\n    // Get deep populate\n    const entriesToClone = await strapi.db.query(uid).findMany({\n      where: {\n        ...queryParams?.lookup,\n        documentId,\n        // DP Enabled: Clone drafts\n        // DP Disabled: Clone only the existing version (published)\n        publishedAt: { $null: hasDraftAndPublish },\n      },\n      populate: getDeepPopulate(uid, { relationalFields: ['id'] }),\n    });\n\n    const clonedEntries = await async.map(\n      entriesToClone,\n      async.pipe(\n        validateParams,\n        omit('id'),\n        // assign new documentId\n        assoc('documentId', createDocumentId()),\n        // Merge new data into it\n        (data) => merge(data, queryParams.data),\n        (data) => entries.create({ ...queryParams, data, status: 'draft' })\n      )\n    );\n\n    clonedEntries.forEach(emitEvent('entry.create'));\n\n    return { documentId: clonedEntries.at(0)?.documentId, entries: clonedEntries };\n  }\n\n  async function update(opts = {} as any) {\n    const { documentId, ...params } = opts;\n\n    const queryParams = await async.pipe(\n      validateParams,\n      DP.filterDataPublishedAt,\n      DP.setStatusToDraft(contentType),\n      DP.statusToLookup(contentType),\n      DP.statusToData(contentType),\n      // Default locale will be set if not provided\n      i18n.defaultLocale(contentType),\n      i18n.localeToLookup(contentType),\n      i18n.localeToData(contentType)\n    )(params);\n\n    const { data, ...restParams } = await transformParamsDocumentId(uid, queryParams || {});\n    const query = transformParamsToQuery(uid, pickSelectionParams(restParams || {}) as any);\n\n    // Validation\n    // Find if document exists\n    const entryToUpdate = await strapi.db\n      .query(uid)\n      .findOne({ ...query, where: { ...queryParams?.lookup, ...query?.where, documentId } });\n\n    let updatedDraft = null;\n    if (entryToUpdate) {\n      updatedDraft = await entries.update(entryToUpdate, queryParams);\n      emitEvent('entry.update', updatedDraft);\n    }\n\n    if (!updatedDraft) {\n      const documentExists = await strapi.db\n        .query(contentType.uid)\n        .findOne({ where: { documentId } });\n\n      if (documentExists) {\n        updatedDraft = await entries.create({\n          ...queryParams,\n          data: { ...queryParams.data, documentId },\n        });\n        emitEvent('entry.create', updatedDraft);\n      }\n    }\n\n    if (hasDraftAndPublish && updatedDraft && params.status === 'published') {\n      return publish({\n        ...params,\n        documentId,\n      }).then((doc) => doc.entries[0]);\n    }\n\n    return updatedDraft;\n  }\n\n  async function count(params = {} as any) {\n    const query = await async.pipe(\n      validateParams,\n      DP.defaultStatus(contentType),\n      DP.statusToLookup(contentType),\n      i18n.defaultLocale(contentType),\n      i18n.localeToLookup(contentType),\n      transformParamsToQuery(uid)\n    )(params);\n\n    return strapi.db.query(uid).count(query);\n  }\n\n  async function publish(opts = {} as any) {\n    const { documentId, ...params } = opts;\n\n    const queryParams = await async.pipe(\n      validateParams,\n      i18n.defaultLocale(contentType),\n      i18n.multiLocaleToLookup(contentType)\n    )(params);\n\n    const [draftsToPublish, oldPublishedVersions] = await Promise.all([\n      strapi.db.query(uid).findMany({\n        where: {\n          ...queryParams?.lookup,\n          documentId,\n          publishedAt: null, // Ignore lookup\n        },\n        // Populate relations, media, compos and dz\n        populate: getDeepPopulate(uid, { relationalFields: ['documentId', 'locale'] }),\n      }),\n      strapi.db.query(uid).findMany({\n        where: {\n          ...queryParams?.lookup,\n          documentId,\n          publishedAt: { $ne: null },\n        },\n        select: ['id', 'locale'],\n      }),\n    ]);\n\n    // Load any unidirectional relation targetting the old published entries\n    const relationsToSync = await unidirectionalRelations.load(uid, oldPublishedVersions);\n\n    // Delete old published versions\n    await async.map(oldPublishedVersions, (entry: any) => entries.delete(entry.id));\n\n    // Transform draft entry data and create published versions\n    const publishedEntries = await async.map(draftsToPublish, (draft: any) =>\n      entries.publish(draft, queryParams)\n    );\n\n    // Sync unidirectional relations with the new published entries\n    await unidirectionalRelations.sync(oldPublishedVersions, publishedEntries, relationsToSync);\n\n    publishedEntries.forEach(emitEvent('entry.publish'));\n\n    return { documentId, entries: publishedEntries };\n  }\n\n  async function unpublish(opts = {} as any) {\n    const { documentId, ...params } = opts;\n\n    const query = await async.pipe(\n      validateParams,\n      i18n.defaultLocale(contentType),\n      i18n.multiLocaleToLookup(contentType),\n      transformParamsToQuery(uid),\n      (query) => assoc('where', { ...query.where, documentId, publishedAt: { $ne: null } }, query)\n    )(params);\n\n    // Delete all published versions\n    const versionsToDelete = await strapi.db.query(uid).findMany(query);\n    await async.map(versionsToDelete, (entry: any) => entries.delete(entry.id));\n\n    versionsToDelete.forEach(emitEvent('entry.unpublish'));\n    return { documentId, entries: versionsToDelete };\n  }\n\n  async function discardDraft(opts = {} as any) {\n    const { documentId, ...params } = opts;\n\n    const queryParams = await async.pipe(\n      validateParams,\n      i18n.defaultLocale(contentType),\n      i18n.multiLocaleToLookup(contentType)\n    )(params);\n\n    const [versionsToDraft, oldDrafts] = await Promise.all([\n      strapi.db.query(uid).findMany({\n        where: {\n          ...queryParams?.lookup,\n          documentId,\n          publishedAt: { $ne: null },\n        },\n        // Populate relations, media, compos and dz\n        populate: getDeepPopulate(uid, { relationalFields: ['documentId', 'locale'] }),\n      }),\n      strapi.db.query(uid).findMany({\n        where: {\n          ...queryParams?.lookup,\n          documentId,\n          publishedAt: null,\n        },\n        select: ['id', 'locale'],\n      }),\n    ]);\n\n    // Load any unidirectional relation targeting the old drafts\n    const relationsToSync = await unidirectionalRelations.load(uid, oldDrafts);\n\n    // Delete old drafts\n    await async.map(oldDrafts, (entry: any) => entries.delete(entry.id));\n\n    // Transform published entry data and create draft versions\n    const draftEntries = await async.map(versionsToDraft, (entry: any) =>\n      entries.discardDraft(entry, queryParams)\n    );\n\n    // Sync unidirectional relations with the new draft entries\n    await unidirectionalRelations.sync(oldDrafts, draftEntries, relationsToSync);\n\n    draftEntries.forEach(emitEvent('entry.draft-discard'));\n    return { documentId, entries: draftEntries };\n  }\n\n  async function updateComponents(entry: any, data: any) {\n    return components.updateComponents(uid, entry, data);\n  }\n\n  function omitComponentData(data: any) {\n    return components.omitComponentData(contentType, data);\n  }\n\n  return {\n    findMany: wrapInTransaction(findMany),\n    findFirst: wrapInTransaction(findFirst),\n    findOne: wrapInTransaction(findOne),\n    delete: wrapInTransaction(deleteDocument),\n    create: wrapInTransaction(create),\n    clone: wrapInTransaction(clone),\n    update: wrapInTransaction(update),\n    count: wrapInTransaction(count),\n    publish: hasDraftAndPublish ? wrapInTransaction(publish) : (undefined as any),\n    unpublish: hasDraftAndPublish ? wrapInTransaction(unpublish) : (undefined as any),\n    discardDraft: hasDraftAndPublish ? wrapInTransaction(discardDraft) : (undefined as any),\n\n    updateComponents,\n    omitComponentData,\n  };\n};\n"],"names":["validate","contentTypesUtils","params","entries","createEntriesService","createEventManager","curry","query","async","DP.defaultToDraft","DP.statusToLookup","i18n.defaultLocale","i18n.multiLocaleToLookup","transformParamsDocumentId","transformParamsToQuery","i18n.localeToLookup","assoc","omit","DP.filterDataPublishedAt","DP.setStatusToDraft","DP.statusToData","i18n.localeToData","doc","getDeepPopulate","createDocumentId","merge","pickSelectionParams","DP.defaultStatus","unidirectionalRelations.load","unidirectionalRelations.sync","components.updateComponents","components.omitComponentData","wrapInTransaction"],"mappings":"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"}